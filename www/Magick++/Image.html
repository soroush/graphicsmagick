<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.78 [en] (X11; U; SunOS 5.6 sun4u) [Netscape]">
   <meta name="Author" content="Bob Friesenhahn">
   <meta name="Description" content="Description of Magick::Image Class">
   <title>Magick::Image Class</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">

<center>
<h1>
Magick::Image Class</h1></center>

<h4>
Quick Contents</h4>

<ul>
<li>
<a href="#BLOBs">BLOBs</a></li>

<li>
<a href="#Constructors">Constructors</a></li>

<li>
<a href="#Image Manipulation Methods">Image Manipulation Methods</a></li>

<li>
<a href="#Image Attributes">Image Attributes</a></li>

<li>
<a href="#Raw Image Pixel Access">Raw Image Pixel Access</a></li>
</ul>

<hr WIDTH="100%">Image is the primary object in Magick++ and represents
a single image frame (see <a href="ImageDesign.html">design</a>). The <a href="STL.html">STL
interface</a> <b>must</b> be used to operate on image sequences or images
(e.g. of format GIF, TIFF, MIFF, Postscript, &amp; MNG) which are comprized
of multiple image frames. Individual frames of a multi-frame image may
be requested by adding array-style notation to the end of the file name
(e.g. "animation.gif[3]" retrieves the fourth frame of a GIF animation.&nbsp;
Various image manipulation operations may be applied to the image. Attributes
may be set on the image to influence the operation of the manipulation
operations. The <a href="Pixels.html">Pixels</a> class provides low-level
access to image pixels. As a convenience, including
<tt>&lt;Magick++.h></tt>
is sufficient in order to use the complete Magick++ API. The Magick++ API
is enclosed within the <i>Magick</i> namespace so you must either add the
prefix "<tt>Magick::</tt>" to each class/enumeration name or add the statement
"<tt>using namespace Magick;</tt>" after including the <tt>Magick++.h </tt>header.
<p>The preferred way to allocate Image objects is via automatic allocation
(on the stack). There is no concern that allocating Image objects on the
stack will excessively enlarge the stack since Magick++ allocates all large
data objects (such as the actual image data) from the heap. Use of automatic
allocation is preferred over explicit allocation (via <i>new</i>) since
it is much less error prone and allows use of C++ scoping rules to avoid
memory leaks. Use of automatic allocation allows Magick++ objects to be
assigned and copied just like the C++ intrinsic data types (e.g. '<i>int</i>'),
leading to clear and easy to read code. Use of automatic allocation leads
to naturally exception-safe code since if an exception is thrown, the object
is automatically deallocated once the stack unwinds past the scope of the
allocation (not the case for objects allocated via <i>new</i>).
<p>Image is very easy to use. For example, here is a the source to a program
which reads an image, crops it, and writes it to a new file (the exception
handling is optional but strongly recommended):
<blockquote><tt><font color="#000066">#include &lt;Magick++.h></font></tt>
<br><tt><font color="#000066">#include &lt;iostream></font></tt>
<br><tt><font color="#000066">using namespace std;</font></tt>
<br><tt><font color="#000066">using namespace Magick;</font></tt>
<br><tt><font color="#000066">int main(int argc,char **argv)</font></tt>
<br><tt><font color="#000066">{</font></tt>
<br><tt><font color="#000066">&nbsp; try {</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; // Create an image object
and read an image</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; Image image( "girl.gif"
);</font></tt>
<p><tt><font color="#000066">&nbsp;&nbsp;&nbsp; // Crop the image to specified
size</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; // (Geometry implicitly
initialized by char *)</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; image.crop("100x100+100+100"
);</font></tt>
<p><tt><font color="#000066">&nbsp;&nbsp;&nbsp; // Write the image to a
file</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; image.write( "x.gif" );</font></tt>
<br><tt><font color="#000066">&nbsp; }</font></tt>
<br><tt><font color="#000066">&nbsp; catch( Exception &amp;error_ )</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; {</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;
"Caught exception: " &lt;&lt; error_.what() &lt;&lt; endl;</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; }</font></tt>
<br><tt><font color="#000066">&nbsp; return 0;</font></tt>
<br><tt><font color="#000066">}</font></tt></blockquote>
The following is the source to a program which illustrates the use of Magick++'s
efficient reference-counted assignment and copy-constructor operations
which minimize use of memory and eliminate unncessary copy operations (allowing
Image objects to be efficiently assigned, and copied into containers).&nbsp;
The program accomplishes the following:
<ol>
<li>
Read master image.</li>

<li>
Assign master image to second image.</li>

<li>
Zoom second image to the size 640x480.</li>

<li>
Assign master image to a third image.</li>

<li>
Zoom third image to the size 800x600.</li>

<li>
Write the second image to a file.</li>

<li>
Write the third image to a file.</li>
</ol>

<blockquote><tt><font color="#000066">#include &lt;Magick++.h></font></tt>
<br><tt><font color="#000066">#include &lt;iostream></font></tt>
<br><tt><font color="#000066">using namespace std;</font></tt>
<br><tt><font color="#000066">using namespace Magick;</font></tt>
<br><tt><font color="#000066">int main(int argc,char **argv)</font></tt>
<br><tt><font color="#000066">{</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; Image master("horse.jpg");</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; Image second = master;</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; second.zoom("640x480");</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; Image third = master;</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; third.zoom("800x600");</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; second.write("horse640x480.jpg");</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; third.write("horse800x600.jpg");</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; return 0;</font></tt>
<br><tt><font color="#000066">}</font></tt></blockquote>
During the entire operation, a maximum of three images exist in memory
and the image data is never copied.
<p>The following is the source for another simple program which creates
a 100 by 100 pixel white image with a red pixel in the center and writes
it to a file:
<blockquote><tt><font color="#000066">#include &lt;Magick++.h></font></tt>
<br><tt><font color="#000066">using namespace std;</font></tt>
<br><tt><font color="#000066">using namespace Magick;</font></tt>
<br><tt><font color="#000066">int main(int argc,char **argv)</font></tt>
<br><tt><font color="#000066">{</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; Image image( "100x100",
"white" );</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; image.pixelColor( 49,
49, "red" );</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; image.write( "red_pixel.png"
);</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; return 0;</font></tt>
<br><tt><font color="#000066">}</font></tt></blockquote>
If you wanted to change the color image to grayscale, you could add the
lines:
<p><tt><font color="#000066">&nbsp;&nbsp;&nbsp; image.quantizeColorSpace(
GRAYColorspace );</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; image.colors( 256 );</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; image.quantize( );</font></tt>
<p>or, more simply:
<p><tt><font color="#000066">&nbsp;&nbsp;&nbsp; image.type( GrayscaleType
);</font></tt>
<p>prior to writing the image.
<center>
<h3>
<a NAME="BLOBs"></a>BLOBs</h3></center>
While encoded images (e.g. JPEG) are most often written-to and read-from
a disk file, encoded images may also reside in memory. Encoded images in
memory are known as BLOBs (Binary Large OBjects) and may be represented
using the <a href="Blob.html">Blob</a> class. The encoded image may be
initially placed in memory by reading it directly from a file, reading
the image from a database, memory-mapped from a disk file, or could be
written to memory by Magick++. Once the encoded image has been placed within
a Blob, it may be read into a Magick++ Image via a <a href="#constructor_blob">constructor</a>
or <a href="#read">read()</a>. Likewise, a Magick++ image may be written
to a Blob via <a href="#write">write()</a>.
<p>An example of using Image to write to a Blob follows:
<br>&nbsp;
<blockquote><tt><font color="#000066">#include &lt;Magick++.h></font></tt>
<br><tt><font color="#000066">using namespace std;</font></tt>
<br><tt><font color="#000066">using namespace Magick;</font></tt>
<br><tt><font color="#000066">int main(int argc,char **argv)</font></tt>
<br><tt><font color="#000066">{</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; // Read GIF file from
disk</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; Image image( "giraffe.gif"
);</font></tt>
<p><tt><font color="#000066">&nbsp;&nbsp;&nbsp; // Write to BLOB in JPEG
format</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; Blob blob;</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; image.magick( "JPEG" )
// Set JPEG output format</font></tt>
<br><tt><font color="#000066">&nbsp;&nbsp;&nbsp; image.write( &amp;blob
);</font></tt>
<p><tt><font color="#000066">&nbsp;&nbsp;&nbsp; [ Use BLOB data (in JPEG
format) here ]</font></tt>
<p><tt><font color="#000066">&nbsp;&nbsp;&nbsp; return 0;</font></tt>
<br><tt><font color="#000066">}</font></tt></blockquote>

<p><br>likewise, to read an image from a Blob, you could use one of the
following examples:
<p>[ <font color="#000000">Entry condition for the following examples is
that <i>data</i> is pointer to encoded image data and <i>length</i> represents
the size of the data</font> ]
<blockquote><tt><font color="#000066">Blob blob( data, length );</font></tt>
<br><tt><font color="#000066">Image image( blob );</font></tt></blockquote>
or
<blockquote><tt><font color="#000066">Blob blob( data, length );</font></tt>
<br><tt><font color="#000066">Image image;</font></tt>
<br><tt><font color="#000066">image.read( blob);</font></tt></blockquote>
some images do not contain their size or format so the size and format
must be specified in advance:
<blockquote><tt><font color="#000066">Blob blob( data, length );</font></tt>
<br><tt><font color="#000066">Image image;</font></tt>
<br><tt><font color="#000066">image.size( "640x480")</font></tt>
<br><tt><font color="#000066">image.magick( "RGBA" );</font></tt>
<br><tt><font color="#000066">image.read( blob);</font></tt></blockquote>

<center>
<h3>
<a NAME="Constructors"></a>Constructors</h3></center>
Image may be constructed in a number of ways. It may be constructed from
a file, a URL, or an encoded image (e.g. JPEG) contained in an in-memory
<a href="Blob.html">BLOB</a>.
The available Image constructors are shown in the following table:
<br>&nbsp;
<br>&nbsp;
<table BORDER WIDTH="100%" BGCOLOR="#FFFFFF" NOSAVE >
<caption><b>Image Constructors</b></caption>

<tr>
<td>
<center><b>Signature</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr>
<td><font size=-1>const std::string &amp;imageSpec_</font></td>

<td><font size=-1>Construct Image by reading from file or URL specified
by <i>imageSpec_</i>. Use array notation (e.g. filename[9]) to select a
specific scene from a multi-frame image.</font></td>
</tr>

<tr>
<td><font size=-1>const Geometry &amp;size_, const <a href="Color.html">Color</a>
&amp;color_</font></td>

<td><font size=-1>Construct a blank image canvas of specified size and
color</font></td>
</tr>

<tr NOSAVE>
<td><a NAME="constructor_blob"></a><font size=-1>const <a href="Blob.html">Blob</a>
&amp;blob_</font></td>

<td ROWSPAN="5" NOSAVE><font size=-1>Construct Image by reading from encoded
image data contained in an in-memory <a href="Blob.html">BLOB</a>. Depending
on the constructor arguments, the Blob <a href="#size">size</a>, <a href="#depth">depth</a>,
<a href="#magick">magick</a>
(format) may also be specified. Some image formats require that size be
specified. The default ImageMagick uses for depth depends on the compiled-in
Quantum size (8 or 16).&nbsp; If ImageMagick's Quantum size does not match
that of the image, the depth may need to be specified. ImageMagick can
usually automatically detect the image's format. When a format can't be
automatically detected, the format (<a href="#magick">magick</a>) must
be specified.</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Blob.html">Blob</a> &amp;blob_, const
<a href="Geometry.html">Geometry</a>
&amp;size_</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Blob.html">Blob</a> &amp;blob_, const
<a href="Geometry.html">Geometry</a>
&amp;size, unsigned int depth</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Blob.html">Blob</a> &amp;blob_, const
<a href="Geometry.html">Geometry</a>
&amp;size, unsigned int depth_, const string &amp;magick_</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Blob.html">Blob</a> &amp;blob_, const
<a href="Geometry.html">Geometry</a>
&amp;size, const string &amp;magick_</font></td>
</tr>

<tr>
<td><font size=-1>const unsigned int width_, const unsigned int height_,
std::string map_, const StorageType type_, const void *pixels_</font></td>

<td><font size=-1>Construct a new Image based on an array of image pixels.
The pixel data must be in scanline order top-to-bottom. The data can be
character, short int, integer, float, or double. Float and double require
the pixels to be normalized [0..1]. The other types are [0..MaxRGB].&nbsp;
For example, to create a 640x480 image from unsigned red-green-blue character
data, use</font>
<p><font size=-1>&nbsp;&nbsp; Image image( 640, 480, "RGB", 0, pixels );</font>
<p><font size=-1>The parameters are as follows:</font>
<br>&nbsp;
<table BORDER=0 WIDTH="100%" NOSAVE >
<tr>
<td><font size=-1>width_</font></td>

<td><font size=-1>Width in pixels of the image.</font></td>
</tr>

<tr>
<td><font size=-1>height_</font></td>

<td><font size=-1>Height in pixels of the image.</font></td>
</tr>

<tr NOSAVE>
<td><font size=-1>map_</font></td>

<td NOSAVE><font size=-1>This character string can be any combination or
order of R = red, G = green, B = blue, A = alpha, C = cyan, Y = yellow
M = magenta, and K = black. The ordering reflects the order of the pixels
in the supplied pixel array.</font></td>
</tr>

<tr>
<td><font size=-1>type_</font></td>

<td><font size=-1>Pixel storage type (CharPixel, ShortPixel, IntegerPixel,
FloatPixel, or DoublePixel)</font></td>
</tr>

<tr>
<td><font size=-1>pixels_</font></td>

<td><font size=-1>This array of values contain the pixel components as
defined by the map_ and type_ parameters. The length of the arrays must
equal the area specified by the width_ and height_ values and type_ parameters.</font></td>
</tr>
</table>
</td>
</tr>
</table>

<center>
<h3>
<a NAME="Image Manipulation Methods"></a>Image Manipulation Methods</h3></center>
<i>Image</i> supports access to all the single-image (versus image-list)
manipulation operations provided by the ImageMagick library. If you must
process a multi-image file (such as an animation), the <a href="STL.html">STL
interface</a>, which provides a multi-image abstraction on top of <i>Image</i>,
must be used.
<p>The operations supported by Image are shown in the following table:
<br>&nbsp;
<table BORDER NOSAVE >
<caption>Image Image Manipulation Methods</caption>

<tr ALIGN=CENTER NOSAVE>
<td NOSAVE><b>Method</b></td>

<td><b>Signature(s)</b></td>

<td><b>Description</b></td>
</tr>

<tr>
<td>
<center><a NAME="addNoise"></a><font size=-1>addNoise</font></center>
</td>

<td><font size=-1><a href="Enumerations.html#NoiseType">NoiseType</a> noiseType_</font></td>

<td><font size=-1>Add noise to image with specified noise type.</font></td>
</tr>

<tr NOSAVE>
<td ROWSPAN="4" NOSAVE>
<center><a NAME="annotate"></a><font size=-1>annotate</font></center>
</td>

<td><font size=-1>const std::string &amp;text_, const <a href="Geometry.html">Geometry</a>
&amp;location_</font></td>

<td><font size=-1>Annotate using specified text, and placement location</font></td>
</tr>

<tr>
<td><font size=-1>string text_, const <a href="Geometry.html">Geometry</a>
&amp;boundingArea_, <a href="Enumerations.html#GravityType">GravityType</a>
gravity_</font></td>

<td><font size=-1>Annotate using specified text, bounding area, and placement
gravity. If <i>boundingArea_</i> is invalid, then bounding area is entire
image.</font></td>
</tr>

<tr>
<td><font size=-1>const std::string &amp;text_, const <a href="Geometry.html">Geometry</a>
&amp;boundingArea_, <a href="Enumerations.html#GravityType">GravityType</a>
gravity_, double degrees_,&nbsp;</font></td>

<td><font size=-1>Annotate with text using specified text, bounding area,
placement gravity, and rotation. If <i>boundingArea_</i> is invalid, then
bounding area is entire image.</font></td>
</tr>

<tr>
<td><font size=-1>const std::string &amp;text_, <a href="Enumerations.html#GravityType">GravityType</a>
gravity_</font></td>

<td><font size=-1>Annotate with text (bounding area is entire image) and
placement gravity.</font></td>
</tr>

<tr>
<td>
<center><a NAME="blur"></a><font size=-1>blur</font></center>
</td>

<td><font size=-1>const double radius_ = 1, const double sigma_ = 0.5</font></td>

<td><font size=-1>Blur image. The <i>radius_ </i>parameter specifies the
radius of the Gaussian, in pixels, not counting the center pixel.&nbsp;
The <i>sigma_</i> parameter specifies the standard deviation of the Laplacian,
in pixels.</font></td>
</tr>

<tr>
<td>
<center><a NAME="border"></a><font size=-1>border</font></center>
</td>

<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;geometry_
= "6x6+0+0"</font></td>

<td><font size=-1>Border image (add border to image).&nbsp; The color of
the border is specified by the <i>borderColor</i> attribute.</font></td>
</tr>

<tr>
<td>
<center><a NAME="channel"></a><font size=-1>channel</font></center>
</td>

<td><font size=-1><a href="Enumerations.html#ChannelType">ChannelType</a>
layer_</font></td>

<td><font size=-1>Extract channel from image. Use this option to extract
a particular channel from&nbsp; the image.&nbsp; <i>MatteChannel</i>&nbsp;
for&nbsp; example, is useful for extracting the opacity values from an
image.</font></td>
</tr>

<tr NOSAVE>
<td NOSAVE>
<center><a NAME="charcoal"></a><font size=-1>charcoal</font></center>
</td>

<td><font size=-1>const double radius_ = 1, const double sigma_ = 0.5</font></td>

<td><font size=-1>Charcoal effect image (looks like charcoal sketch). The
<i>radius_</i>
parameter specifies the radius of the Gaussian, in pixels, not counting
the center pixel.&nbsp; The <i>sigma_</i> parameter specifies the standard
deviation of the Laplacian, in pixels.</font></td>
</tr>

<tr>
<td>
<center><a NAME="chop"></a><font size=-1>chop</font></center>
</td>

<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;geometry_</font></td>

<td><font size=-1>Chop image (remove vertical or horizontal subregion of
image)</font></td>
</tr>

<tr NOSAVE>
<td ROWSPAN="2" NOSAVE>
<center><a NAME="colorize"></a><font size=-1>colorize</font></center>
</td>

<td><font size=-1>const unsigned int opacityRed_, const unsigned int opacityGreen_,
const unsigned int opacityBlue_, const Color &amp;penColor_</font></td>

<td><font size=-1>Colorize image with pen color, using specified percent
opacity for red, green, and blue quantums.</font></td>
</tr>

<tr>
<td><font size=-1>const unsigned int opacity_, const Color &amp;penColor_</font></td>

<td><font size=-1>Colorize image with pen color, using specified percent
opacity.</font></td>
</tr>

<tr>
<td>
<center><a NAME="comment"></a><font size=-1>comment</font></center>
</td>

<td><font size=-1>const string &amp;comment_</font></td>

<td><font size=-1>Comment image (add comment string to image).&nbsp; By
default, each image is commented with its file name. Use&nbsp; this&nbsp;
method to&nbsp; assign a specific comment to the image.&nbsp; Optionally
you can include the image filename, type, width, height, or other&nbsp;
image&nbsp; attributes by embedding <a href="FormatCharacters.html">special
format characters.</a></font></td>
</tr>

<tr NOSAVE>
<td ROWSPAN="3" NOSAVE>
<center><a NAME="composite"></a><font size=-1>composite</font></center>
</td>

<td><font size=-1>const <a href="Image.html">Image</a> &amp;compositeImage_,
int xOffset_, int yOffset_,
<a href="Enumerations.html#CompositeOperator">CompositeOperator</a>
compose_ = <i>InCompositeOp</i></font></td>

<td NOSAVE><font size=-1>Compose an image onto the current image at offset
specified by <i>xOffset_</i>, <i>yOffset_ </i>using the composition algorithm
specified by <i>compose_</i>.&nbsp;</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Image.html">Image</a> &amp;compositeImage_,
const <a href="Geometry.html">Geometry</a> &amp;offset_,
<a href="Enumerations.html#CompositeOperator">CompositeOperator</a>
compose_ = <i>InCompositeOp</i></font></td>

<td><font size=-1>Compose an image onto the current image at offset specified
by
<i>offset_</i> using the composition algorithm specified by <i>compose_</i>.&nbsp;</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Image.html">Image</a> &amp;compositeImage_,
<a href="Enumerations.html#GravityType">GravityType</a>
gravity_, <a href="Enumerations.html#CompositeOperator">CompositeOperator</a>
compose_ = <i>InCompositeOp</i></font></td>

<td><font size=-1>Compose an image onto the current image with placement
specified by <i>gravity_ </i>using the composition algorithm specified
by <i>compose_</i>.&nbsp;</font></td>
</tr>

<tr>
<td>
<center><a NAME="contrast"></a><font size=-1>contrast</font></center>
</td>

<td><font size=-1>unsigned int sharpen_</font></td>

<td><font size=-1>Contrast image (enhance intensity differences in image)</font></td>
</tr>

<tr>
<td>
<center><a NAME="convolve"></a><font size=-1>convolve</font></center>
</td>

<td><font size=-1>unsigned int order_, const double *kernel_</font></td>

<td><font size=-1>Convolve image.&nbsp; Applies a user-specfied convolution
to the image. The <i>order_</i> parameter represents the number of columns
and rows in the filter kernel, and <i>kernel_</i> is a two-dimensional
array of doubles representing the convolution kernel to apply.</font></td>
</tr>

<tr>
<td>
<center><a NAME="crop"></a><font size=-1>crop</font></center>
</td>

<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;geometry_</font></td>

<td><font size=-1>Crop image (subregion of original image)</font></td>
</tr>

<tr>
<td>
<center><a NAME="cycleColormap"></a><font size=-1>cycleColormap</font></center>
</td>

<td><font size=-1>int amount_</font></td>

<td><font size=-1>Cycle image colormap</font></td>
</tr>

<tr>
<td>
<center><a NAME="despeckle"></a><font size=-1>despeckle</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1>Despeckle image (reduce speckle noise)</font></td>
</tr>

<tr>
<td>
<center><a NAME="display"></a><font size=-1>display</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1>Display image on screen.</font>
<br><font size=-1><b><font color="#FF0000">Caution: </font></b>if an image
format is is not compatable with the display visual (e.g. JPEG on a colormapped
display) then the original image will be altered. Use a copy of the original
if this is a problem.</font></td>
</tr>

<tr NOSAVE>
<td ROWSPAN="2" NOSAVE>
<center><a NAME="draw"></a><font size=-1>draw</font></center>
</td>

<td><font size=-1>const <a href="Drawable.html">Drawable</a> &amp;drawable_</font></td>

<td><font size=-1>Draw shape or text on image.</font></td>
</tr>

<tr>
<td><font size=-1>const std::list&lt;<a href="Drawable.html">Drawable</a>>
&amp;drawable_</font></td>

<td><font size=-1>Draw shapes or text on image using a set of Drawable
objects contained in an STL list. Use of this method improves drawing performance
and allows batching draw objects together in a list for repeated use.</font></td>
</tr>

<tr>
<td>
<center><a NAME="edge"></a><font size=-1>edge</font></center>
</td>

<td><font size=-1>unsigned int radius_ = 0.0</font></td>

<td><font size=-1>Edge image (hilight edges in image).&nbsp; The radius
is the radius of the pixel neighborhood.. Specify a radius of zero for
automatic radius selection.</font></td>
</tr>

<tr NOSAVE>
<td NOSAVE>
<center><a NAME="emboss"></a><font size=-1>emboss</font></center>
</td>

<td><font size=-1>const double radius_ = 1, const double sigma_ = 0.5</font></td>

<td NOSAVE><font size=-1>Emboss image (hilight edges with 3D effect). The
<i>radius_</i>
parameter specifies the radius of the Gaussian, in pixels, not counting
the center pixel.&nbsp; The <i>sigma_</i> parameter specifies the standard
deviation of the Laplacian, in pixels.</font></td>
</tr>

<tr>
<td>
<center><a NAME="enhance"></a><font size=-1>enhance</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1>Enhance image (minimize noise)</font></td>
</tr>

<tr>
<td>
<center><a NAME="equalize"></a><font size=-1>equalize</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1>Equalize image (histogram equalization)</font></td>
</tr>

<tr>
<td>
<center><a NAME="erase"></a><font size=-1>erase</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1>Set all image pixels to the current background color.</font></td>
</tr>

<tr>
<td>
<center><a NAME="flip"></a><font size=-1>flip</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1>Flip image (reflect each scanline in the vertical direction)</font></td>
</tr>

<tr NOSAVE>
<td ROWSPAN="4" NOSAVE>
<center><a NAME="floodFillColor"></a><font size=-1>floodFill-</font>
<br><font size=-1>Color</font></center>
</td>

<td><font size=-1>unsigned int x_, unsigned int y_, const <a href="Color.html">Color</a>
&amp;fillColor_</font></td>

<td ROWSPAN="2" NOSAVE><font size=-1>Flood-fill color across pixels that
match the color of the target pixel and are neighbors of the target pixel.
Uses current fuzz setting when determining color match.</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;point_,
const <a href="Color.html">Color</a> &amp;fillColor_</font></td>
</tr>

<tr NOSAVE>
<td><font size=-1>unsigned int x_, unsigned int y_, const <a href="Color.html">Color</a>
&amp;fillColor_, const <a href="Color.html">Color</a> &amp;borderColor_</font></td>

<td ROWSPAN="2" NOSAVE><font size=-1>Flood-fill color across pixels starting
at target-pixel and stopping at pixels matching specified border color.
Uses current fuzz setting when determining color match.</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;point_,
const <a href="Color.html">Color</a> &amp;fillColor_, const <a href="Color.html">Color</a>
&amp;borderColor_</font></td>
</tr>

<tr>
<td><a NAME="floodFillOpacity"></a><font size=-1>floodFillOpacity</font></td>

<td><font size=-1>const long x_, const long y_, const unsigned int opacity_,
const PaintMethod method_</font></td>

<td><font size=-1>Floodfill pixels matching color (within fuzz factor)
of target pixel(x,y) with replacement opacity value using method.</font></td>
</tr>

<tr NOSAVE>
<td ROWSPAN="4" NOSAVE>
<center><a NAME="floodFillTexture"></a><font size=-1>floodFill-</font>
<br><font size=-1>Texture</font></center>
</td>

<td><font size=-1>unsigned int x_, unsigned int y_,&nbsp; const Image &amp;texture_</font></td>

<td ROWSPAN="2" NOSAVE><font size=-1>Flood-fill texture across pixels that
match the color of the target pixel and are neighbors of the target pixel.
Uses current fuzz setting when determining color match.</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;point_,
const Image &amp;texture_</font></td>
</tr>

<tr NOSAVE>
<td><font size=-1>unsigned int x_, unsigned int y_, const Image &amp;texture_,
const <a href="Color.html">Color</a> &amp;borderColor_</font></td>

<td ROWSPAN="2" NOSAVE><font size=-1>Flood-fill texture across pixels starting
at target-pixel and stopping at pixels matching specified border color.
Uses current fuzz setting when determining color match.</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;point_,
const Image &amp;texture_, const <a href="Color.html">Color</a> &amp;borderColor_</font></td>
</tr>

<tr>
<td>
<center><a NAME="flop"></a><font size=-1>flop</font></center>
</td>

<td><font size=-1>void&nbsp;</font></td>

<td><font size=-1>Flop image (reflect each scanline in the horizontal direction)</font></td>
</tr>

<tr NOSAVE>
<td ROWSPAN="2" NOSAVE>
<center><a NAME="frame"></a><font size=-1>frame</font></center>
</td>

<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;geometry_
= "25x25+6+6"</font></td>

<td ROWSPAN="2" NOSAVE><font size=-1>Add decorative frame around image</font></td>
</tr>

<tr>
<td><font size=-1>unsigned int width_, unsigned int height_, int x_, int
y_, int innerBevel_ = 0, int outerBevel_ = 0</font></td>
</tr>

<tr NOSAVE>
<td ROWSPAN="2" NOSAVE>
<center><a NAME="gamma"></a><font size=-1>gamma</font></center>
</td>

<td><font size=-1>double gamma_</font></td>

<td><font size=-1>Gamma correct image (uniform red, green, and blue correction).</font></td>
</tr>

<tr>
<td><font size=-1>double gammaRed_, double gammaGreen_, double gammaBlue_</font></td>

<td><font size=-1>Gamma correct red, green, and blue channels of image.</font></td>
</tr>

<tr>
<td>
<center><a NAME="gaussianBlur"></a><font size=-1>gaussianBlur</font></center>
</td>

<td><font size=-1>double width_, double sigma_</font></td>

<td><font size=-1>Gaussian blur image. The number of neighbor pixels to
be included in the convolution mask is specified by 'width_'.&nbsp; For
example, a width of one gives a (standard) 3x3 convolution mask. The standard
deviation of the gaussian bell curve is specified by 'sigma_'.</font></td>
</tr>

<tr>
<td>
<center><a NAME="implode"></a><font size=-1>implode</font></center>
</td>

<td><font size=-1>double factor_</font></td>

<td><font size=-1>Implode image (special effect)</font></td>
</tr>

<tr>
<td>
<center><a NAME="label"></a><font size=-1>label</font></center>
</td>

<td><font size=-1>const string &amp;label_</font></td>

<td><font size=-1>Assign a label to an image. Use this option to&nbsp;
assign&nbsp; a&nbsp; specific label to the image. Optionally you can include
the image filename, type, width, height, or scene number in the label by
embedding&nbsp; <a href="FormatCharacters.html">special format characters.</a>
If the first character of string is @, the image label is read from a file
titled by the remaining characters in the string. When converting to Postscript,
use this&nbsp; option to specify a header string to print above the image.</font></td>
</tr>

<tr>
<td>
<center><a NAME="magnify"></a><font size=-1>magnify</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1>Magnify image by integral size</font></td>
</tr>

<tr>
<td>
<center><a NAME="map"></a><font size=-1>map</font></center>
</td>

<td><font size=-1>const Image &amp;mapImage_ , bool dither_ = false</font></td>

<td><font size=-1>Remap image colors with closest color from reference
image. Set dither_ to <i>true</i> in to apply Floyd/Steinberg error diffusion
to the image. By default, color reduction chooses an optimal&nbsp; set&nbsp;
of colors that best represent the original image. Alternatively, you can&nbsp;
choose&nbsp; a&nbsp; particular&nbsp; set&nbsp; of colors&nbsp; from&nbsp;
an image file with this option.</font></td>
</tr>

<tr>
<td>
<center><a NAME="matteFloodfill"></a><font size=-1>matteFloodfill</font></center>
</td>

<td><font size=-1>const <a href="Color.html">Color</a> &amp;target_, unsigned
int&nbsp; opacity_, long x_, long y_, <a href="Enumerations.html#PaintMethod">PaintMethod</a>
method_</font></td>

<td><font size=-1>Floodfill designated area with a replacement opacity
value.</font></td>
</tr>

<tr>
<td><a NAME="medianFilter"></a><font size=-1>medianFilter</font></td>

<td><font size=-1>const double radius_ = 0.0</font></td>

<td><font size=-1>Filter image by replacing each pixel component with the
median color in a circular neighborhood</font></td>
</tr>

<tr>
<td>
<center><a NAME="minify"></a><font size=-1>minify</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1>Reduce image by integral size</font></td>
</tr>

<tr>
<td><a NAME="modifyImage"></a><font size=-1>modifyImage</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>Prepare to update image. Ensures that there is only one
reference to the underlying image so that the underlying image may be safely
modified without effecting previous generations of the image. Copies the
underlying image to a new image if necessary.</font></td>
</tr>

<tr>
<td>
<center><a NAME="modulate"></a><font size=-1>modulate</font></center>
</td>

<td><font size=-1>double brightness_, double saturation_, double hue_</font></td>

<td><font size=-1>Modulate percent hue, saturation, and brightness of an
image</font></td>
</tr>

<tr>
<td>
<center><a NAME="negate"></a><font size=-1>negate</font></center>
</td>

<td><font size=-1>bool grayscale_ = false</font></td>

<td><font size=-1>Negate colors in image.&nbsp; Replace every pixel with
its complementary color (white becomes black, yellow becomes blue, etc.).&nbsp;
Set grayscale to only negate grayscale values in image.</font></td>
</tr>

<tr>
<td>
<center><a NAME="normalize"></a><font size=-1>normalize</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1>Normalize image (increase contrast by normalizing the
pixel values to span the full range of color values).</font></td>
</tr>

<tr>
<td>
<center><a NAME="oilPaint"></a><font size=-1>oilPaint</font></center>
</td>

<td><font size=-1>unsigned int radius_ = 3</font></td>

<td><font size=-1>Oilpaint image (image looks like oil painting)</font></td>
</tr>

<tr>
<td>
<center><a NAME="opacity"></a><font size=-1>opacity</font></center>
</td>

<td><font size=-1>unsigned int opacity_</font></td>

<td><font size=-1>Set or attenuate the opacity channel in the image. If
the image pixels are opaque then they are set to the specified opacity
value, otherwise they are blended with the supplied opacity value.&nbsp;
The value of opacity_ ranges from 0 (completely opaque) to <i>MaxRGB</i>.
The defines <i>OpaqueOpacity</i> and <i>TransparentOpacity</i> are available
to specify completely opaque or completely transparent, respectively.</font></td>
</tr>

<tr>
<td>
<center><a NAME="opaque"></a><font size=-1>opaque</font></center>
</td>

<td><font size=-1>const <a href="Color.html">Color</a> &amp;opaqueColor_,
const <a href="Color.html">Color</a> &amp;penColor_</font></td>

<td><font size=-1>Change color of pixels matching opaqueColor_ to specified
penColor_.</font></td>
</tr>

<tr>
<td>
<center><a NAME="ping"></a><font size=-1>ping</font></center>
</td>

<td><font size=-1>const std::string &amp;imageSpec_</font></td>

<td><font size=-1>Ping is similar to read except only enough of the image
is read to determine the image columns, rows, and filesize.&nbsp; The <a href="#columns">columns</a></font>,
<font size=-1><a href="#rows">rows</a>,
and <a href="#fileSize">fileSize</a> attributes are valid after invoking
ping.&nbsp; The image data is not valid after calling ping.</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="quantize"></a><font size=-1>quantize</font></center>
</td>

<td><font size=-1>bool measureError_ = false</font></td>

<td NOSAVE><font size=-1>Quantize image (reduce number of colors). Set
measureError_ to true in order to calculate error attributes.</font></td>
</tr>

<tr>
<td>
<center><a NAME="raise"></a><font size=-1>raise</font></center>
</td>

<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;geometry_
= "6x6+0+0",&nbsp; bool raisedFlag_ =&nbsp; false</font></td>

<td><font size=-1>Raise image (lighten or darken the edges of an image
to give a 3-D raised or lowered effect)</font></td>
</tr>

<tr NOSAVE>
<td ROWSPAN="8" NOSAVE>
<center><a NAME="read"></a><font size=-1>read</font></center>
</td>

<td><font size=-1>const string &amp;imageSpec_</font></td>

<td><font size=-1>Read image into current object</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;size_,
const std::string &amp;imageSpec_</font></td>

<td><font size=-1>Read image of specified size into current object. This
form is useful for images that do not specifiy their size or to specify
a size hint for decoding an image. For example, when reading a Photo CD,
JBIG, or JPEG image, a size request causes the library to return an image
which is the next resolution greater or equal to the specified size. This
may result in memory and time savings.</font></td>
</tr>

<tr NOSAVE>
<td><font size=-1>const <a href="Blob.html">Blob</a> &amp;blob_</font></td>

<td ROWSPAN="5" NOSAVE><font size=-1>Read encoded image of specified size
from an in-memory
<a href="Blob.html">BLOB</a> into current object. Depending
on the method arguments, the Blob size, depth, and format may also be specified.
Some image formats require that size be specified. The default ImageMagick
uses for depth depends on its Quantum size (8 or 16).&nbsp; If ImageMagick's
Quantum size does not match that of the image, the depth may need to be
specified. ImageMagick can usually automatically detect the image's format.
When a format can't be automatically detected, the format must be specified.</font></td>
</tr>

<tr NOSAVE>
<td><font size=-1>const <a href="Blob.html">Blob</a> &amp;blob_, const
<a href="Geometry.html">Geometry</a>
&amp;size_</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Blob.html">Blob</a> &amp;blob_, const
<a href="Geometry.html">Geometry</a>
&amp;size_, unsigned int depth_</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Blob.html">Blob</a> &amp;blob_, const
<a href="Geometry.html">Geometry</a>
&amp;size_, unsigned short depth_, const string &amp;magick_&nbsp;</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Blob.html">Blob</a> &amp;blob_, const
<a href="Geometry.html">Geometry</a>
&amp;size_, const string &amp;magick_</font></td>
</tr>

<tr>
<td><font size=-1>const unsigned int width_, const unsigned int height_,
std::string map_, const StorageType type_, const void *pixels_</font></td>

<td><font size=-1>Read image based on an array of image pixels. The pixel
data must be in scanline order top-to-bottom. The data can be character,
short int, integer, float, or double. Float and double require the pixels
to be normalized [0..1]. The other types are [0..MaxRGB].&nbsp; For example,
to create a 640x480 image from unsigned red-green-blue character data,
use</font>
<p><font size=-1>&nbsp; image.read( 640, 480, "RGB", 0, pixels );</font>
<p><font size=-1>The parameters are as follows:</font>
<br>&nbsp;
<table BORDER=0 WIDTH="100%" NOSAVE >
<tr>
<td><font size=-1>width_</font></td>

<td><font size=-1>Width in pixels of the image.</font></td>
</tr>

<tr>
<td><font size=-1>height_</font></td>

<td><font size=-1>Height in pixels of the image.</font></td>
</tr>

<tr NOSAVE>
<td NOSAVE><font size=-1>map_</font></td>

<td NOSAVE><font size=-1>This character string can be any combination or
order of R = red, G = green, B = blue, A = alpha, C = cyan, Y = yellow
M = magenta, and K = black. The ordering reflects the order of the pixels
in the supplied pixel array.</font></td>
</tr>

<tr>
<td><font size=-1>type_</font></td>

<td><font size=-1>Pixel storage type (CharPixel, ShortPixel, IntegerPixel,
FloatPixel, or DoublePixel)</font></td>
</tr>

<tr>
<td><font size=-1>pixels_</font></td>

<td><font size=-1>This array of values contain the pixel components as
defined by the map_ and type_ parameters. The length of the arrays must
equal the area specified by the width_ and height_ values and type_ parameters.</font></td>
</tr>
</table>
</td>
</tr>

<tr NOSAVE>
<td ROWSPAN="2" NOSAVE>
<center><a NAME="reduceNoise"></a><font size=-1>reduceNoise</font></center>
</td>

<td><font size=-1>void</font></td>

<td ROWSPAN="2" NOSAVE><font size=-1>Reduce noise in image using a noise
peak elimination filter.</font></td>
</tr>

<tr>
<td><font size=-1>unsigned int order_</font></td>
</tr>

<tr>
<td>
<center><a NAME="roll"></a><font size=-1>roll</font></center>
</td>

<td><font size=-1>int columns_, int rows_</font></td>

<td><font size=-1>Roll image (rolls image vertically and horizontally)
by specified number of columnms and rows)</font></td>
</tr>

<tr>
<td>
<center><a NAME="rotate"></a><font size=-1>rotate</font></center>
</td>

<td><font size=-1>double degrees_</font></td>

<td><font size=-1>Rotate image counter-clockwise by specified number of
degrees.</font></td>
</tr>

<tr>
<td>
<center><a NAME="sample"></a><font size=-1>sample</font></center>
</td>

<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;geometry_&nbsp;</font></td>

<td><font size=-1>Resize image by using pixel sampling algorithm</font></td>
</tr>

<tr>
<td>
<center><a NAME="scale"></a><font size=-1>scale</font></center>
</td>

<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;geometry_</font></td>

<td><font size=-1>Resize image by using simple ratio algorithm</font></td>
</tr>

<tr>
<td>
<center><a NAME="segment"></a><font size=-1>segment</font></center>
</td>

<td><font size=-1>double clusterThreshold_ = 1.0,</font>
<br><font size=-1>double smoothingThreshold_ = 1.5</font></td>

<td><font size=-1>Segment (coalesce similar image components) by analyzing
the histograms of the color components and identifying units that are homogeneous
with the fuzzy c-means technique. Also uses <i>quantizeColorSpace</i> and
<i>verbose</i>
image attributes. Specify <i>clusterThreshold_</i>, as the number&nbsp;
of&nbsp; pixels&nbsp; each cluster&nbsp; must exceed the cluster threshold
to be considered valid. <i>SmoothingThreshold_</i> eliminates noise in
the&nbsp; second derivative of the histogram. As the value is&nbsp; increased,
you can&nbsp; expect&nbsp; a&nbsp; smoother second derivative.&nbsp; The
default is 1.5.</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="shade"></a><font size=-1>shade</font></center>
</td>

<td NOSAVE><font size=-1>double azimuth_ = 30, double elevation_ = 30,</font>
<br><font size=-1>bool colorShading_ = false</font></td>

<td><font size=-1>Shade image using distant light source. Specify <i>azimuth_</i>
and <i>elevation_</i> as the&nbsp; position&nbsp; of&nbsp; the light source.
By default, the shading results as a grayscale image.. Set c<i>olorShading_</i>
to <i>true</i> to shade the red, green, and blue components of the image.</font></td>
</tr>

<tr>
<td>
<center><a NAME="sharpen"></a><font size=-1>sharpen</font></center>
</td>

<td><font size=-1>const double radius_ = 1, const double sigma_ = 0.5</font></td>

<td><font size=-1>Sharpen pixels in image.&nbsp; The <i>radius_</i> parameter
specifies the radius of the Gaussian, in pixels, not counting the center
pixel.&nbsp; The <i>sigma_</i> parameter specifies the standard deviation
of the Laplacian, in pixels.</font></td>
</tr>

<tr>
<td>
<center><a NAME="shave"></a><font size=-1>shave</font></center>
</td>

<td><font size=-1>const Geometry &amp;geometry_</font></td>

<td><font size=-1>Shave pixels from image edges.</font></td>
</tr>

<tr>
<td>
<center><a NAME="shear"></a><font size=-1>shear</font></center>
</td>

<td><font size=-1>double xShearAngle_, double yShearAngle_</font></td>

<td><font size=-1>Shear image (create parallelogram by sliding image by
X or Y axis).&nbsp; Shearing slides one edge of an image along the X&nbsp;
or&nbsp; Y axis,&nbsp; creating&nbsp; a parallelogram.&nbsp; An X direction
shear slides an edge along the X axis, while&nbsp; a&nbsp; Y&nbsp; direction
shear&nbsp; slides&nbsp; an edge along the Y axis.&nbsp; The amount of
the shear is controlled by a shear angle.&nbsp; For X direction&nbsp; shears,&nbsp;
x&nbsp; degrees is measured relative to the Y axis, and similarly, for
Y direction shears&nbsp; y&nbsp; degrees is measured relative to the X
axis. Empty triangles left over from shearing the&nbsp; image&nbsp; are
filled&nbsp; with&nbsp; the&nbsp; color&nbsp; defined as <i>borderColor</i>.&nbsp;</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="solarize"></a><font size=-1>solarize</font></center>
</td>

<td><font size=-1>double factor_ = 50.0</font></td>

<td NOSAVE><font size=-1>Solarize image (similar to effect seen when exposing
a photographic film to light during the development process)</font></td>
</tr>

<tr>
<td>
<center><a NAME="spread"></a><font size=-1>spread</font></center>
</td>

<td><font size=-1>unsigned int amount_ = 3</font></td>

<td><font size=-1>Spread pixels randomly within image by specified amount</font></td>
</tr>

<tr>
<td>
<center><a NAME="stegano"></a><font size=-1>stegano</font></center>
</td>

<td><font size=-1>const Image &amp;watermark_</font></td>

<td><font size=-1>Add a digital watermark to the image (based on second
image)</font></td>
</tr>

<tr>
<td>
<center><a NAME="stereo"></a><font size=-1>stereo</font></center>
</td>

<td><font size=-1>const Image &amp;rightImage_</font></td>

<td><font size=-1>Create an image which appears in stereo when viewed with
red-blue glasses (Red image on left, blue on right)</font></td>
</tr>

<tr>
<td>
<center><a NAME="swirl"></a><font size=-1>swirl</font></center>
</td>

<td><font size=-1>double degrees_</font></td>

<td><font size=-1>Swirl image (image pixels are rotated by degrees)</font></td>
</tr>

<tr>
<td>
<center><a NAME="texture"></a><font size=-1>texture</font></center>
</td>

<td><font size=-1>const Image &amp;texture_</font></td>

<td><font size=-1>Layer a texture on pixels matching image background color.</font></td>
</tr>

<tr>
<td>
<center><a NAME="threshold"></a><font size=-1>threshold</font></center>
</td>

<td><font size=-1>double threshold_</font></td>

<td><font size=-1>Threshold image</font></td>
</tr>

<tr NOSAVE>
<td ROWSPAN="2" NOSAVE>
<center><a NAME="transform"></a><font size=-1>transform</font></center>
</td>

<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;imageGeometry_</font></td>

<td ROWSPAN="2" NOSAVE><font size=-1>Transform image based on image and
crop geometries. Crop geometry is optional.</font></td>
</tr>

<tr>
<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;imageGeometry_,
const <a href="Geometry.html">Geometry</a> &amp;cropGeometry_&nbsp;</font></td>
</tr>

<tr>
<td>
<center><a NAME="transparent"></a><font size=-1>transparent</font></center>
</td>

<td><font size=-1>const <a href="Color.html">Color</a> &amp;color_</font></td>

<td><font size=-1>Add matte image to image, setting pixels matching color
to transparent.</font></td>
</tr>

<tr>
<td>
<center><a NAME="trim"></a><font size=-1>trim</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1>Trim edges that are the background color from the image.</font></td>
</tr>

<tr>
<td>
<center><a NAME="unsharpmask"></a><font size=-1>unsharpmask</font></center>
</td>

<td><font size=-1>double radius_, double sigma_, double amount_, double
threshold_</font></td>

<td><font size=-1>Replace image with a sharpened version of the original
image using the unsharp mask algorithm. The <i>radius</i>_ parameter specifies
the radius of the Gaussian, in pixels, not counting the center pixel. The
<i>sigma</i>_
parameter specifies the standard deviation of the Gaussian, in pixels.
The <i>amount</i>_ parameter specifies the percentage of the difference
between the original and the blur image that is added back into the original.
The <i>threshold</i>_ parameter specifies the threshold in pixels needed
to apply the diffence amount.</font></td>
</tr>

<tr>
<td>
<center><a NAME="wave"></a><font size=-1>wave</font></center>
</td>

<td><font size=-1>double amplitude_ = 25.0, double wavelength_ = 150.0</font></td>

<td><font size=-1>Alter an image along a sine wave.</font></td>
</tr>

<tr NOSAVE>
<td ROWSPAN="5" NOSAVE>
<center><a NAME="write"></a><font size=-1>write</font></center>
</td>

<td><font size=-1>const string &amp;imageSpec_</font></td>

<td><font size=-1>Write image to a file using filename i<i>mageSpec_</i>.</font>
<br><font size=-1><b><font color="#FF0000">Caution: </font></b>if an image
format is selected which is capable of supporting fewer colors than the
original image or quantization has been requested, the original image will
be quantized to fewer colors. Use a copy of the original if this is a problem.</font></td>
</tr>

<tr NOSAVE>
<td><font size=-1><a href="Blob.html">Blob</a> *blob_</font></td>

<td ROWSPAN="3" NOSAVE><font size=-1>Write image to a in-memory <a href="Blob.html">BLOB</a>
stored in <i>blob_</i>. The <i>magick</i>_ parameter specifies the image
format to write (defaults to <a href="#magick">magick</a> ). The depth_
parameter species the image depth (defaults to <a href="#depth">depth</a>).</font>
<br><font size=-1><b><font color="#FF0000">Caution: </font></b>if an image
format is selected which is capable of supporting fewer colors than the
original image or quantization has been requested, the original image will
be quantized to fewer colors. Use a copy of the original if this is a problem.</font></td>
</tr>

<tr>
<td><font size=-1><a href="Blob.html">Blob</a> *blob_, std::string &amp;magick_</font></td>
</tr>

<tr>
<td><font size=-1><a href="Blob.html">Blob</a> *blob_, std::string &amp;magick_,
unsigned int depth_</font></td>
</tr>

<tr>
<td><font size=-1>const int x_, const int y_, const unsigned int columns_,
const unsigned int rows_, const std::string &amp;map_, const StorageType
type_, void *pixels_</font></td>

<td><font size=-1>Write pixel data into a buffer you supply. The data is
saved either as char, short int, integer, float or double format in the
order specified by the type_ parameter. For example, we want to extract
scanline 1 of a 640x480 image as character data in red-green-blue order:</font>
<p><font size=-1>&nbsp; image.write(0,0,640,1,"RGB",0,pixels);</font>
<p><font size=-1>The parameters are as follows:</font>
<br>&nbsp;
<table BORDER=0 WIDTH="100%" NOSAVE >
<tr>
<td><font size=-1>x_</font></td>

<td><font size=-1>Horizontal ordinate of left-most coordinate of region
to extract.</font></td>
</tr>

<tr>
<td><font size=-1>y_</font></td>

<td><font size=-1>Vertical ordinate of top-most coordinate of region to
extract.</font></td>
</tr>

<tr>
<td><font size=-1>columns_</font></td>

<td><font size=-1>Width in pixels of the region to extract.</font></td>
</tr>

<tr>
<td><font size=-1>rows_</font></td>

<td><font size=-1>Height in pixels of the region to extract.</font></td>
</tr>

<tr NOSAVE>
<td><font size=-1>map_</font></td>

<td NOSAVE><font size=-1>This character string can be any combination or
order of R = red, G = green, B = blue, A = alpha, C = cyan, Y = yellow,
M = magenta, and K = black. The ordering reflects the order of the pixels
in the supplied pixel array.</font></td>
</tr>

<tr>
<td><font size=-1>type_</font></td>

<td><font size=-1>Pixel storage type (CharPixel, ShortPixel, IntegerPixel,
FloatPixel, or DoublePixel)</font></td>
</tr>

<tr>
<td><font size=-1>pixels_</font></td>

<td><font size=-1>This array of values contain the pixel components as
defined by the map_ and type_ parameters. The length of the arrays must
equal the area specified by the width_ and height_ values and type_ parameters.</font></td>
</tr>
</table>
</td>
</tr>

<tr>
<td>
<center><a NAME="zoom"></a><font size=-1>zoom</font></center>
</td>

<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;geometry_</font></td>

<td><font size=-1>Zoom image to specified size.</font></td>
</tr>
</table>

<center>
<h3>
<a NAME="Image Attributes"></a>Image Attributes</h3></center>
Image attributes are set and obtained via methods in Image. Except for
methods which accept pointer arguments (e.g. c<tt>hromaBluePrimary)</tt>
all methods return attributes by value.
<p>The supported image attributes and the method arguments required to
obtain them are shown in the following table:
<br>&nbsp;
<table BORDER NOSAVE >
<caption>Image Image Attributes</caption>

<tr>
<td>
<center><b>Attribute</b></center>
</td>

<td>
<center><b>Type</b></center>
</td>

<td>
<center><b>Get Signature</b></center>
</td>

<td>
<center><b>Set Signature</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr>
<td>
<center><a NAME="adjoin"></a><font size=-1>adjoin</font></center>
</td>

<td><font size=-1>bool</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>bool flag_</font></td>

<td><font size=-1>Join images into a single multi-image file.</font></td>
</tr>

<tr>
<td>
<center><a NAME="antiAlias"></a><font size=-1>antiAlias</font></center>
</td>

<td><font size=-1>bool</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>bool flag_</font></td>

<td><font size=-1>Control antialiasing of rendered Postscript and Postscript
or TrueType fonts. Enabled by default.</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="animationDelay"></a><font size=-1>animation-</font>
<br><font size=-1>Delay</font></center>
</td>

<td NOSAVE><font size=-1>unsigned int (0 to 65535)</font></td>

<td><font size=-1>void</font></td>

<td NOSAVE><font size=-1>unsigned int delay_</font></td>

<td><font size=-1>Time in 1/100ths of a second (0 to 65535) which must
expire before displaying the next image in an animated sequence. This option
is useful for regulating the animation of a sequence&nbsp; of GIF images
within Netscape.</font></td>
</tr>

<tr>
<td>
<center><a NAME="animationIterations"></a><font size=-1>animation-</font>
<br><font size=-1>Iterations</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>unsigned int iterations_</font></td>

<td><font size=-1>Number of iterations to loop an animation (e.g. Netscape
loop extension) for.</font></td>
</tr>

<tr>
<td>
<center><a NAME="backgroundColor"></a><font size=-1>background-</font>
<br><font size=-1>Color</font></center>
</td>

<td><font size=-1><a href="Color.html">Color</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const <a href="Color.html">Color</a> &amp;color_</font></td>

<td><font size=-1>Image background color</font></td>
</tr>

<tr>
<td>
<center><a NAME="backgroundTexture"></a><font size=-1>background-</font>
<br><font size=-1>Texture</font></center>
</td>

<td><font size=-1>string</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const string &amp;texture_</font></td>

<td><font size=-1>Image file name to use as the background texture. Does
not modify image pixels.</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="baseColumns"></a><font size=-1>baseColumns</font></center>
</td>

<td NOSAVE><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Base image width (before transformations)</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="baseFilename"></a><font size=-1>baseFilename</font></center>
</td>

<td><font size=-1>string</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Base image filename (before transformations)</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="baseRows"></a><font size=-1>baseRows</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Base image height (before transformations)</font></td>
</tr>

<tr>
<td>
<center><a NAME="borderColor"></a><font size=-1>borderColor</font></center>
</td>

<td><font size=-1><a href="Color.html">Color</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>&nbsp;const <a href="Color.html">Color</a> &amp;color_</font></td>

<td><font size=-1>Image border color</font></td>
</tr>

<tr NOSAVE>
<td><a NAME="boundingBox"></a><font size=-1>boundingBox</font></td>

<td><font size=-1>Geometry</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Return smallest bounding box enclosing non-border pixels.
The current fuzz value is used when discriminating between pixels. This
is the crop bounding box used by crop(Geometry(0,0)).</font></td>
</tr>

<tr>
<td>
<center><a NAME="boxColor"></a><font size=-1>boxColor</font></center>
</td>

<td><font size=-1><a href="Color.html">Color</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const <a href="Color.html">Color</a> &amp;boxColor_</font></td>

<td><font size=-1>Base color that annotation text is rendered on.</font></td>
</tr>

<tr NOSAVE>
<td><a NAME="cacheThreshold"></a><font size=-1>cacheThreshold</font></td>

<td><font size=-1>unsigned int</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>Pixel cache threshold in megabytes. Once this threshold
is exceeded, all subsequent pixels cache operations are to/from disk. This
is a static method and the attribute it sets is shared by all Image objects.</font></td>
</tr>

<tr>
<td>
<center><a NAME="chromaBluePrimary"></a><font size=-1>chroma-</font>
<br><font size=-1>BluePrimary</font></center>
</td>

<td><font size=-1>float x &amp; y</font></td>

<td><font size=-1>float *x_, float *y_</font></td>

<td><font size=-1>float x_, float y_</font></td>

<td><font size=-1>Chromaticity blue primary point (e.g. x=0.15, y=0.06)</font></td>
</tr>

<tr>
<td>
<center><a NAME="chromaGreenPrimary"></a><font size=-1>chroma-</font>
<br><font size=-1>GreenPrimary</font></center>
</td>

<td><font size=-1>float x &amp; y</font></td>

<td><font size=-1>float *x_, float *y_</font></td>

<td><font size=-1>float x_, float y_</font></td>

<td><font size=-1>Chromaticity green primary point (e.g. x=0.3, y=0.6)</font></td>
</tr>

<tr>
<td>
<center><a NAME="chromaRedPrimary"></a><font size=-1>chroma-</font>
<br><font size=-1>RedPrimary</font></center>
</td>

<td><font size=-1>float x &amp; y</font></td>

<td><font size=-1>float *x_, float *y_</font></td>

<td><font size=-1>float x_, float y_</font></td>

<td><font size=-1>Chromaticity red primary point (e.g. x=0.64, y=0.33)</font></td>
</tr>

<tr>
<td>
<center><a NAME="chromaWhitePoint"></a><font size=-1>chroma-</font>
<br><font size=-1>WhitePoint</font></center>
</td>

<td><font size=-1>float x &amp; y</font></td>

<td><font size=-1>float *x_, float *y_</font></td>

<td><font size=-1>float x_, float y_</font></td>

<td><font size=-1>Chromaticity white point (e.g. x=0.3127, y=0.329)</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="classType"></a><font size=-1>classType</font></center>
</td>

<td><font size=-1><a href="Enumerations.html#ClassType">ClassType</a></font></td>

<td><font size=-1>void</font></td>

<td NOSAVE><font size=-1>&nbsp;<a href="Enumerations.html#ClassType">ClassType</a>
class_</font></td>

<td><font size=-1>Image storage class.&nbsp; Note that conversion from
a DirectClass image to a PseudoClass image may result in a loss of color
due to the limited size of the palette (256 or 65535 colors).</font></td>
</tr>

<tr>
<td>
<center><a NAME="clipMask"></a><font size=-1>clipMask</font></center>
</td>

<td><font size=-1>Image</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const Image &amp;clipMask_</font></td>

<td><font size=-1>Associate a clip mask image with the current image. The
clip mask image must have the same dimensions as the current image or an
exception is thrown. Clipping occurs wherever pixels are transparent in
the clip mask image. Clipping Pass an invalid image to unset an existing
clip mask.</font></td>
</tr>

<tr>
<td>
<center><a NAME="colorFuzz"></a><font size=-1>colorFuzz</font></center>
</td>

<td><font size=-1>double</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>double fuzz_</font></td>

<td><font size=-1>Colors within this distance are considered equal. A number
of algorithms search for a target&nbsp; color. By default the color must
be exact. Use this option to match colors that are close to the target
color in RGB space.</font></td>
</tr>

<tr>
<td>
<center><a NAME="colorMap"></a><font size=-1>colorMap</font></center>
</td>

<td><font size=-1><a href="Color.html">Color</a></font></td>

<td><font size=-1>unsigned int index_</font></td>

<td><font size=-1>unsigned int index_, const <a href="Color.html">Color</a>
&amp;color_</font></td>

<td><font size=-1>Color at color-pallet index.</font></td>
</tr>

<tr>
<td>
<center><a NAME="colorSpace"></a><font size=-1>colorSpace</font></center>
</td>

<td><font size=-1><a href="Enumerations.html#ColorspaceType">ColorspaceType</a>
colorSpace_</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1><a href="Enumerations.html#ColorspaceType">ColorspaceType</a>
colorSpace_</font></td>

<td><font size=-1>The colorspace (e.g. CMYK) used to represent the image
pixel colors. Image pixels are always stored as RGB(A) except for the case
of CMY(K).</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="columns"></a><font size=-1>columns</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Image width</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="comment"></a><font size=-1>comment</font></center>
</td>

<td><font size=-1>string</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Image comment</font></td>
</tr>

<tr>
<td>
<center><a NAME="compressType"></a><font size=-1>compress-</font>
<br><font size=-1>Type</font></center>
</td>

<td><font size=-1><a href="Enumerations.html#CompressionType">CompressionType</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1><a href="Enumerations.html#CompressionType">CompressionType</a>
compressType_</font></td>

<td><font size=-1>Image compresion type. The default is the compression
type of the specified image file.</font></td>
</tr>

<tr>
<td>
<center><a NAME="density"></a><font size=-1>density</font></center>
</td>

<td><font size=-1><a href="Geometry.html">Geometry</a>&nbsp; (default 72x72)</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;density_</font></td>

<td><font size=-1>Vertical and horizontal resolution in pixels of the image.
This option specifies an image density when decoding a Postscript or Portable
Document page. Often used with <i>psPageSize</i>.</font></td>
</tr>

<tr>
<td>
<center><a NAME="depth"></a><font size=-1>depth</font></center>
</td>

<td><font size=-1>&nbsp;unsigned int (8 or 16)</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>unsigned int depth_</font></td>

<td><font size=-1>Image depth. Used to specify the bit depth when reading
or writing&nbsp; raw images or when the output format supports multiple
depths. Defaults to the quantum depth that ImageMagick is compiled with.</font></td>
</tr>

<tr>
<td>
<center><a NAME="directory"></a><font size=-1>directory</font></center>
</td>

<td><font size=-1>string</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>&nbsp;</font></td>

<td><font size=-1>Tile names from within an image montage</font></td>
</tr>

<tr>
<td>
<center><a NAME="fileName"></a><font size=-1>fileName</font></center>
</td>

<td><font size=-1>string</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const string &amp;fileName_</font></td>

<td><font size=-1>Image file name.</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="fileSize"></a><font size=-1>fileSize</font></center>
</td>

<td><font size=-1>off_t</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Number of bytes of the image on disk</font></td>
</tr>

<tr>
<td>
<center><a NAME="fillColor"></a><font size=-1>fillColor</font></center>
</td>

<td><font size=-1>Color</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const Color &amp;fillColor_</font></td>

<td><font size=-1>Color to use when filling drawn objects</font></td>
</tr>

<tr>
<td>
<center><a NAME="fillRule"></a><font size=-1>fillRule</font></center>
</td>

<td><font size=-1><a href="Enumerations.html#FillRule">FillRule</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const Magick::FillRule &amp;fillRule_</font></td>

<td><font size=-1>Rule to use when filling drawn objects.</font></td>
</tr>

<tr>
<td>
<center><a NAME="filterType"></a><font size=-1>filterType</font></center>
</td>

<td><font size=-1><a href="Enumerations.html#FilterTypes">FilterTypes</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1><a href="Enumerations.html#FilterTypes">FilterTypes</a>
filterType_</font></td>

<td><font size=-1>Filter to use when resizing image. The reduction filter
employed has a sigificant effect on the time required to resize an image
and the resulting quality. The default filter is <i>Lanczos</i> which has
been shown to produce high quality results when reducing most images.</font></td>
</tr>

<tr>
<td>
<center><a NAME="font"></a><font size=-1>font</font></center>
</td>

<td><font size=-1>string</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const string &amp;font_</font></td>

<td><font size=-1>Text rendering font. If the font is a fully qualified
X server font name, the font is obtained from an X&nbsp; server. To use
a TrueType font, precede the TrueType filename with an @. Otherwise, specify&nbsp;
a&nbsp; Postscript font name (e.g. "helvetica").</font></td>
</tr>

<tr>
<td>
<center><a NAME="fontPointsize"></a><font size=-1>fontPointsize</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>unsigned int pointSize_</font></td>

<td><font size=-1>Text rendering font point size</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="fontTypeMetrics"></a><font size=-1>fontTypeMetrics</font></center>
</td>

<td><font size=-1><a href="TypeMetric.html">TypeMetric</a></font></td>

<td><font size=-1>const std::string &amp;text_, <a href="TypeMetric.html">TypeMetric</a>
*metrics</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Update metrics with font type metrics using specified
<i>text</i>,
and current <a href="#font">font</a> and <a href="#fontPointsize">fontPointSize</a>
settings.</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="format"></a><font size=-1>format</font></center>
</td>

<td><font size=-1>string</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Long form image format description.</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="gamma"></a><font size=-1>gamma</font></center>
</td>

<td><font size=-1>double (typical range 0.8 to 2.3)</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Gamma level of the image. The same color image displayed
on two different&nbsp; workstations&nbsp; may&nbsp; look&nbsp; different
due to differences in the display monitor.&nbsp; Use gamma correction&nbsp;
to&nbsp; adjust&nbsp; for this&nbsp; color&nbsp; difference.</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="geometry"></a><font size=-1>geometry</font></center>
</td>

<td><font size=-1><a href="Geometry.html">Geometry</a></font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Preferred size of the image when encoding.</font></td>
</tr>

<tr>
<td>
<center><a NAME="gifDisposeMethod"></a><font size=-1>gifDispose-</font>
<br><font size=-1>Method</font></center>
</td>

<td><font size=-1>unsigned int</font>
<br><font size=-1>{ 0 = Disposal not specified,</font>
<br><font size=-1>1 = Do not dispose of graphic,</font>
<br><font size=-1>3 = Overwrite graphic with background color,</font>
<br><font size=-1>4 = Overwrite graphic with previous graphic. }</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>unsigned int disposeMethod_</font></td>

<td><font size=-1>GIF disposal method. This option is used to control how
successive frames are rendered (how the preceding frame is disposed of)
when creating a GIF animation.</font></td>
</tr>

<tr>
<td>
<center><a NAME="iccColorProfile"></a><font size=-1>iccColorProfile</font></center>
</td>

<td><font size=-1><a href="Blob.html">Blob</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const <a href="Blob.html">Blob</a> &amp;colorProfile_</font></td>

<td><font size=-1>ICC color profile. Supplied via a <a href="Blob.html">Blob</a>
since Magick++/ and ImageMagick do not currently support formating this
data structure directly.&nbsp; Specifications are available from the <a href="http://www.color.org/">International
Color Consortium</a> for the format of ICC color profiles.</font></td>
</tr>

<tr>
<td>
<center><a NAME="interlaceType"></a><font size=-1>interlace-</font>
<br><font size=-1>Type</font></center>
</td>

<td><font size=-1><a href="Enumerations.html#InterlaceType">InterlaceType</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1><a href="Enumerations.html#InterlaceType">InterlaceType</a>
interlace_</font></td>

<td><font size=-1>The type of interlacing scheme (default <i>NoInterlace</i>).
This option is used to specify the type of&nbsp; interlacing scheme&nbsp;
for&nbsp; raw&nbsp; image formats such as RGB or YUV. <i>NoInterlace</i>
means do not&nbsp; interlace, <i>LineInterlace</i> uses scanline interlacing,
and <i>PlaneInterlace</i> uses plane interlacing. <i>PartitionInterlace</i>
is like <i>PlaneInterlace</i> except the&nbsp; different planes&nbsp; are
saved&nbsp; to individual files (e.g.&nbsp; image.R, image.G, and image.B).
Use <i>LineInterlace</i> or <i>PlaneInterlace</i> to create an interlaced
GIF or progressive JPEG image.</font></td>
</tr>

<tr>
<td>
<center><a NAME="iptcProfile"></a><font size=-1>iptcProfile</font></center>
</td>

<td><font size=-1><a href="Blob.html">Blob</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const <a href="Blob.html">Blob</a>&amp; iptcProfile_</font></td>

<td><font size=-1>IPTC profile. Supplied via a <a href="Blob.html">Blob</a>
since Magick++ and ImageMagick do not currently&nbsp; support formating
this data structure directly. Specifications are available from the <a href="http://www.iptc.org/iptc/">International
Press Telecommunications Council</a> for IPTC profiles.</font></td>
</tr>

<tr>
<td>
<center><a NAME="label"></a><font size=-1>label</font></center>
</td>

<td><font size=-1>string</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const string &amp;label_</font></td>

<td><font size=-1>Image label</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="magick"></a><font size=-1>magick</font></center>
</td>

<td><font size=-1>string</font></td>

<td><font size=-1>void</font></td>

<td NOSAVE><font size=-1>&nbsp;const string &amp;magick_</font></td>

<td><font size=-1>Get image format (e.g. "GIF")</font></td>
</tr>

<tr>
<td>
<center><a NAME="matte"></a><font size=-1>matte</font></center>
</td>

<td><font size=-1>bool</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>bool matteFlag_</font></td>

<td><font size=-1>True if the image has transparency. If set True, store
matte channel if&nbsp; the image has one otherwise create an opaque one.</font></td>
</tr>

<tr>
<td>
<center><a NAME="matteColor"></a><font size=-1>matteColor</font></center>
</td>

<td><font size=-1><a href="Color.html">Color</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const <a href="Color.html">Color</a> &amp;matteColor_</font></td>

<td><font size=-1>Image matte (transparent) color</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="meanErrorPerPixel"></a><font size=-1>meanError-</font>
<br><font size=-1>PerPixel</font></center>
</td>

<td><font size=-1>double</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>The mean error per pixel computed when an image is color
reduced. This parameter is only valid if verbose is set to true and the
image has just been quantized.</font></td>
</tr>

<tr>
<td>
<center><a NAME="monochrome"></a><font size=-1>monochrome</font></center>
</td>

<td><font size=-1>bool</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>bool flag_</font></td>

<td><font size=-1>Transform the image to black and white</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="montageGeometry"></a><font size=-1>montage-</font>
<br><font size=-1>Geometry</font></center>
</td>

<td><font size=-1><a href="Geometry.html">Geometry</a></font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td NOSAVE><font size=-1>Tile size and offset within an image montage.
Only valid for montage images.</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="normalizedMaxError"></a><font size=-1>normalized-</font>
<br><font size=-1>MaxError</font></center>
</td>

<td><font size=-1>double</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>The normalized max error per pixel computed when an image
is color reduced. This parameter is only valid if verbose is set to true
and the image has just been quantized.</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="normalizedMeanError"></a><font size=-1>normalized-</font>
<br><font size=-1>MeanError</font></center>
</td>

<td><font size=-1>double</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>The normalized mean error per pixel computed when an
image is color reduced. This parameter is only valid if verbose is set
to true and the image has just been quantized.</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="packets"></a><font size=-1>packets</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>The number of runlength-encoded packets in</font>
<br><font size=-1>the image</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="packetSize"></a><font size=-1>packetSize</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>The number of bytes in each pixel packet</font></td>
</tr>

<tr>
<td>
<center><a NAME="page"></a><font size=-1>page</font></center>
</td>

<td><font size=-1><a href="Geometry.html#PostscriptPageSize">Geometry</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const <a href="Geometry.html#PostscriptPageSize">Geometry</a>
&amp;pageSize_</font></td>

<td><font size=-1>Preferred size and location of an image canvas.</font>
<p><font size=-1>Use this option to specify the dimensions and position
of the Postscript page in dots per inch or a TEXT page in pixels. This
option is typically used in concert with <i><a href="#density">density</a></i>.</font>
<p><font size=-1>Page may also be used to position a GIF image (such as
for a scene in an animation)</font></td>
</tr>

<tr>
<td>
<center><a NAME="penColor"></a><font size=-1>penColor</font></center>
</td>

<td><font size=-1><a href="Color.html">Color</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const <a href="Color.html">Color</a> &amp;penColor_</font></td>

<td><font size=-1>Pen color to use when annotating on or drawing on image.</font></td>
</tr>

<tr>
<td>
<center><a NAME="penTexture"></a><font size=-1>penTexture</font></center>
</td>

<td><font size=-1>Image</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const Image &amp; penTexture_</font></td>

<td><font size=-1>Texture image to paint with (similar to penColor).</font></td>
</tr>

<tr>
<td>
<center><a NAME="pixelColor"></a><font size=-1>pixelColor</font></center>
</td>

<td><font size=-1><a href="Color.html">Color</a></font></td>

<td><font size=-1>unsigned int x_, unsigned int y_</font></td>

<td><font size=-1>unsigned int x_, unsigned int y_, const <a href="Color.html">Color</a>
&amp;color_</font></td>

<td><font size=-1>Get/set pixel color at location x &amp; y.</font></td>
</tr>

<tr>
<td>
<center><a NAME="quality"></a><font size=-1>quality</font></center>
</td>

<td><font size=-1>unsigned int (0 to 100)</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>unsigned int quality_</font></td>

<td><font size=-1>JPEG/MIFF/PNG compression level (default 75).</font></td>
</tr>

<tr>
<td>
<center><a NAME="quantizeColors"></a><font size=-1>quantize-</font>
<br><font size=-1>Colors</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>unsigned int colors_</font></td>

<td><font size=-1>Preferred number of colors in the image. The actual number
of colors in the image may be less than your request, but never more. Images
with less unique colors than specified with this option will have any duplicate
or unused colors removed.</font></td>
</tr>

<tr>
<td>
<center><a NAME="quantizeColorSpace"></a><font size=-1>quantize-</font>
<br><font size=-1>ColorSpace</font></center>
</td>

<td><font size=-1><a href="Enumerations.html#ColorspaceType">ColorspaceType</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1><a href="Enumerations.html#ColorspaceType">ColorspaceType</a>
colorSpace_</font></td>

<td><font size=-1>Colorspace to quantize colors in (default RGB). Empirical
evidence suggests that distances in color spaces such as YUV or YIQ correspond
to perceptual color differences more closely than do distances in RGB space.
These color spaces may give better results when color reducing an image.</font></td>
</tr>

<tr>
<td>
<center><a NAME="quantizeDither"></a><font size=-1>quantize-</font>
<br><font size=-1>Dither</font></center>
</td>

<td><font size=-1>bool</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>bool flag_</font></td>

<td><font size=-1>Apply Floyd/Steinberg error diffusion to the image. The
basic strategy of dithering is to&nbsp; trade&nbsp; intensity resolution&nbsp;
for&nbsp; spatial&nbsp; resolution&nbsp; by&nbsp; averaging the intensities&nbsp;
of&nbsp; several&nbsp; neighboring&nbsp; pixels. Images which&nbsp; suffer&nbsp;
from&nbsp; severe&nbsp; contouring&nbsp; when&nbsp; reducing colors can
be improved with this option. The quantizeColors or monochrome option must
be set for this option to take effect.</font></td>
</tr>

<tr>
<td>
<center><a NAME="quantizeTreeDepth"></a><font size=-1>quantize-</font>
<br><font size=-1>TreeDepth</font></center>
</td>

<td><font size=-1>unsigned int&nbsp;</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>unsigned int treeDepth_</font></td>

<td><font size=-1>Depth of the quantization color classification tree.
Values of 0 or 1 allow selection of the optimal tree depth for the color
reduction algorithm. Values between 2 and 8 may be used to manually adjust
the tree depth.</font></td>
</tr>

<tr>
<td>
<center><a NAME="renderingIntent"></a><font size=-1>rendering-</font>
<br><font size=-1>Intent</font></center>
</td>

<td><font size=-1><a href="Enumerations.html#RenderingIntent">RenderingIntent</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1><a href="Enumerations.html#RenderingIntent">RenderingIntent</a>
render_</font></td>

<td><font size=-1>The type of rendering intent</font></td>
</tr>

<tr>
<td>
<center><a NAME="resolutionUnits"></a><font size=-1>resolution-</font>
<br><font size=-1>Units</font></center>
</td>

<td><font size=-1><a href="Enumerations.html#ResolutionType">ResolutionType</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1><a href="Enumerations.html#ResolutionType">ResolutionType</a>
units_</font></td>

<td><font size=-1>Units of image resolution</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="rows"></a><font size=-1>rows</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>The number of pixel rows in the image</font></td>
</tr>

<tr>
<td>
<center><a NAME="scene"></a><font size=-1>scene</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>unsigned int scene_</font></td>

<td><font size=-1>Image scene number</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="signature"></a><font size=-1>signature</font></center>
</td>

<td><font size=-1>string</font></td>

<td><font size=-1>bool force_ = false</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Image MD5 signature. Set force_ to 'true' to force re-computation
of signature.</font></td>
</tr>

<tr>
<td>
<center><a NAME="size"></a><font size=-1>size</font></center>
</td>

<td><font size=-1><a href="Geometry.html">Geometry</a></font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const <a href="Geometry.html">Geometry</a> &amp;geometry_</font></td>

<td><font size=-1>Width and height of a raw image (an image which does
not support width and height information).&nbsp; Size may also be used
to affect the image size read from a multi-resolution format (e.g. Photo
CD, JBIG, or JPEG.</font></td>
</tr>

<tr>
<td>
<center><a NAME="strokeAntiAlias"></a><font size=-1>strokeAntiAlias</font></center>
</td>

<td><font size=-1>bool</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>bool flag_</font></td>

<td><font size=-1>Enable or disable anti-aliasing when drawing object outlines.</font></td>
</tr>

<tr>
<td>
<center><a NAME="strokeColor"></a><font size=-1>strokeColor</font></center>
</td>

<td><font size=-1>Color</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const Color &amp;strokeColor_</font></td>

<td><font size=-1>Color to use when drawing object outlines</font></td>
</tr>

<tr>
<td>
<center><a NAME="strokeDashOffset"></a><font size=-1>strokeDashOffset</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>double strokeDashOffset_</font></td>

<td><font size=-1>While drawing using a dash pattern, specify distance
into the dash pattern to start the dash (default 0).</font></td>
</tr>

<tr>
<td>
<center><a NAME="strokeDashArray"></a><font size=-1>strokeDashArray</font></center>
</td>

<td><font size=-1>const double*</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const double* strokeDashArray_</font></td>

<td><font size=-1>Specify the pattern of dashes and gaps used to stroke
paths. The strokeDashArray represents a zero-terminated array of numbers
that specify the lengths (in pixels) of alternating dashes and gaps in
user units. If an odd number of values is provided, then the list of values
is repeated to yield an even number of values.&nbsp; A typical strokeDashArray_
array might contain the members 5 3 2 0, where the zero value indicates
the end of the pattern array.</font></td>
</tr>

<tr>
<td>
<center><a NAME="strokeLineCap"></a><font size=-1>strokeLineCap</font></center>
</td>

<td><font size=-1>LineCap</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>LineCap lineCap_</font></td>

<td><font size=-1>Specify the shape to be used at the corners of paths
(or other vector shapes) when they are stroked. Values of LineJoin are
UndefinedJoin, MiterJoin, RoundJoin, and BevelJoin.</font></td>
</tr>

<tr>
<td>
<center><a NAME="strokeLineJoin"></a><font size=-1>strokeLineJoin</font></center>
</td>

<td><font size=-1>LineJoin</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>LineJoin lineJoin_</font></td>

<td><font size=-1>Specify the shape to be used at the corners of paths
(or other vector shapes) when they are stroked. Values of LineJoin are
UndefinedJoin, MiterJoin, RoundJoin, and BevelJoin.</font></td>
</tr>

<tr>
<td>
<center><a NAME="strokeMiterLimit"></a><font size=-1>strokeMiterLimit</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>unsigned int miterLimit_</font></td>

<td><font size=-1>Specify miter limit. When two line segments meet at a
sharp angle and miter joins have been specified for 'lineJoin', it is possible
for the miter to extend far beyond the thickness of the line stroking the
path. The miterLimit' imposes a limit on the ratio of the miter length
to the 'lineWidth'. The default value of this parameter is 4.</font></td>
</tr>

<tr>
<td>
<center><a NAME="strokeWidth"></a><a NAME="lineWidth"></a><font size=-1>strokeWidth</font></center>
</td>

<td><font size=-1>double</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>double strokeWidth_</font></td>

<td><font size=-1>Stroke width for use when drawing vector objects (default
one)</font></td>
</tr>

<tr>
<td>
<center><a NAME="subImage"></a><font size=-1>subImage</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>unsigned int subImage_</font></td>

<td><font size=-1>Subimage of an image sequence</font></td>
</tr>

<tr>
<td>
<center><a NAME="subRange"></a><font size=-1>subRange</font></center>
</td>

<td><font size=-1>unsigned int</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>unsigned int subRange_</font></td>

<td><font size=-1>Number of images relative to the base image</font></td>
</tr>

<tr>
<td>
<center><a NAME="tileName"></a><font size=-1>tileName</font></center>
</td>

<td><font size=-1>string</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const string &amp;tileName_</font></td>

<td><font size=-1>Tile name</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="totalColors"></a><font size=-1>totalColors</font></center>
</td>

<td><font size=-1>unsigned long</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>Number of colors in the image</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="type"></a><font size=-1>type</font></center>
</td>

<td><font size=-1><a href="Enumerations.html#ImageType">ImageType</a></font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#FFFFFF" NOSAVE><font size=-1><a href="Enumerations.html#ImageType">ImageType</a></font></td>

<td><font size=-1>Image type.</font></td>
</tr>

<tr>
<td>
<center><a NAME="verbose"></a><font size=-1>verbose</font></center>
</td>

<td><font size=-1>bool</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>bool verboseFlag_</font></td>

<td><font size=-1>Print detailed information about the image</font></td>
</tr>

<tr>
<td>
<center><a NAME="view"></a><font size=-1>view</font></center>
</td>

<td><font size=-1>string</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const string &amp;view_</font></td>

<td><font size=-1>FlashPix viewing parameters.</font></td>
</tr>

<tr>
<td>
<center><a NAME="x11Display"></a><font size=-1>x11Display</font></center>
</td>

<td><font size=-1>string (e.g. "hostname:0.0")</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>const string &amp;display_</font></td>

<td><font size=-1>X11 display to display to, obtain fonts from, or to capture
image from</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="xResolution"></a><font size=-1>xResolution</font></center>
</td>

<td><font size=-1>double</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>x resolution of the image</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="yResolution"></a><font size=-1>yResolution</font></center>
</td>

<td><font size=-1>double</font></td>

<td><font size=-1>void</font></td>

<td BGCOLOR="#666666" NOSAVE><font size=-1>&nbsp;</font></td>

<td><font size=-1>y resolution of the image</font></td>
</tr>
</table>

<center>
<h3>
<a NAME="Raw Image Pixel Access"></a>Raw Image Pixel Access</h3></center>
Image pixels (of type <i><a href="PixelPacket.html">PixelPacket</a></i>)
may be accessed directly via the <i>Image Pixel Cache</i>.&nbsp; The image
pixel cache is a rectangular window into the actual image pixels (which
may be in memory, memory-mapped from a disk file, or entirely on disk).
Two interfaces exist to access the <i>Image Pixel Cache.</i> The interface
described here (part of the <i>Image</i> class) supports only one view
at a time. See the <i><a href="Pixels.html">Pixels</a></i> class for a
more abstract interface which supports simultaneous pixel views (up to
the number of rows). As an analogy, the interface described here relates
to the <i><a href="Pixels.html">Pixels</a></i> class as stdio's gets()
relates to fgets(). The <i><a href="Pixels.html">Pixels</a></i> class provides
the more general form of the interface.
<p>Obtain existing image pixels via <i>getPixels()</i>. Create a new pixel
region using <i>setPixels().</i>
<p>Depending on the capabilities of the operating system, and the relationship
of the window to the image, the pixel cache may be a copy of the pixels
in the selected window, or it may be the actual image pixels. In any case
calling <i>syncPixels()</i> insures that the base image is updated with
the contents of the modified pixel cache. The method
<i>readPixels()</i>
supports copying foreign pixel data formats into the pixel cache according
to the <i>QuantumTypes</i>. The method <i>writePixels()</i> supports copying
the pixels in the cache to a foreign pixel representation according to
the format specified by <i>QuantumTypes</i>.
<p>The pixel region is effectively a small image in which the pixels may
be accessed, addressed, and updated, as shown in the following example:
<table BORDER=0 WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td NOSAVE><font face="Courier New,Courier"><font color="#000099"><font size=-1>Image
image("cow.png");</font></font></font>
<br><font face="Courier New,Courier"><font color="#FF0000"><font size=-1>//
Obtain pixel region with size 60x40, and top origin at 20x30</font></font></font>
<br><font face="Courier New,Courier"><font color="#000099"><font size=-1>int
columns = 60;</font></font></font>
<br><font face="Courier New,Courier"><font color="#000099"><font size=-1>PixelPacket
*pixel_cache = image.GetPixels(20,30,columns,40);</font></font></font>
<br><font face="Courier New,Courier"><font color="#FF0000"><font size=-1>//
Set pixel at column 5, and row 10 in the pixel cache to red.</font></font></font>
<br><font face="Courier New,Courier"><font color="#000099"><font size=-1>int
column = 5;</font></font></font>
<br><font face="Courier New,Courier"><font color="#000099"><font size=-1>int
row = 10;</font></font></font>
<br><font face="Courier New,Courier"><font color="#000099"><font size=-1>PixelPacket
*pixel = pixel_cache+row*columns*sizeof(PixelPacket)+column;</font></font></font>
<br><font face="Courier New,Courier"><font color="#000099"><font size=-1>pixel
= Color("red");</font></font></font>
<br><font face="Courier New,Courier"><font color="#FF0000"><font size=-1>//
Save updated pixel cache back to underlying image</font></font></font>
<br><font face="Courier New,Courier"><font color="#000099"><font size=-1>image.syncPixels();</font></font></font>
<br><font face="Courier New,Courier"><font color="#000099"><font size=-1>image.write("horse.png");</font></font></font></td>

<td><img SRC="Cache.png" height=218 width=254></td>
</tr>
</table>

<p>The image cache supports the following methods:
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<caption>Image Cache Methods</caption>

<tr>
<td>
<center><b>Method</b></center>
</td>

<td>
<center><b>Returns</b></center>
</td>

<td>
<center><b>Signature</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr>
<td>
<center><a NAME="getConstPixels"></a><font size=-1>getConstPixels</font></center>
</td>

<td><font size=-1>const <a href="PixelPacket.html">PixelPacket</a>*</font></td>

<td><font size=-1>int x_, int y_, unsigned int columns_, unsigned int rows_</font></td>

<td><font size=-1>Transfers pixels from the image to the pixel cache as
defined by the specified rectangular region.&nbsp;</font></td>
</tr>

<tr>
<td>
<center><a NAME="getConstIndexes"></a><font size=-1>getConstIndexes</font></center>
</td>

<td><font size=-1>const IndexPacket*</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>Returns a pointer to the Image pixel indexes. Only valid
for PseudoClass images or CMYKA images. The pixel indexes represent an
array of type IndexPacket, with each entry corresponding to an x,y pixel
position. For PseudoClass images, the entry's value is the offset into
the colormap (see <a href="#colorMap">colorMap</a>) for that pixel. For
CMYKA images, the indexes are used to contain the alpha channel.</font></td>
</tr>

<tr>
<td>
<center><a NAME="getIndexes"></a><font size=-1>getIndexes</font></center>
</td>

<td><font size=-1>IndexPacket*</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>Returns a pointer to the Image pixel indexes. Only valid
for PseudoClass images or CMYKA images. The pixel indexes represent an
array of type IndexPacket, with each entry corresponding to an x,y pixel
position. For PseudoClass images, the entry's value is the offset into
the colormap (see <a href="#colorMap">colorMap</a>)&nbsp; for that pixel.
For CMYKA images, the indexes are used to contain the alpha channel.</font></td>
</tr>

<tr>
<td>
<center><a NAME="getPixels"></a><font size=-1>getPixels</font></center>
</td>

<td><font size=-1><a href="PixelPacket.html">PixelPacket</a>*</font></td>

<td><font size=-1>int x_, int y_, unsigned int columns_, unsigned int rows_</font></td>

<td><font size=-1>Transfers pixels from the image to the pixel cache as
defined by the specified rectangular region. Modified pixels may be subsequently
transferred back to the image via syncPixels.</font></td>
</tr>

<tr NOSAVE>
<td>
<center><a NAME="setPixels"></a><font size=-1>setPixels</font></center>
</td>

<td><font size=-1><a href="PixelPacket.html">PixelPacket</a>*</font></td>

<td NOSAVE><font size=-1>int x_, int y_, unsigned int columns_, unsigned
int rows_</font></td>

<td><font size=-1>Allocates a pixel cache region to store image pixels
as defined by the region rectangle.&nbsp; This area is subsequently transferred
from the pixel cache to the image via syncPixels.</font></td>
</tr>

<tr>
<td>
<center><a NAME="syncPixels"></a><font size=-1>syncPixels</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1>void</font></td>

<td><font size=-1>Transfers the image cache pixels to the image.</font></td>
</tr>

<tr>
<td>
<center><a NAME="readPixels"></a><font size=-1>readPixels</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1><a href="Enumerations.html#QuantumTypes">QuantumTypes</a>
quantum_, unsigned char *source_,</font></td>

<td><font size=-1>Transfers one or more pixel components from a buffer
or file into the image pixel cache of an image. ReadPixels is typically
used to support image decoders.</font></td>
</tr>

<tr>
<td>
<center><a NAME="writePixels"></a><font size=-1>writePixels</font></center>
</td>

<td><font size=-1>void</font></td>

<td><font size=-1><a href="Enumerations.html#QuantumTypes">QuantumTypes</a>
quantum_, unsigned char *destination_</font></td>

<td><font size=-1>Transfers one or more pixel components from the image
pixel cache to a buffer or file. WritePixels is typically used to support
image encoders.</font></td>
</tr>
</table>

<br>&nbsp;
</body>
</html>
