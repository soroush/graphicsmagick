<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><HTML>
<HEAD><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<TITLE>constitute - Methods to Constitute an Image</TITLE>
<link rel="StyleSheet" href="../magick.css" type="text/css">
</HEAD>

<body bgcolor="#FFFFFF" text="#000000" link="#0085c0" alink="#0085c0"  vlink="#800080">

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">
<FONT SIZE=-1>NAME</FONT></A>
	<LI><A HREF="#synopsis">
<FONT SIZE=-1>SYNOPSIS</FONT></A>
	<LI><A HREF="#function descriptions">
<FONT SIZE=-1>FUNCTION</FONT> 
<FONT SIZE=-1>DESCRIPTIONS</FONT></A>
	<UL>

		<LI><A HREF="#constituteimage">ConstituteImage</A>
		<LI><A HREF="#destroyconstitute">DestroyConstitute</A>
		<LI><A HREF="#dispatchimage">DispatchImage</A>
		<LI><A HREF="#pingimage">PingImage</A>
		<LI><A HREF="#popimagepixels">PopImagePixels</A>
		<LI><A HREF="#pushimagepixels">PushImagePixels</A>
		<LI><A HREF="#readimage">ReadImage</A>
		<LI><A HREF="#readinlineimage">ReadInlineImage</A>
		<LI><A HREF="#writeimage">WriteImage</A>
		<LI><A HREF="#writeimages">WriteImages</A>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">
<FONT SIZE=-1>NAME</FONT></A></H1>
<P>constitute - Methods to Constitute an Image</P>
<P>
<HR>
<H1><A NAME="synopsis">
<FONT SIZE=-1>SYNOPSIS</FONT></A></H1>
<P>Image * <STRONG>ConstituteImage</STRONG>( const unsigned long width, const unsigned long height, const char *map, const StorageType type, const void *pixels, ExceptionInfo *exception );</P>
<P><STRONG>DestroyConstitute</STRONG>( void );</P>
<P>unsigned int  <STRONG>DispatchImage</STRONG>( const Image *image, const long x_offset, const long y_offset, const unsigned long columns, const unsigned long rows, const char *map, const StorageType type, void *pixels, ExceptionInfo *exception );</P>
<P>Image * <STRONG>PingImage</STRONG>( const ImageInfo *image_info, ExceptionInfo *exception );</P>
<P>unsigned int  <STRONG>PopImagePixels</STRONG>( const Image *, const QuantumType quantum, unsigned char *destination );</P>
<P>unsigned int  <STRONG>PushImagePixels</STRONG>( Image *image, const QuantumType quantum, const unsigned char *source );</P>
<P>Image * <STRONG>ReadImage</STRONG>( const ImageInfo *image_info, ExceptionInfo *exception );</P>
<P>Image * <STRONG>ReadInlineImage</STRONG>( const ImageInfo *image_info, const char *content, ExceptionInfo *exception );</P>
<P>unsigned int  <STRONG>WriteImage</STRONG>( const ImageInfo *image_info, Image *image );</P>
<P>unsigned int  <STRONG>WriteImages</STRONG>( const ImageInfo *image_info, Image *image, const char *filename, ExceptionInfo *exception );</P>
<P>
<HR>
<H1><A NAME="function descriptions">
<FONT SIZE=-1>FUNCTION</FONT> 
<FONT SIZE=-1>DESCRIPTIONS</FONT></A></H1>
<P>
<H2><A NAME="constituteimage">ConstituteImage</A></H2>
<blockquote>ConstituteImage() returns an image from the the pixel data you supply. The pixel data must be in scanline order top-to-bottom. The data can be char, short int, int, float, or double. Float and double require the pixels to be normalized [0..1], otherwise [0..MaxRGB]. For example, to create a 640x480 image from unsigned red-green-blue character data, use </blockquote><blockquote>image=ConstituteImage ( 640, 480, "RGB", CharPixel, pixels, &exception );; </blockquote><P>The format of the Constitute method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ConstituteImage ( const unsigned long width, const unsigned long height, const char *map, const StorageType type, const void *pixels, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DT><DD><DL>
<dd><p></p><dt><STRONG><A NAME="item_o_width%3A">width:</A></STRONG><BR>
<DD>
width in pixels of the image.
<P></P>
<dd><p></p><dt><STRONG><A NAME="item_o_height%3A">height:</A></STRONG><BR>
<DD>
height in pixels of the image.
<P></P>
<dd><p></p><dt><STRONG><A NAME="item_o_map%3A">map:</A></STRONG><BR>
<DD>
This string reflects the expected ordering of the pixel array.  It can be any combination or order of 
<FONT SIZE=-1>R</FONT> = red, 
<FONT SIZE=-1>G</FONT> = green, 
<FONT SIZE=-1>B</FONT> = blue, 
<FONT SIZE=-1>A</FONT> = alpha, 
<FONT SIZE=-1>C</FONT> = cyan, 
<FONT SIZE=-1>Y</FONT> = yellow, 
<FONT SIZE=-1>M</FONT> = magenta, 
<FONT SIZE=-1>K</FONT> = black, or 
<FONT SIZE=-1>I</FONT> = intensity (for grayscale).
<P></P>
<dd><p></p><dt><STRONG><A NAME="item_o_type%3A">type:</A></STRONG><BR>
<DD>
Define the data type of the pixels.  Float and double types are expected to be normalized [0..1] otherwise [0..MaxRGB]. Choose from these types: CharPixel, ShortPixel, IntegerPixel, LongPixel, FloatPixel, or DoublePixel.
<P></P>
<dd><p></p><dt><STRONG><A NAME="item_o_pixels%3A">pixels:</A></STRONG><BR>
<DD>
This array of values contain the pixel components as defined by map and type.  You must preallocate this array where the expected length varies depending on the values of width, height, map, and type.
<P></P>
<dd><p></p><dt><STRONG><A NAME="item_o_exception%3A">exception:</A></STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="destroyconstitute">DestroyConstitute</A></H2>
<blockquote>DestroyConstitute() destroys the constitute environment. </blockquote><P>The format of the DestroyConstitute method is:</P>
<blockquote>DestroyConstitute ( void ); </blockquote><P>
<H2><A NAME="dispatchimage">DispatchImage</A></H2>
<blockquote>DispatchImage() extracts pixel data from an image and returns it to you. The method returns False on success otherwise True if an error is encountered. The data is returned as char, short int, int, long, float, or double in the order specified by map. </blockquote><P>Suppose we want want to extract the first scanline of a 640x480 image as character data in red-green-blue order:</P>
<blockquote>DispatchImage ( image, 0, 0, 640, 1, "RGB", 0, pixels, exception );; </blockquote><P>The format of the DispatchImage method is:</P>
<blockquote>unsigned int DispatchImage ( const <A HREF="types/Image.html">Image</A> *image, const long x_offset, const long y_offset, const unsigned long columns, const unsigned long rows, const char *map, const StorageType type, void *pixels, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DT><DD><DL>
<dd><p></p><dt><STRONG><A NAME="item_o_image%3A">image:</A></STRONG><BR>
<DD>
The image.
<P></P>
<dd><p></p><dt><STRONG><A NAME="item_o_x_offset%2C_y_offset%2C_columns%2C_rows%3A">x_offset, y_offset, columns, rows:</A></STRONG><BR>
<DD>
These values define the perimeter of a region of pixels you want to extract.
<P></P>
<dd><p></p><dt><STRONG>map:</STRONG><BR>
<DD>
This string reflects the expected ordering of the pixel array.  It can be any combination or order of 
<FONT SIZE=-1>R</FONT> = red, 
<FONT SIZE=-1>G</FONT> = green, 
<FONT SIZE=-1>B</FONT> = blue, 
<FONT SIZE=-1>A</FONT> = alpha, 
<FONT SIZE=-1>C</FONT> = cyan, 
<FONT SIZE=-1>Y</FONT> = yellow, 
<FONT SIZE=-1>M</FONT> = magenta, 
<FONT SIZE=-1>K</FONT> = black, or 
<FONT SIZE=-1>I</FONT> = intensity (for grayscale).
<P></P>
<dd><p></p><dt><STRONG>type:</STRONG><BR>
<DD>
Define the data type of the pixels.  Float and double types are normalized to [0..1] otherwise [0..MaxRGB]. Choose from these types: CharPixel, ShortPixel, IntegerPixel, LongPixel, FloatPixel, or DoublePixel.
<P></P>
<dd><p></p><dt><STRONG>pixels:</STRONG><BR>
<DD>
This array of values contain the pixel components as defined by map and type.  You must preallocate this array where the expected length varies depending on the values of width, height, map, and type.
<P></P>
<dd><p></p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="pingimage">PingImage</A></H2>
<blockquote>PingImage() returns all the attributes of an image or image sequence except for the pixels. It is much faster and consumes far less memory than ReadImage ( ) . On failure, a NULL image is returned and exception describes the reason for the failure. </blockquote><P>The format of the PingImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *PingImage ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DT><DD><DL>
<dd><p></p><dt><STRONG><A NAME="item_o_image_info%3A">image_info:</A></STRONG><BR>
<DD>
Ping the image defined by the file or filename members of this structure.
<P></P>
<dd><p></p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="popimagepixels">PopImagePixels</A></H2>
<blockquote>PopImagePixels() transfers one or more pixel components from the image pixel cache to a user supplied buffer. True is returned if the pixels are successfully transferred, otherwise False. </blockquote><P>The format of the PopImagePixels method is:</P>
<blockquote>unsigned int PopImagePixels ( const <A HREF="types/Image.html">Image</A> *, const QuantumType quantum, unsigned char *destination ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DT><DD><DL>
<dd><p></p><dt><STRONG><A NAME="item_o_status%3A">status:</A></STRONG><BR>
<DD>
Method PopImagePixels returns True if the pixels are successfully transferred, otherwise False.
<P></P>
<dd><p></p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P>
<dd><p></p><dt><STRONG><A NAME="item_o_quantum%3A">quantum:</A></STRONG><BR>
<DD>
Declare which pixel components to transfer 
<FONT SIZE=-1>(RGB,</FONT> 
<FONT SIZE=-1>RGBA,</FONT> etc).
<P></P>
<dd><p></p><dt><STRONG><A NAME="item_o_destination%3A">destination:</A></STRONG><BR>
<DD>
The components are transferred to this buffer.
<P></P></DL></DL>
<P>
<H2><A NAME="pushimagepixels">PushImagePixels</A></H2>
<blockquote>PushImagePixels() transfers one or more pixel components from a user supplied buffer into the image pixel cache of an image. It returns True if the pixels are successfully transferred, otherwise False. </blockquote><P>The format of the PushImagePixels method is:</P>
<blockquote>unsigned int PushImagePixels ( <A HREF="types/Image.html">Image</A> *image, const QuantumType quantum, const unsigned char *source ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DT><DD><DL>
<dd><p></p><dt><STRONG>status:</STRONG><BR>
<DD>
Method PushImagePixels returns True if the pixels are successfully transferred, otherwise False.
<P></P>
<dd><p></p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P>
<dd><p></p><dt><STRONG>quantum:</STRONG><BR>
<DD>
Declare which pixel components to transfer (red, green, blue, opacity, 
<FONT SIZE=-1>RGB,</FONT> or 
<FONT SIZE=-1>RGBA).</FONT>
<P></P>
<dd><p></p><dt><STRONG><A NAME="item_o_source%3A">source:</A></STRONG><BR>
<DD>
The pixel components are transferred from this buffer.
<P></P></DL></DL>
<P>
<H2><A NAME="readimage">ReadImage</A></H2>
<blockquote>ReadImage() reads an image or image sequence from a file or file handle. The method returns a NULL if there is a memory shortage or if the image cannot be read. On failure, a NULL image is returned and exception describes the reason for the failure. </blockquote><P>The format of the ReadImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ReadImage ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DT><DD><DL>
<dd><p></p><dt><STRONG>image_info:</STRONG><BR>
<DD>
Read the image defined by the file or filename members of this structure.
<P></P>
<dd><p></p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="readinlineimage">ReadInlineImage</A></H2>
<blockquote>ReadInlineImage() reads a Base64-encoded inline image or image sequence. The method returns a NULL if there is a memory shortage or if the image cannot be read. On failure, a NULL image is returned and exception describes the reason for the failure. </blockquote><P>The format of the ReadInlineImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ReadInlineImage ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, const char *content, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DT><DD><DL>
<dd><p></p><dt><STRONG>image_info:</STRONG><BR>
<DD>
The image info.
<P></P>
<dd><p></p><dt><STRONG><A NAME="item_o_content%3A">content:</A></STRONG><BR>
<DD>
The image encoded in Base64.
<P></P>
<dd><p></p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="writeimage">WriteImage</A></H2>
<P>Use <CODE>Write()</CODE> to write an image or an image sequence to a file or filehandle.  If writing to a file on disk, the name is defined by the filename member of the image structure.  <CODE>Write()</CODE> returns 0 is there is a memory shortage or if the image cannot be written.  Check the exception member of image to determine the cause for any failure.</P>
<P>The format of the WriteImage method is:</P>
<blockquote>unsigned int WriteImage ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, <A HREF="types/Image.html">Image</A> *image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DT><DD><DL>
<dd><p></p><dt><STRONG>image_info:</STRONG><BR>
<DD>
The image info.
<P></P>
<dd><p></p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P></DL></DL>
<P>
<H2><A NAME="writeimages">WriteImages</A></H2>
<blockquote>WriteImages() writes an image sequence. </blockquote><P>The format of the WriteImages method is:</P>
<blockquote>unsigned int WriteImages ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, <A HREF="types/Image.html">Image</A> *image, const char *filename, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DT><DD><DL>
<dd><p></p><dt><STRONG>image_info:</STRONG><BR>
<DD>
The image info.
<P></P>
<dd><p></p><dt><STRONG><A NAME="item_o_images%3A">images:</A></STRONG><BR>
<DD>
The image list.
<P></P>
<dd><p></p><dt><STRONG><A NAME="item_o_filename%3A">filename:</A></STRONG><BR>
<DD>
The image filename.
<P></P>
<dd><p></p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
</DL></DL>

</BODY>

</HTML>
