<HTML>
<HEAD>
<TITLE>effect - ImageMagick Image Effects Methods</TITLE>
<LINK REV="made" HREF="mailto:bhcompile@daffy.perf.redhat.com">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">
<FONT SIZE=-1>NAME</FONT></A></LI>
	<LI><A HREF="#synopsis">
<FONT SIZE=-1>SYNOPSIS</FONT></A></LI>
	<LI><A HREF="#function descriptions">
<FONT SIZE=-1>FUNCTION</FONT> 
<FONT SIZE=-1>DESCRIPTIONS</FONT></A></LI>
	<UL>

		<LI><A HREF="#addnoiseimage">AddNoiseImage</A></LI>
		<LI><A HREF="#blurimage">BlurImage</A></LI>
		<LI><A HREF="#charcoalimage">CharcoalImage</A></LI>
		<LI><A HREF="#colorizeimage">ColorizeImage</A></LI>
		<LI><A HREF="#convolveimage">ConvolveImage</A></LI>
		<LI><A HREF="#despeckleimage">DespeckleImage</A></LI>
		<LI><A HREF="#edgeimage">EdgeImage</A></LI>
		<LI><A HREF="#embossimage">EmbossImage</A></LI>
		<LI><A HREF="#enhanceimage">EnhanceImage</A></LI>
		<LI><A HREF="#gaussianblurimage">GaussianBlurImage</A></LI>
		<LI><A HREF="#implodeimage">ImplodeImage</A></LI>
		<LI><A HREF="#medianfilterimage">MedianFilterImage</A></LI>
		<LI><A HREF="#morphimages">MorphImages</A></LI>
		<LI><A HREF="#motionblurimage">MotionBlurImage</A></LI>
		<LI><A HREF="#oilpaintimage">OilPaintImage</A></LI>
		<LI><A HREF="#plasmaimage">PlasmaImage</A></LI>
		<LI><A HREF="#reducenoiseimage">ReduceNoiseImage</A></LI>
		<LI><A HREF="#shadeimage">ShadeImage</A></LI>
		<LI><A HREF="#sharpenimage">SharpenImage</A></LI>
		<LI><A HREF="#solarizeimage">SolarizeImage</A></LI>
		<LI><A HREF="#spreadimage">SpreadImage</A></LI>
		<LI><A HREF="#steganoimage">SteganoImage</A></LI>
		<LI><A HREF="#stereoimage">StereoImage</A></LI>
		<LI><A HREF="#swirlimage">SwirlImage</A></LI>
		<LI><A HREF="#thresholdimage">ThresholdImage</A></LI>
		<LI><A HREF="#unsharpmaskimage">UnsharpMaskImage</A></LI>
		<LI><A HREF="#waveimage">WaveImage</A></LI>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">
<FONT SIZE=-1>NAME</FONT></A></H1>
<P>effect - ImageMagick Image Effects Methods</P>
<P>
<HR>
<H1><A NAME="synopsis">
<FONT SIZE=-1>SYNOPSIS</FONT></A></H1>
<P>Image * <STRONG>AddNoiseImage</STRONG>( const Image *image, const NoiseType noise_type, ExceptionInfo *exception );</P>
<P>Image * <STRONG>BlurImage</STRONG>( const Image *image, const double radius, const double sigma, ExceptionInfo *exception );</P>
<P>Image * <STRONG>CharcoalImage</STRONG>( const Image *image, const double radius, const double sigma, ExceptionInfo *exception );</P>
<P>Image * <STRONG>ColorizeImage</STRONG>( const Image *image, const char *opacity, const PixelPacket target, ExceptionInfo *exception );</P>
<P>Image * <STRONG>ConvolveImage</STRONG>( const Image *image, const unsigned int order, const double *kernel, ExceptionInfo *exception );</P>
<P>Image * <STRONG>DespeckleImage</STRONG>( const Image *image, ExceptionInfo *exception );</P>
<P>Image * <STRONG>EdgeImage</STRONG>( const Image *image, const double radius, ExceptionInfo *exception );</P>
<P>Image * <STRONG>EmbossImage</STRONG>( const Image *image, const double radius, const double sigma, ExceptionInfo *exception );</P>
<P>Image * <STRONG>EnhanceImage</STRONG>( const Image *image, ExceptionInfo *exception );</P>
<P>Image * <STRONG>GaussianBlurImage</STRONG>( const Image *image, const double radius, const double sigma, ExceptionInfo *exception );</P>
<P>Image * <STRONG>ImplodeImage</STRONG>( const Image *image, const double amount, ExceptionInfo *exception );</P>
<P>Image * <STRONG>MedianFilterImage</STRONG>( const Image *image, const double radius, ExceptionInfo *exception );</P>
<P>Image * <STRONG>MorphImages</STRONG>( const Image *image, const unsigned long number_frames, ExceptionInfo *exception );</P>
<P>Image * <STRONG>MotionBlurImage</STRONG>( const Image *image, const double radius, const double sigma, const double amount, ExceptionInfo *exception );</P>
<P>Image * <STRONG>OilPaintImage</STRONG>( const Image *image, const double radius, ExceptionInfo *exception );</P>
<P>unsigned int  <STRONG>PlasmaImage</STRONG>( Image *image, const SegmentInfo *segment, int attenuate, int depth );</P>
<P>Image * <STRONG>ReduceNoiseImage</STRONG>( const Image *image, const double radius, ExceptionInfo *exception );</P>
<P>Image * <STRONG>ShadeImage</STRONG>( const Image *image, const unsigned int color_shading, double azimuth, double elevation, ExceptionInfo *exception );</P>
<P>Image * <STRONG>SharpenImage</STRONG>( const Image *image, const double radius, const double sigma, ExceptionInfo *exception );</P>
<P>void  <STRONG>SolarizeImage</STRONG>( Image *image, const double threshold );</P>
<P>Image * <STRONG>SpreadImage</STRONG>( const Image *image, const unsigned int radius, ExceptionInfo *exception );</P>
<P>Image * <STRONG>SteganoImage</STRONG>( const Image *image, Image *watermark, ExceptionInfo *exception );</P>
<P>Image * <STRONG>StereoImage</STRONG>( const Image *image, const Image *offset_image, ExceptionInfo *exception );</P>
<P>Image * <STRONG>SwirlImage</STRONG>( const Image *image, double degrees, ExceptionInfo *exception );</P>
<P>unsigned int  <STRONG>ThresholdImage</STRONG>( Image *image, const double threshold );</P>
<P>Image * <STRONG>UnsharpMaskImage</STRONG>( const Image *image, const double radius, const double sigma, const double amount, const double threshold, ExceptionInfo *exception );</P>
<P>Image * <STRONG>WaveImage</STRONG>( const Image *image, const double amplitude, const double wave_length, ExceptionInfo *exception );</P>
<P>
<HR>
<H1><A NAME="function descriptions">
<FONT SIZE=-1>FUNCTION</FONT> 
<FONT SIZE=-1>DESCRIPTIONS</FONT></A></H1>
<P>
<H2><A NAME="addnoiseimage">AddNoiseImage</A></H2>
<blockquote>AddNoiseImage() adds random noise to the image. </blockquote><P>The format of the AddNoiseImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *AddNoiseImage ( const <A HREF="types/Image.html">Image</A> *image, const <A HREF="types/Enumerations.html#NoiseType">NoiseType</A> noise_type, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG><A NAME="item_o_image%3A">o image:</A></STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG><A NAME="item_o_noise_type%3A">o noise_type:</A></STRONG><BR>
<DD>
The type of noise: Uniform, Gaussian, Multiplicative, Impulse, Laplacian, or Poisson.
<P></P>
<DT><STRONG><A NAME="item_o_exception%3A">o exception:</A></STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="blurimage">BlurImage</A></H2>
<blockquote>BlurImage() blurs an image. We convolve the image with a Gaussian operator of the given radius and standard deviation ( sigma ) . For reasonable results, the radius should be larger than sigma. Use a radius of 0 and BlurImage ( ) selects a suitable radius for you. </blockquote><P>The format of the BlurImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *BlurImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG><A NAME="item_o_radius%3A">o radius:</A></STRONG><BR>
<DD>
The radius of the Gaussian, in pixels, not counting the center pixel.
<P></P>
<DT><STRONG><A NAME="item_o_sigma%3A">o sigma:</A></STRONG><BR>
<DD>
The standard deviation of the Gaussian, in pixels.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="charcoalimage">CharcoalImage</A></H2>
<P>Method CharcoalImage creates a new image that is a copy of an existing one with the edge highlighted.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the CharcoalImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *CharcoalImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG><A NAME="item_o_charcoal_image%3A">o charcoal_image:</A></STRONG><BR>
<DD>
Method CharcoalImage returns a pointer to the image after it is embossed.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o radius:</STRONG><BR>
<DD>
the radius of the pixel neighborhood.
<P></P>
<DT><STRONG>o sigma:</STRONG><BR>
<DD>
The standard deviation of the Gaussian, in pixels.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="colorizeimage">ColorizeImage</A></H2>
<blockquote>ColorizeImage() blends the fill color with each pixel in the image. A percentage blend is specified with opacity. Control the application of different color components by specifying a different percentage for </blockquote><P>The format of the ColorizeImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ColorizeImage ( const <A HREF="types/Image.html">Image</A> *image, const char *opacity, const <A HREF="types/PixelPacket.html">PixelPacket</A> target, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG><A NAME="item_o_opacity%3A">o opacity:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> character string indicating the level of opacity as a percentage.
<P></P>
<DT><STRONG><A NAME="item_o_target%3A">o target:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> color value.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="convolveimage">ConvolveImage</A></H2>
<blockquote>ConvolveImage() applies a custom convolution kernel to the image. </blockquote><P>The format of the ConvolveImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ConvolveImage ( const <A HREF="types/Image.html">Image</A> *image, const unsigned int order, const double *kernel, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG><A NAME="item_o_order%3A">o order:</A></STRONG><BR>
<DD>
The number of columns and rows in the filter kernel.
<P></P>
<DT><STRONG><A NAME="item_o_kernel%3A">o kernel:</A></STRONG><BR>
<DD>
An array of double representing the convolution kernel.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="despeckleimage">DespeckleImage</A></H2>
<P><CODE>Despeckle()</CODE> reduces the speckle noise in an image while perserving the edges of the original image.</P>
<P>The format of the DespeckleImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *DespeckleImage ( const <A HREF="types/Image.html">Image</A> *image, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="edgeimage">EdgeImage</A></H2>
<blockquote>EdgeImage() finds edges in an image. Radius defines the radius of the convolution filter. Use a radius of 0 and Edge ( ) selects a suitable radius for you. </blockquote><P>The format of the EdgeImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *EdgeImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o radius:</STRONG><BR>
<DD>
the radius of the pixel neighborhood.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="embossimage">EmbossImage</A></H2>
<blockquote>EmbossImage() returns a grayscale image with a three-dimensional effect. We convolve the image with a Gaussian operator of the given radius and standard deviation ( sigma ) . For reasonable results, radius should be larger than sigma. Use a radius of 0 and Emboss ( ) selects a suitable radius for you. </blockquote><P>The format of the EmbossImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *EmbossImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o radius:</STRONG><BR>
<DD>
the radius of the pixel neighborhood.
<P></P>
<DT><STRONG>o sigma:</STRONG><BR>
<DD>
The standard deviation of the Gaussian, in pixels.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="enhanceimage">EnhanceImage</A></H2>
<blockquote>EnhanceImage() applies a digital filter that improves the quality of a noisy image. </blockquote><P>The format of the EnhanceImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *EnhanceImage ( const <A HREF="types/Image.html">Image</A> *image, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="gaussianblurimage">GaussianBlurImage</A></H2>
<blockquote>GaussianBlurImage() blurs an image. We convolve the image with a Gaussian operator of the given radius and standard deviation ( sigma ) . For reasonable results, the radius should be larger than sigma. Use a radius of 0 and GaussianBlurImage ( ) selects a suitable radius for you </blockquote><P>The format of the BlurImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *GaussianBlurImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG><A NAME="item_o_blur_image%3A">o blur_image:</A></STRONG><BR>
<DD>
Method GaussianBlurImage returns a pointer to the image after it is blur.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<DT><STRONG>o radius:</STRONG><BR>
<DD>
the radius of the Gaussian, in pixels, not counting the center pixel.
<P></P>
<DT><STRONG>o sigma:</STRONG><BR>
<DD>
the standard deviation of the Gaussian, in pixels.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="implodeimage">ImplodeImage</A></H2>
<P>Method ImplodeImage creates a new image that is a copy of an existing one with the image pixels ``implode'' by the specified percentage.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the ImplodeImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ImplodeImage ( const <A HREF="types/Image.html">Image</A> *image, const double amount, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG><A NAME="item_o_implode_image%3A">o implode_image:</A></STRONG><BR>
<DD>
Method ImplodeImage returns a pointer to the image after it is implode.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG><A NAME="item_o_amount%3A">o amount:</A></STRONG><BR>
<DD>
Define the extent of the implosion.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="medianfilterimage">MedianFilterImage</A></H2>
<blockquote>MedianFilterImage() applies a digital filter that improves the quality of a noisy image. Each pixel is replaced by the median in a set of neighboring pixels as defined by radius. </blockquote><P>The algorithm was contributed by Mike Edmonds and implements an insertion sort for selecting median color-channel values.  For more on this algorithm see ``Skip Lists: 
<FONT SIZE=-1>A</FONT> probabilistic Alternative to Balanced Trees'' by William Pugh in the June 1990 of Communications of the 
<FONT SIZE=-1>ACM.</FONT></P>
<P>The format of the MedianFilterImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *MedianFilterImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o radius:</STRONG><BR>
<DD>
The radius of the pixel neighborhood.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="morphimages">MorphImages</A></H2>
<blockquote>The MorphImages() method requires a minimum of two images. The first image is transformed into the second by a number of intervening images as specified by frames. </blockquote><P>The format of the MorphImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *MorphImages ( const <A HREF="types/Image.html">Image</A> *image, const unsigned long number_frames, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG><A NAME="item_o_number_frames%3A">o number_frames:</A></STRONG><BR>
<DD>
Define the number of in-between image to generate.  The more in-between frames, the smoother the morph.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="motionblurimage">MotionBlurImage</A></H2>
<blockquote>MotionBlurImage() simulates motion blur. We convolve the image with a Gaussian operator of the given radius and standard deviation ( sigma ) . For reasonable results, radius should be larger than sigma. Use a radius of 0 and MotionBlurImage ( ) selects a suitable radius for you. Angle gives the angle of the blurring motion. </blockquote><P>Andrew Protano contributed this effect.</P>
<P>The format of the MotionBlurImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *MotionBlurImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, const double amount, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o radius:</STRONG><BR>
<DD>
The radius of the Gaussian, in pixels, not counting the center pixel.
<P></P>
<DT><STRONG>o sigma:</STRONG><BR>
<DD>
The standard deviation of the Gaussian, in pixels.
<P></P>
<DT><STRONG><A NAME="item_o_angle%3A">o angle:</A></STRONG><BR>
<DD>
Apply the effect along this angle.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="oilpaintimage">OilPaintImage</A></H2>
<blockquote>OilPaintImage() applies a special effect filter that simulates an oil painting. Each pixel is replaced by the most frequent color occurring in a circular region defined by radius. </blockquote><P>The format of the OilPaintImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *OilPaintImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o radius:</STRONG><BR>
<DD>
The radius of the circular neighborhood.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="plasmaimage">PlasmaImage</A></H2>
<blockquote>PlasmaImage() initializes an image with plasma fractal values. The image must be initialized with a base color and the random number generator seeded before this method is called. </blockquote><P>The format of the PlasmaImage method is:</P>
<blockquote>unsigned int PlasmaImage ( <A HREF="types/Image.html">Image</A> *image, const SegmentInfo *segment, int attenuate, int depth ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG><A NAME="item_o_segment%3A">o segment:</A></STRONG><BR>
<DD>
Define the region to apply plasma fractals values.
<P></P>
<DT><STRONG><A NAME="item_o_attenuate%3A">o attenuate:</A></STRONG><BR>
<DD>
Define the plasma attenuation factor.
<P></P>
<DT><STRONG><A NAME="item_o_depth%3A">o depth:</A></STRONG><BR>
<DD>
Limit the plasma recursion depth.
<P></P></DL>
<P>
<H2><A NAME="reducenoiseimage">ReduceNoiseImage</A></H2>
<blockquote>ReduceNoiseImage() smooths the contours of an image while still preserving edge information. The algorithm works by replacing each pixel with its neighbor closest in value. A neighbor is defined by radius. Use a radius of 0 and ReduceNoise ( ) selects a suitable radius for you. </blockquote><P>The format of the ReduceNoiseImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ReduceNoiseImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o radius:</STRONG><BR>
<DD>
The radius of the pixel neighborhood.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="shadeimage">ShadeImage</A></H2>
<blockquote>ShadeImage() shines a distant light on an image to create a three-dimensional effect. You control the positioning of the light with azimuth and elevation; azimuth is measured in degrees off the x axis and elevation is measured in pixels above the Z axis. </blockquote><P>The format of the ShadeImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ShadeImage ( const <A HREF="types/Image.html">Image</A> *image, const unsigned int color_shading, double azimuth, double elevation, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG><A NAME="item_o_color_shading%3A">o color_shading:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> value other than zero shades the red, green, and blue components of the image.
<P></P>
<DT><STRONG><A NAME="item_o_azimuth%2C_elevation%3A">o azimuth, elevation:</A></STRONG><BR>
<DD>
Define the light source direction.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="sharpenimage">SharpenImage</A></H2>
<blockquote>SharpenImage() sharpens an image. We convolve the image with a Gaussian operator of the given radius and standard deviation ( sigma ) . For reasonable results, radius should be larger than sigma. Use a radius of 0 and SharpenImage ( ) selects a suitable radius for you. </blockquote><P>The format of the SharpenImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *SharpenImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o radius:</STRONG><BR>
<DD>
The radius of the Gaussian, in pixels, not counting the center pixel.
<P></P>
<DT><STRONG>o sigma:</STRONG><BR>
<DD>
The standard deviation of the Laplacian, in pixels.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="solarizeimage">SolarizeImage</A></H2>
<blockquote>SolarizeImage() applies a special effect to the image, similar to the effect achieved in a photo darkroom by selectively exposing areas of photo sensitive paper to light. Threshold ranges from 0 to MaxRGB and is a measure of the extent of the solarization. </blockquote><P>The format of the SolarizeImage method is:</P>
<blockquote>void SolarizeImage ( <A HREF="types/Image.html">Image</A> *image, const double threshold ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG><A NAME="item_o_threshold%3A">o threshold:</A></STRONG><BR>
<DD>
Define the extent of the solarization.
<P></P></DL>
<P>
<H2><A NAME="spreadimage">SpreadImage</A></H2>
<blockquote>SpreadImage() is a special effects method that randomly displaces each pixel in a block defined by the amount parameter. </blockquote><P>The format of the SpreadImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *SpreadImage ( const <A HREF="types/Image.html">Image</A> *image, const unsigned int radius, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o radius:</STRONG><BR>
<DD>
Choose a random pixel in a neighborhood of this extent.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="steganoimage">SteganoImage</A></H2>
<blockquote>Use SteganoImage() to hide a digital watermark within the image. Recover the hidden watermark later to prove that the authenticity of an image. Offset defines the start position within the image to hide the watermark. </blockquote><P>The format of the SteganoImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *SteganoImage ( const <A HREF="types/Image.html">Image</A> *image, <A HREF="types/Image.html">Image</A> *watermark, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG><A NAME="item_o_watermark%3A">o watermark:</A></STRONG><BR>
<DD>
The watermark image.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="stereoimage">StereoImage</A></H2>
<blockquote>StereoImage() combines two images and produces a single image that is the composite of a left and right image of a stereo pair. Special red-green stereo glasses are required to view this effect. </blockquote><P>The format of the StereoImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *StereoImage ( const <A HREF="types/Image.html">Image</A> *image, const <A HREF="types/Image.html">Image</A> *offset_image, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG><A NAME="item_o_stereo_image%3A">o stereo_image:</A></STRONG><BR>
<DD>
Method StereoImage returns a pointer to the stereo image.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG><A NAME="item_o_offset_image%3A">o offset_image:</A></STRONG><BR>
<DD>
Another image.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="swirlimage">SwirlImage</A></H2>
<blockquote>SwirlImage() swirls the pixels about the center of the image, where degrees indicates the sweep of the arc through which each pixel is moved. You get a more dramatic effect as the degrees move from 1 to 360. </blockquote><P>The format of the SwirlImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *SwirlImage ( const <A HREF="types/Image.html">Image</A> *image, double degrees, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG><A NAME="item_o_degrees%3A">o degrees:</A></STRONG><BR>
<DD>
Define the tightness of the swirling effect.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="thresholdimage">ThresholdImage</A></H2>
<blockquote>ThresholdImage() changes the value of individual pixels based on the intensity of each pixel compared to threshold. The result is a high-contrast, two color image. </blockquote><P>The format of the ThresholdImage method is:</P>
<blockquote>unsigned int ThresholdImage ( <A HREF="types/Image.html">Image</A> *image, const double threshold ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o threshold:</STRONG><BR>
<DD>
Define the threshold value
<P></P></DL>
<P>
<H2><A NAME="unsharpmaskimage">UnsharpMaskImage</A></H2>
<blockquote>UnsharpMaskImage() sharpens an image. We convolve the image with a Gaussian operatorof the given radius and standard deviation ( sigma ) . For reasonable results, radius should be larger than sigma. Use a radius of 0 and UnsharpMaskImage ( ) selects a suitable radius for you. </blockquote><P>The format of the UnsharpMaskImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *UnsharpMaskImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, const double amount, const double threshold, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG>o radius:</STRONG><BR>
<DD>
The radius of the Gaussian, in pixels, not counting the center pixel.
<P></P>
<DT><STRONG>o sigma:</STRONG><BR>
<DD>
The standard deviation of the Gaussian, in pixels.
<P></P>
<DT><STRONG>o amount:</STRONG><BR>
<DD>
The percentage of the difference between the original and the blur image that is added back into the original.
<P></P>
<DT><STRONG>o threshold:</STRONG><BR>
<DD>
The threshold in pixels needed to apply the diffence amount.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL>
<P>
<H2><A NAME="waveimage">WaveImage</A></H2>
<blockquote>The WaveImage() filter creates a "ripple" effect in the image by shifting the pixels vertically along a sine wave whose amplitude and wavelength is specified by the given parameters. </blockquote><P>The format of the WaveImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *WaveImage ( const <A HREF="types/Image.html">Image</A> *image, const double amplitude, const double wave_length, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL>
<DT><STRONG>o image:</STRONG><BR>
<DD>
The image.
<P></P>
<DT><STRONG><A NAME="item_o_amplitude%2C_frequency%3A">o amplitude, frequency:</A></STRONG><BR>
<DD>
Define the amplitude and wave_length of the sine wave.
<P></P>
<DT><STRONG>o exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
</DL>

</BODY>

</HTML>
