<HTML>
<HEAD>
<TITLE>NAME</TITLE>
<LINK REV="made" HREF="mailto:magick@wizards.dupont.com">
</HEAD>

<body background="../../images/background.gif">

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#FUNCTION_DESCRIPTIONS">FUNCTION DESCRIPTIONS</A>
	<UL>

		<LI><A HREF="#BlobToImage">BlobToImage</A>
		<LI><A HREF="#CloseBlob">CloseBlob</A>
		<LI><A HREF="#EOFBlob">EOFBlob</A>
		<LI><A HREF="#FlushBlob">FlushBlob</A>
		<LI><A HREF="#GetBlobInfo">GetBlobInfo</A>
		<LI><A HREF="#GetStringBlob">GetStringBlob</A>
		<LI><A HREF="#ImageToBlob">ImageToBlob</A>
		<LI><A HREF="#OpenBlob">OpenBlob</A>
		<LI><A HREF="#ReadBlob">ReadBlob</A>
		<LI><A HREF="#SeekBlob">SeekBlob</A>
		<LI><A HREF="#TellBlob">TellBlob</A>
		<LI><A HREF="#WriteBlob">WriteBlob</A>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
blob - 

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
Image * <STRONG>BlobToImage</STRONG>( const ImageInfo *image_info, const char *blob, const unsigned long length
);

<P>
void  <STRONG>CloseBlob</STRONG>( Image <CODE>*image</CODE> );

<P>
int  <STRONG>EOFBlob</STRONG>( const Image <CODE>*image</CODE> );

<P>
int  <STRONG>FlushBlob</STRONG>( const Image <CODE>*image</CODE> );

<P>
void  <STRONG>GetBlobInfo</STRONG>( BlobInfo <CODE>*blob_info</CODE> );

<P>
char * <STRONG>GetStringBlob</STRONG>( Image *image, char <CODE>*string</CODE> );

<P>
char * <STRONG>ImageToBlob</STRONG>( const ImageInfo *image_info, Image *image, unsigned long
<CODE>*length</CODE> );

<P>
unsigned int  <STRONG>OpenBlob</STRONG>( const ImageInfo *image_info, Image *image, const char <CODE>*type</CODE>
);

<P>
unsigned long  <STRONG>ReadBlob</STRONG>( Image *image, const unsigned long number_bytes, char <CODE>*data</CODE>
);

<P>
int  <STRONG>SeekBlob</STRONG>( Image *image, const long offset, const int whence );

<P>
void  <STRONG>SetBlobQuantum</STRONG>( BlobInfo *blob_info, const unsigned long quantum );

<P>
int  <STRONG>TellBlob</STRONG>( const Image <CODE>*image</CODE> );

<P>
unsigned long  <STRONG>WriteBlob</STRONG>( Image *image, const unsigned long number_bytes, const char
<CODE>*data</CODE> );

<P>
<HR>
<H1><A NAME="FUNCTION_DESCRIPTIONS">FUNCTION DESCRIPTIONS</A></H1>
<P>
<HR>
<H2><A NAME="BlobToImage">BlobToImage</A></H2>
<P>
Method BlobToImage implements direct to memory image formats. It returns
the blob as an image.

<P>
The format of the BlobToImage method is:

<blockquote><A HREF="types/Image.html">Image</A> *BlobToImage ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, const char *blob, const unsigned long length ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG><A NAME="item_o">image:</A></STRONG><DD>
<P>
Method BlobToImage returns an image from the supplied blob. If an error occurs 
<FONT SIZE=-1>NULL</FONT> is returned.


<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<DT><STRONG>blob:</STRONG><DD>
<P>
The address of a character stream in one of the image formats understood by
ImageMagick.

<DT><STRONG>length:</STRONG><DD>
<P>
This unsigned integer reflects the length in bytes of the blob.

</DL></DL>
<P>
<HR>
<H2><A NAME="CloseBlob">CloseBlob</A></H2>
<P>
Method CloseBlob closes a file associated with the image. If the filename
prefix is '|', the file is a pipe and is closed with PipeClose.

<P>
The format of the CloseBlob method is:

<blockquote>void CloseBlob ( <A HREF="types/Image.html">Image</A> *image ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="EOFBlob">EOFBlob</A></H2>
<P>
Method EOFBlob returns a non-zero value when 
<FONT SIZE=-1>EOF</FONT> has been detected reading from a blob or file.

<P>
The format of the EOFBlob method is:

<blockquote>int EOFBlob ( const <A HREF="types/Image.html">Image</A> *image ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method EOFBlob returns 0 on success; otherwise, it returns -1 and set errno
to indicate the error.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="FlushBlob">FlushBlob</A></H2>
<P>
Method FlushBlob flushes the datastream if it is a file.

<P>
The format of the FlushBlob method is:

<blockquote>int FlushBlob ( const <A HREF="types/Image.html">Image</A> *image ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method FlushBlob returns 0 on success; otherwise, it returns -1 and set
errno to indicate the error.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetBlobInfo">GetBlobInfo</A></H2>
<P>
Method GetBlobInfo initializes the BlobInfo structure.

<P>
The format of the GetBlobInfo method is:

<blockquote>void GetBlobInfo ( BlobInfo *blob_info ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>blob_info:</STRONG><DD>
<P>
Specifies a pointer to a BlobInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetStringBlob">GetStringBlob</A></H2>
<P>
Method GetStringBlob reads characters from a blob or file until a newline
character is read or an end-of-file condition is encountered. from a blob
or file.

<P>
The format of the GetStringBlob method is:

<blockquote>char *GetStringBlob ( <A HREF="types/Image.html">Image</A> *image, char *string ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method GetStringBlob returns the string on success, otherwise, a null is
returned.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>string:</STRONG><DD>
<P>
The address of a character buffer.

</DL></DL>
<P>
<HR>
<H2><A NAME="ImageToBlob">ImageToBlob</A></H2>
<P>
Method ImageToBlob implements direct to memory image formats. It returns
the image as a blob and its length.

<P>
The format of the ImageToBlob method is:

<blockquote>char *ImageToBlob ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, <A HREF="types/Image.html">Image</A> *image, unsigned long *length ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>blob:</STRONG><DD>
<P>
Method ImageToBlob returns a chunk of memory written in the desired image format (e.g. 
<FONT SIZE=-1>JPEG,</FONT> 
<FONT SIZE=-1>GIF,</FONT> etc.). If an error occurs 
<FONT SIZE=-1>NULL</FONT> is returned.


<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>length:</STRONG><DD>
<P>
This pointer to an unsigned int sets the initial length of the blob. On
return, it reflects the actual length of the blob.

</DL></DL>
<P>
<HR>
<H2><A NAME="OpenBlob">OpenBlob</A></H2>
<P>
Method OpenBlob open a file associated with the image. 
<FONT SIZE=-1>A</FONT> file name of '-' sets the file to stdin for type 'r' and stdout for type 'w'. If the filename suffix is '.gz' or 
<FONT SIZE=-1>'.Z',</FONT> the image is decompressed for type 'r' and compressed for type 'w'. If the filename prefix is '|', it is piped to or from a system command.


<P>
The format of the OpenBlob method is:

<blockquote>unsigned int OpenBlob ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, <A HREF="types/Image.html">Image</A> *image, const char *type ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method OpenBlob returns True if the file is successfully opened otherwise
False.

<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>type:</STRONG><DD>
<P>
'r' for reading; 'w' for writing.

</DL></DL>
<P>
<HR>
<H2><A NAME="ReadBlob">ReadBlob</A></H2>
<P>
Method ReadBlob reads data from the blob or image file and returns it. It
returns the number of bytes read.

<P>
The format of the ReadBlob method is:

<blockquote>unsigned long ReadBlob ( <A HREF="types/Image.html">Image</A> *image, const unsigned long number_bytes, char *data ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>count:</STRONG><DD>
<P>
Method ReadBlob returns the number of items read.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>number_bytes:</STRONG><DD>
<P>
Specifies an integer representing the number of bytes to read from the
file.

<DT><STRONG>data:</STRONG><DD>
<P>
Specifies an area to place the information requested from the file.

</DL></DL>
<P>
<HR>
<H2><A NAME="SeekBlob">SeekBlob</A></H2>
<P>
Method SeekBlob sets the offset in bytes from the beginning of a blob or
file.

<P>
The format of the SeekBlob method is:

<blockquote>int SeekBlob ( <A HREF="types/Image.html">Image</A> *image, const long offset, const int whence ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method SeekBlob returns 0 on success; otherwise, it returned -1 and set
errno to indicate the error.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>offset:</STRONG><DD>
<P>
Specifies an integer representing the offset in bytes.

<DT><STRONG>whence:</STRONG><DD>
<P>
Specifies an integer representing how the offset is treated relative to the
beginning of the blob as follows:

</DL></DL>
<P>
<PRE>      SEEK_SET  Set position equal to offset bytes.
      SEEK_CUR  Set position to current location plus offset.
      SEEK_END  Set position to EOF plus offset.
=head2 SetBlobQuantum
</PRE>
<P>
Method SetBlobQuantum set the current value of the blob quantum. This is
the size in bytes to add to a blob when writing to a blob exceeds its
current length.

<P>
The format of the SetBlobQuantum method is:

<blockquote>void SetBlobQuantum ( BlobInfo *blob_info, const unsigned long quantum ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>blob_info:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to a BlobInfo structure.

<DT><STRONG>quantum:</STRONG><DD>
<P>
An unsigned long that reflects the number of bytes to increase a blob.

</DL></DL>
<P>
<HR>
<H2><A NAME="TellBlob">TellBlob</A></H2>
<P>
Method TellBlob obtains the current value of the blob or file position.

<P>
The format of the TellBlob method is:

<blockquote>int TellBlob ( const <A HREF="types/Image.html">Image</A> *image ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method TellBlob returns 0 on success; otherwise, it returned -1 and set
errno to indicate the error.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="WriteBlob">WriteBlob</A></H2>
<P>
Method WriteBlob writes data to a blob or image file. It returns the number
of items written.

<P>
The format of the WriteBlob method is:

<blockquote>unsigned long WriteBlob ( <A HREF="types/Image.html">Image</A> *image, const unsigned long number_bytes, const char *data ) ; </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method WriteBlob returns True if all the data requested is obtained without
error, otherwise False.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>size:</STRONG><DD>
<P>
Specifies an integer representing the length of an individual item to be
written to the file.

<DT><STRONG>number_items:</STRONG><DD>
<P>
Specifies an integer representing the number of items to write to the file.

<DT><STRONG>data:</STRONG><DD>
<P>
The address of the data to write to the blob or file.

</DL></DL>
</BODY>

</HTML>
