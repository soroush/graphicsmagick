<HTML>
<HEAD>
<TITLE>utility - ImageMagick Utility Methods</TITLE>
<LINK REV="made" HREF="mailto:magick@wizards.dupont.com">
</HEAD>

<body background="../../images/background.gif">

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#FUNCTION_DESCRIPTIONS">FUNCTION DESCRIPTIONS</A>
	<UL>

		<LI><A HREF="#AllocateString">AllocateString</A>
		<LI><A HREF="#AppendImageFormat">AppendImageFormat</A>
		<LI><A HREF="#BaseFilename">BaseFilename</A>
		<LI><A HREF="#CloneString">CloneString</A>
		<LI><A HREF="#ConvertTextToUnicode">ConvertTextToUnicode</A>
		<LI><A HREF="#ExpandFilename">ExpandFilename</A>
		<LI><A HREF="#ExpandFilenames">ExpandFilenames</A>
		<LI><A HREF="#FormatString">FormatString</A>
		<LI><A HREF="#GetGeometry">GetGeometry</A>
		<LI><A HREF="#GlobExpression">GlobExpression</A>
		<LI><A HREF="#IsAccessible">IsAccessible</A>
		<LI><A HREF="#IsDirectory">IsDirectory</A>
		<LI><A HREF="#Latin1Compare">Latin1Compare</A>
		<LI><A HREF="#ListColors">ListColors</A>
		<LI><A HREF="#ListFiles">ListFiles</A>
		<LI><A HREF="#LocaleFilename">LocaleFilename</A>
		<LI><A HREF="#LSBFirstReadLong">LSBFirstReadLong</A>
		<LI><A HREF="#LSBFirstReadShort">LSBFirstReadShort</A>
		<LI><A HREF="#LSBFirstWriteLong">LSBFirstWriteLong</A>
		<LI><A HREF="#LSBFirstWriteShort">LSBFirstWriteShort</A>
		<LI><A HREF="#MSBFirstOrderLong">MSBFirstOrderLong</A>
		<LI><A HREF="#MSBFirstOrderShort">MSBFirstOrderShort</A>
		<LI><A HREF="#MSBFirstReadShort">MSBFirstReadShort</A>
		<LI><A HREF="#MSBFirstReadLong">MSBFirstReadLong</A>
		<LI><A HREF="#MSBFirstWriteLong">MSBFirstWriteLong</A>
		<LI><A HREF="#MSBFirstWriteShort">MSBFirstWriteShort</A>
		<LI><A HREF="#MultilineCensus">MultilineCensus</A>
		<LI><A HREF="#ParseGeometry">ParseGeometry</A>
		<LI><A HREF="#PostscriptGeometry">PostscriptGeometry</A>
		<LI><A HREF="#ReadByte">ReadByte</A>
		<LI><A HREF="#ReadDataBlock">ReadDataBlock</A>
		<LI><A HREF="#SetClientName">SetClientName</A>
		<LI><A HREF="#StringToArgv">StringToArgv</A>
		<LI><A HREF="#StringToList">StringToList</A>
		<LI><A HREF="#Strip">Strip</A>
		<LI><A HREF="#SystemCommand">SystemCommand</A>
		<LI><A HREF="#TemporaryFilename">TemporaryFilename</A>
		<LI><A HREF="#TranslateText">TranslateText</A>
		<LI><A HREF="#WriteByte">WriteByte</A>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
utility - ImageMagick Utility Methods

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
char* <STRONG>AllocateString</STRONG>(constchar*source)

<P>
void <STRONG>AppendImageFormat</STRONG>(constchar*format,char*filename)

<P>
<PRE> B&lt;BaseFilename&gt;(name)
</PRE>
<P>
unsigned int <STRONG>CloneString</STRONG>(char**destination,constchar*source)

<P>
unicode= <STRONG>ConvertTextToUnicode</STRONG>(text,count)

<P>
<PRE> B&lt;ExpandFilename&gt;(filename)
</PRE>
<P>
status= <STRONG>ExpandFilenames</STRONG>(argc,argv)

<P>
void <STRONG>FormatString</STRONG>(char*string,constchar*format,...)

<P>
<PRE> B&lt;GlobExpression&gt;(expression,pattern)
</PRE>
<P>
unsigned int <STRONG>IsAccessible</STRONG>(constchar*filename)

<P>
unsigned int <STRONG>IsDirectory</STRONG>(constchar*filename)

<P>
unsignedlong <STRONG>LSBFirstReadLong</STRONG>(Image*image)

<P>
unsignedshort <STRONG>LSBFirstReadShort</STRONG>(Image*image)

<P>
unsignedlong <STRONG>LSBFirstWriteLong</STRONG>(Image*image,constunsignedlongvalue)

<P>
unsignedlong <STRONG>LSBFirstWriteShort</STRONG>(Image*image,constunsignedshortvalue)

<P>
int <STRONG>Latin1Compare</STRONG>(constchar*p,constchar*q)

<P>
filelist= <STRONG>ListColors</STRONG>(pattern,number_colors)

<P>
filelist= <STRONG>ListFiles</STRONG>(directory,pattern,number_entries)

<P>
void <STRONG>LocaleFilename</STRONG>(char*filename)

<P>
void <STRONG>MSBFirstOrderLong</STRONG>(registerchar*p,constunsigned intlength)

<P>
void <STRONG>MSBFirstOrderShort</STRONG>(registerchar*p,constunsigned intlength)

<P>
unsignedlong <STRONG>MSBFirstReadLong</STRONG>(Image*image)

<P>
unsignedshort <STRONG>MSBFirstReadShort</STRONG>(Image*image)

<P>
unsignedlong <STRONG>MSBFirstWriteLong</STRONG>(Image*image,constunsignedlongvalue)

<P>
unsignedlong <STRONG>MSBFirstWriteShort</STRONG>(Image*image,constunsignedshortvalue)

<P>
int <STRONG>MultilineCensus</STRONG>(constchar*label)

<P>
voidDestroy <STRONG>PostscriptGeometry</STRONG>(char*geometry)

<P>
int <STRONG>ReadByte</STRONG>(Image*image)

<P>
char* <STRONG>SetClientName</STRONG>(constchar*name)

<P>
char** <STRONG>StringToArgv</STRONG>(constchar*text,int*argc)

<P>
char** <STRONG>StringToList</STRONG>(constchar*text)

<P>
void <STRONG>Strip</STRONG>(char*data)

<P>
int <STRONG>SystemCommand</STRONG>(constunsigned intverbose,constchar*command)

<P>
void <STRONG>TemporaryFilename</STRONG>(char*filename)

<P>
unsignedlong <STRONG>WriteByte</STRONG>(Image*image,constcharvalue)

<P>
<HR>
<H1><A NAME="FUNCTION_DESCRIPTIONS">FUNCTION DESCRIPTIONS</A></H1>
<P>
<HR>
<H2><A NAME="AllocateString">AllocateString</A></H2>
<P>
Method AllocateString allocates memory for a string and copies the source
string to that memory location (and returns it).

<P>
The format of the AllocateString method is:

<P>
<PRE>        char *AllocateString(const char *source)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG><A NAME="item_o">allocated_string:</A></STRONG><DD>
<P>
Method AllocateString returns a copy of the source string.

<DT><STRONG>source:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> character string.

</DL></DL>
<P>
<HR>
<H2><A NAME="AppendImageFormat">AppendImageFormat</A></H2>
<P>
Method AppendImageFormat appends the image format type to the filename. If
an extension to the file already exists, it is first removed.

<P>
The format of the AppendImageFormat method is:

<P>
<PRE>        void AppendImageFormat(const char *format,char *filename)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>format:</STRONG><DD>
<P>
Specifies a pointer to an array of characters. This is the format of the
image.

<DT><STRONG>filename:</STRONG><DD>
<P>
Specifies a pointer to an array of characters. The unique file name is
returned in this array.

</DL></DL>
<P>
<HR>
<H2><A NAME="BaseFilename">BaseFilename</A></H2>
<P>
Method BaseFilename removes the path name component and any extensions.

<P>
The format of the BaseFilename function is:

<P>
<PRE>        BaseFilename(name)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>name:</STRONG><DD>
<P>
Specifies a pointer to a character array that contains the name.

</DL></DL>
<P>
<HR>
<H2><A NAME="CloneString">CloneString</A></H2>
<P>
Method CloneString allocates memory for the destination string and copies
the source string to that memory location.

<P>
The format of the (void) CloneString method is:

<P>
<PRE>        unsigned int CloneString(char **destination,const char *source)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method CloneString returns True is the string is cloned, otherwise False is
returned.

<DT><STRONG>destination:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to a character string.

<DT><STRONG>source:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> character string.

</DL></DL>
<P>
<HR>
<H2><A NAME="ConvertTextToUnicode">ConvertTextToUnicode</A></H2>
<P>
Method ConvertTextToUnicode converts an 
<FONT SIZE=-1>ASCII</FONT> text string to Unicode and returns the Unicode
translation and the character count. Normal characters are just copied.
However, escaped hex codes are interpreted before converting to Unicode
(e.g. \0x30a3 is 12451 in the Unicode character set).

<P>
The format of the ConvertTextToUnicode function is:

<P>
<PRE>        unicode=ConvertTextToUnicode(text,count)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>unicode:</STRONG><DD>
<P>
Method ConvertTextToUnicode returns a pointer to an unsigned short array representing the Unicode translation of the 
<FONT SIZE=-1>ASCII</FONT> string.


<DT><STRONG>text:</STRONG><DD>
<P>
Specifies a pointer to a character array that contains the text to convert.

<DT><STRONG>count:</STRONG><DD>
<P>
The number of characters that were translated from 
<FONT SIZE=-1>ASCII</FONT> to Unicode is returned in this unsigned integer
pointer.

</DL></DL>
<P>
<HR>
<H2><A NAME="ExpandFilename">ExpandFilename</A></H2>
<P>
Method ExpandFilename expands '~' in a filename.

<P>
The format of the ExpandFilename function is:

<P>
<PRE>        ExpandFilename(filename)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>filename:</STRONG><DD>
<P>
Specifies a pointer to a character array that contains the filename.

</DL></DL>
<P>
<HR>
<H2><A NAME="ExpandFilenames">ExpandFilenames</A></H2>
<P>
Method ExpandFilenames checks each argument of the command line vector and
expands it if they have a wildcard character. For example, *.jpg might
expand to: bird.jpg rose.jpg tiki.jpg.

<P>
The format of the ExpandFilenames function is:

<P>
<PRE>        status=ExpandFilenames(argc,argv)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>argc:</STRONG><DD>
<P>
Specifies a pointer to an integer describing the number of elements in the
argument vector.

<DT><STRONG>argv:</STRONG><DD>
<P>
Specifies a pointer to a text array containing the command line arguments.

</DL></DL>
<P>
<HR>
<H2><A NAME="FormatString">FormatString</A></H2>
<P>
Method FormatString prints formatted output of a variable argument list.

<P>
The format of the FormatString method is:

<P>
<PRE>        void FormatString(char *string,const char *format,...)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>string:</STRONG><DD>
<P>
Method FormatString returns the formatted string in this character buffer.

<DT><STRONG>format:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> string describing the format to use to write the
remaining arguments.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetGeometry">GetGeometry</A></H2>
<P>
Method GetGeometry parses a geometry specification and returns the width,
height, x, and y values. It also returns flags that indicates which of the
four values (width, height, xoffset, yoffset) were located in the string,
and whether the x and y values are negative. In addition,

<P>
The format of the GetGeometry method is:

<P>
<PRE>    int GetGeometry(const char *image_geometry,int *x,int *y,
      unsigned int *width,unsigned int *height)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>flags:</STRONG><DD>
<P>
Method GetGeometry returns a bitmask that indicates which of the four
values were located in the geometry string.

<DT><STRONG>image_geometry:</STRONG><DD>
<P>
Specifies a character string representing the geometry specification.

<DT><STRONG>x,y:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to an integer. The x and y offset as
determined by the geometry specification is returned here.

<DT><STRONG>width,height:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to an unsigned integer. The width and height
as determined by the geometry specification is returned here.

</DL></DL>
<P>
<HR>
<H2><A NAME="GlobExpression">GlobExpression</A></H2>
<P>
Method GlobExpression returns True if the expression matches the pattern.

<P>
The format of the GlobExpression function is:

<P>
<PRE>        GlobExpression(expression,pattern)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>expression:</STRONG><DD>
<P>
Specifies a pointer to a text string containing a file name.

<DT><STRONG>pattern:</STRONG><DD>
<P>
Specifies a pointer to a text string containing a pattern.

</DL></DL>
<P>
<HR>
<H2><A NAME="IsAccessible">IsAccessible</A></H2>
<P>
Method IsAccessible returns True if the file as defined by filename is
accessible.

<P>
The format of the IsAccessible method is:

<P>
<PRE>        unsigned int IsAccessible(const char *filename)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method IsAccessible returns True is the file as defined by filename is
accessible, otherwise False is returned.

<DT><STRONG>filename:</STRONG><DD>
<P>
Specifies a pointer to an array of characters. The unique file name is
returned in this array.

</DL></DL>
<P>
<HR>
<H2><A NAME="IsDirectory">IsDirectory</A></H2>
<P>
Method IsDirectory returns True if the file as defined by filename is a
directory. Once MetroWerks write a <CODE>stat(2)</CODE> function, we can
remove the <CODE>chdir(2)</CODE> function.

<P>
The format of the IsAccessible method is:

<P>
<PRE>        unsigned int IsDirectory(const char *filename)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method IsDirectory returns True is the file as defined by filename is a
directory, otherwise False is returned.

<DT><STRONG>filename:</STRONG><DD>
<P>
Specifies a pointer to an array of characters. The unique file name is
returned in this array.

</DL></DL>
<P>
<HR>
<H2><A NAME="Latin1Compare">Latin1Compare</A></H2>
<P>
Method Latin1Compare compares two null terminated Latin-1 strings, ignoring case differences, and returns an integer greater than, equal to, or less than 0, according to whether first is lexicographically greater than, equal to, or less than second. The two strings are assumed to be encoded using 
<FONT SIZE=-1>ISO</FONT> 8859-1.


<P>
The format of the Latin1Compare method is:

<P>
<PRE>        int Latin1Compare(const char *p,const char *q)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>p:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to the string to convert to Latin1 string.

<DT><STRONG>q:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to the string to convert to Latin1 string.

</DL></DL>
<P>
<HR>
<H2><A NAME="ListColors">ListColors</A></H2>
<P>
Method ListColors reads the 
<FONT SIZE=-1>X</FONT> client color database and returns a list of colors
contained in the database sorted in ascending alphabetic order.

<P>
The format of the ListColors function is:

<P>
<PRE>        filelist=ListColors(pattern,number_colors)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>filelist:</STRONG><DD>
<P>
Method ListColors returns a list of colors contained in the database. If the database cannot be read, a 
<FONT SIZE=-1>NULL</FONT> list is returned.


<DT><STRONG>pattern:</STRONG><DD>
<P>
Specifies a pointer to a text string containing a pattern.

<DT><STRONG>number_colors:</STRONG><DD>
<P>
This integer returns the number of colors in the list.

</DL></DL>
<P>
<HR>
<H2><A NAME="ListFiles">ListFiles</A></H2>
<P>
Method ListFiles reads the directory specified and returns a list of
filenames contained in the directory sorted in ascending alphabetic order.

<P>
The format of the ListFiles function is:

<P>
<PRE>        filelist=ListFiles(directory,pattern,number_entries)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>filelist:</STRONG><DD>
<P>
Method ListFiles returns a list of filenames contained in the directory. If the directory specified cannot be read or it is a file a 
<FONT SIZE=-1>NULL</FONT> list is returned.


<DT><STRONG>directory:</STRONG><DD>
<P>
Specifies a pointer to a text string containing a directory name.

<DT><STRONG>pattern:</STRONG><DD>
<P>
Specifies a pointer to a text string containing a pattern.

<DT><STRONG>number_entries:</STRONG><DD>
<P>
This integer returns the number of filenames in the list.

</DL></DL>
<P>
<HR>
<H2><A NAME="LocaleFilename">LocaleFilename</A></H2>
<P>
Method LocaleFilename replaces the contents of the string pointed to by
filename by a unique file name relative to the directory.

<P>
The format of the LocaleFilename method is:

<P>
<PRE>        void LocaleFilename(char *filename)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>filename:</STRONG><DD>
<P>
Specifies a pointer to an array of characters. The unique file name is
returned in this array.

</DL></DL>
<P>
<HR>
<H2><A NAME="LSBFirstReadLong">LSBFirstReadLong</A></H2>
<P>
Method LSBFirstReadLong reads a long value as a 32 bit quantity in
least-significant byte first order.

<P>
The format of the LSBFirstReadLong method is:

<P>
<PRE>        unsigned long LSBFirstReadLong(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>value:</STRONG><DD>
<P>
Method LSBFirstReadLong returns an unsigned long read from the file.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="LSBFirstReadShort">LSBFirstReadShort</A></H2>
<P>
Method LSBFirstReadShort reads a short value as a 16 bit quantity in
least-significant byte first order.

<P>
The format of the LSBFirstReadShort method is:

<P>
<PRE>        unsigned short LSBFirstReadShort(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>value:</STRONG><DD>
<P>
Method LSBFirstReadShort returns an unsigned short read from the file.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="LSBFirstWriteLong">LSBFirstWriteLong</A></H2>
<P>
Method LSBFirstWriteLong writes a long value as a 32 bit quantity in
least-significant byte first order.

<P>
The format of the LSBFirstWriteLong method is:

<P>
<PRE>        unsigned long LSBFirstWriteLong(Image *image,const unsigned long value)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>count:</STRONG><DD>
<P>
Method LSBFirstWriteLong returns the number of unsigned longs written.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>value:</STRONG><DD>
<P>
Specifies the value to write.

</DL></DL>
<P>
<HR>
<H2><A NAME="LSBFirstWriteShort">LSBFirstWriteShort</A></H2>
<P>
Method LSBFirstWriteShort writes a long value as a 16 bit quantity in
least-significant byte first order.

<P>
The format of the LSBFirstWriteShort method is:

<P>
<PRE>        unsigned long LSBFirstWriteShort(Image *image,const unsigned short value)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>count:</STRONG><DD>
<P>
Method LSBFirstWriteShort returns the number of unsigned longs written.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>value:</STRONG><DD>
<P>
Specifies the value to write.

</DL></DL>
<P>
<HR>
<H2><A NAME="MSBFirstOrderLong">MSBFirstOrderLong</A></H2>
<P>
Method MSBFirstOrderLong converts a least-significant byte first buffer of
integers to most-significant byte first.

<P>
The format of the MSBFirstOrderLong method is:

<P>
<PRE>        void MSBFirstOrderLong(register char *p,const unsigned int length)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>p:</STRONG><DD>
<P>
Specifies a pointer to a buffer of integers.

<DT><STRONG>length:</STRONG><DD>
<P>
Specifies the length of the buffer.

</DL></DL>
<P>
<HR>
<H2><A NAME="MSBFirstOrderShort">MSBFirstOrderShort</A></H2>
<P>
Method MSBFirstOrderShort converts a least-significant byte first buffer of
integers to most-significant byte first.

<P>
The format of the MSBFirstOrderShort method is:

<P>
<PRE>        void MSBFirstOrderShort(register char *p,const unsigned int length)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>p:</STRONG><DD>
<P>
Specifies a pointer to a buffer of integers.

<DT><STRONG>length:</STRONG><DD>
<P>
Specifies the length of the buffer.

</DL></DL>
<P>
<HR>
<H2><A NAME="MSBFirstReadShort">MSBFirstReadShort</A></H2>
<P>
Method MSBFirstReadShort reads a short value as a 16 bit quantity in
most-significant byte first order.

<P>
The format of the MSBFirstReadShort method is:

<P>
<PRE>        unsigned short MSBFirstReadShort(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>value:</STRONG><DD>
<P>
Method MSBFirstReadShort returns an unsigned short read from the file.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="MSBFirstReadLong">MSBFirstReadLong</A></H2>
<P>
Method MSBFirstReadLong reads a long value as a 32 bit quantity in
most-significant byte first order.

<P>
The format of the MSBFirstReadLong method is:

<P>
<PRE>        unsigned long MSBFirstReadLong(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>value:</STRONG><DD>
<P>
Method MSBFirstReadLong returns an unsigned long read from the file.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="MSBFirstWriteLong">MSBFirstWriteLong</A></H2>
<P>
Method MSBFirstWriteLong writes a long value as a 32 bit quantity in
most-significant byte first order.

<P>
The format of the MSBFirstWriteLong method is:

<P>
<PRE>        unsigned long MSBFirstWriteLong(Image *image,const unsigned long value)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>count:</STRONG><DD>
<P>
Method MSBFirstWriteLong returns the number of unsigned longs written.

<DT><STRONG>value:</STRONG><DD>
<P>
Specifies the value to write.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="MSBFirstWriteShort">MSBFirstWriteShort</A></H2>
<P>
Method MSBFirstWriteShort writes a long value as a 16 bit quantity in
most-significant byte first order.

<P>
The format of the MSBFirstWriteShort method is:

<P>
<PRE>        unsigned long MSBFirstWriteShort(Image *image,const unsigned short value)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>value:</STRONG><DD>
<P>
Specifies the value to write.

<DT><STRONG>file:</STRONG><DD>
<P>
Specifies the file to write the data to.

</DL></DL>
<P>
<HR>
<H2><A NAME="MultilineCensus">MultilineCensus</A></H2>
<P>
Method MultilineCensus returns the number of lines within a label. 
<FONT SIZE=-1>A</FONT> line is represented by a \n character.

<P>
The format of the MultilineCenus method is:

<P>
<PRE>        int MultilineCensus(const char *label)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>label:</STRONG><DD>
<P>
This character string is the label.

</DL></DL>
<P>
<HR>
<H2><A NAME="ParseGeometry">ParseGeometry</A></H2>
<P>
Method ParseImageGeometry parses a geometry specification and returns the
width, height, x, and y values. It also returns flags that indicates which
of the four values (width, height, xoffset, yoffset) were located in the
string, and whether the x and y values are negative. In addition,

<P>
The format of the ParseImageGeometry method is:

<P>
<PRE>    int ParseGeometry(const char *geometry,int *x,int *y,unsigned int *width,
      unsigned int *height)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>flags:</STRONG><DD>
<P>
Method ParseImageGeometry returns a bitmask that indicates which of the
four values were located in the geometry string.

<DT><STRONG>image_geometry:</STRONG><DD>
<P>
Specifies a character string representing the geometry specification.

<DT><STRONG>x,y:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to an integer. The x and y offset as
determined by the geometry specification is returned here.

<DT><STRONG>width,height:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to an unsigned integer. The width and height
as determined by the geometry specification is returned here.

</DL></DL>
<P>
<HR>
<H2><A NAME="PostscriptGeometry">PostscriptGeometry</A></H2>
<P>
Method PostscriptGeometry replaces any page mneumonic with the equivalent
size in picas.

<P>
The format of the PostscriptGeometry method is:

<P>
<PRE>        void DestroyPostscriptGeometry(char *geometry)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>page:</STRONG><DD>
<P>
Specifies a pointer to an array of characters. The string is either a Postscript page name (e.g. 
<FONT SIZE=-1>A4)</FONT> or a postscript page geometry (e.g. 612x792+36+36).


</DL></DL>
<P>
<HR>
<H2><A NAME="ReadByte">ReadByte</A></H2>
<P>
Method ReadByte reads a single byte from the image file and returns it.

<P>
The format of the ReadByte method is:

<P>
<PRE>        int ReadByte(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>value:</STRONG><DD>
<P>
Method ReadByte returns an integer read from the file.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="ReadDataBlock">ReadDataBlock</A></H2>
<P>
Method ReadBlobBlock reads data from the image file and returns it. The
amount of data is determined by first reading a count byte. The number or
bytes read is returned.

<P>
The format of the ReadBlobBlock method is:

<P>
<PRE>    unsigned long ReadBlobBlock(Image *image,char *data)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>count:</STRONG><DD>
<P>
Method ReadBlobBlock returns the number of bytes read.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>data:</STRONG><DD>
<P>
Specifies an area to place the information requested from the file.

</DL></DL>
<P>
<HR>
<H2><A NAME="SetClientName">SetClientName</A></H2>
<P>
Method SetClientName sets the client name if the name is specified.
Otherwise the current client name is returned.

<P>
The format of the SetClientName method is:

<P>
<PRE>        char *SetClientName(const char *name)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>client_name:</STRONG><DD>
<P>
Method SetClientName returns the current client name.

<DT><STRONG>status:</STRONG><DD>
<P>
Specifies the new client name.

</DL></DL>
<P>
<HR>
<H2><A NAME="StringToArgv">StringToArgv</A></H2>
<P>
Method StringToArgv converts a text string into command line arguments.

<P>
The format of the StringToArgv method is:

<P>
<PRE>        char **StringToArgv(const char *text,int *argc)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>argv:</STRONG><DD>
<P>
Method StringToArgv returns the string list unless an error occurs, otherwise 
<FONT SIZE=-1>NULL.</FONT>


<DT><STRONG>text:</STRONG><DD>
<P>
Specifies the string to segment into a list.

<DT><STRONG>argc:</STRONG><DD>
<P>
This integer pointer returns the number of arguments in the list.

</DL></DL>
<P>
<HR>
<H2><A NAME="StringToList">StringToList</A></H2>
<P>
Method StringToList converts a text string into a list by segmenting the text string at each carriage return discovered. The list is converted to 
<FONT SIZE=-1>HEX</FONT> characters if any control characters are discovered within the text string.


<P>
The format of the StringToList method is:

<P>
<PRE>        char **StringToList(const char *text)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>list:</STRONG><DD>
<P>
Method StringToList returns the string list unless an error occurs, otherwise 
<FONT SIZE=-1>NULL.</FONT>


<DT><STRONG>text:</STRONG><DD>
<P>
Specifies the string to segment into a list.

</DL></DL>
<P>
<HR>
<H2><A NAME="Strip">Strip</A></H2>
<P>
Method Strip strips the whitespace from the beginning and end of a string
of characters.

<P>
The format of the Strip method is:

<P>
<PRE>        void Strip(char *data)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>data:</STRONG><DD>
<P>
Specifies an array of characters.

</DL></DL>
<P>
<HR>
<H2><A NAME="SystemCommand">SystemCommand</A></H2>
<P>
Method SystemCommand executes the specified command and waits until it
terminates. The returned value is the exit status of the command.

<P>
The format of the SystemCommand method is:

<P>
<PRE>        int SystemCommand(const unsigned int verbose,const char *command)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method SystemCommand returns False if the command is executed successfully.

<DT><STRONG>verbose:</STRONG><DD>
<P>
An unsigned integer other than 0 prints the executed command before it is
invoked.

<DT><STRONG>command:</STRONG><DD>
<P>
This string is the command to execute.

</DL></DL>
<P>
<HR>
<H2><A NAME="TemporaryFilename">TemporaryFilename</A></H2>
<P>
Method TemporaryFilename replaces the contents of the string pointed to in
their filenames.

<P>
The format of the TemporaryFilename method is:

<P>
<PRE>        void TemporaryFilename(char *filename)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>filename:</STRONG><DD>
<P>
Specifies a pointer to an array of characters. The unique file name is
returned in this array.

</DL></DL>
<P>
<HR>
<H2><A NAME="TranslateText">TranslateText</A></H2>
<P>
Method TranslateText replaces any embedded formatting characters with the
appropriate image attribute and returns the translated text.

<P>
The format of the TranslateText method is:

<P>
<PRE>    char *TranslateText(const ImageInfo *image_info,const Image *image,
      const char *formatted_text)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<DT><STRONG>translated_text:</STRONG><DD>
<P>
Method TranslateText returns the translated text string.

<DT><STRONG>image_info:</STRONG><DD>
<P>
The address of a structure of type ImageInfo.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>formatted_text:</STRONG><DD>
<P>
The address of a character string containing the embedded formatting
characters.

</DL></DL>
<P>
<HR>
<H2><A NAME="WriteByte">WriteByte</A></H2>
<P>
Method WriteByte write an integer to a file. It returns the number of bytes
written (either 0 or 1);

<P>
The format of the WriteByte method is:

<P>
<PRE>        unsigned long WriteByte(Image *image,const char value)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows.

<DL><DL>
<DT><STRONG>count:</STRONG><DD>
<P>
Method WriteByte returns the number of bytes written.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>value:</STRONG><DD>
<P>
Specifies the value to write.

</DL></DL>
</BODY>

</HTML>
