<HTML>
<HEAD>
<TITLE>image - ImageMagick Image Methods</TITLE>
<LINK REV="made" HREF="mailto:magick@wizards.dupont.com">
</HEAD>

<body background="../../images/background.png">

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#FUNCTION_DESCRIPTIONS">FUNCTION DESCRIPTIONS</A>
	<UL>

		<LI><A HREF="#AnimateImages">AnimateImages</A>
		<LI><A HREF="#AppendImages">AppendImages</A>
		<LI><A HREF="#AverageImages">AverageImages</A>
		<LI><A HREF="#CloneImage">CloneImage</A>
		<LI><A HREF="#CloneImageInfo">CloneImageInfo</A>
		<LI><A HREF="#CommentImage">CommentImage</A>
		<LI><A HREF="#CompositeImage">CompositeImage</A>
		<LI><A HREF="#CreateImage">CreateImage</A>
		<LI><A HREF="#CycleColormapImage">CycleColormapImage</A>
		<LI><A HREF="#DescribeImage">DescribeImage</A>
		<LI><A HREF="#DestroyImage">DestroyImage</A>
		<LI><A HREF="#DestroyImageInfo">DestroyImageInfo</A>
		<LI><A HREF="#DestroyImages">DestroyImages</A>
		<LI><A HREF="#DisplayImages">DisplayImages</A>
		<LI><A HREF="#GetImageInfo">GetImageInfo</A>
		<LI><A HREF="#GetImageType">GetImageType</A>
		<LI><A HREF="#GetNextImage">GetNextImage</A>
		<LI><A HREF="#GetNumberScenes">GetNumberScenes</A>
		<LI><A HREF="#GetPageInfo">GetPageInfo</A>
		<LI><A HREF="#GetPixels">GetPixels</A>
		<LI><A HREF="#GetPixelPacket">GetPixelPacket</A>
		<LI><A HREF="#IsGeometry">IsGeometry</A>
		<LI><A HREF="#IsSubimage">IsSubimage</A>
		<LI><A HREF="#IsTainted">IsTainted</A>
		<LI><A HREF="#LabelImage">LabelImage</A>
		<LI><A HREF="#LayerImage">LayerImage</A>
		<LI><A HREF="#ListToGroupImage">ListToGroupImage</A>
		<LI><A HREF="#MatteImage">MatteImage</A>
		<LI><A HREF="#MogrifyImage">MogrifyImage</A>
		<LI><A HREF="#MogrifyImages">MogrifyImages</A>
		<LI><A HREF="#MosaicImages">MosaicImages</A>
		<LI><A HREF="#ParseImageGeometry">ParseImageGeometry</A>
		<LI><A HREF="#PingImage">PingImage</A>
		<LI><A HREF="#ReadImage">ReadImage</A>
		<LI><A HREF="#ReadImages">ReadImages</A>
		<LI><A HREF="#RGBTransformImage">RGBTransformImage</A>
		<LI><A HREF="#SetImage">SetImage</A>
		<LI><A HREF="#SetImageInfo">SetImageInfo</A>
		<LI><A HREF="#SortColormapByIntentsity">SortColormapByIntentsity</A>
		<LI><A HREF="#SyncImage">SyncImage</A>
		<LI><A HREF="#TextureImage">TextureImage</A>
		<LI><A HREF="#TransformRGBImage">TransformRGBImage</A>
		<LI><A HREF="#TransparentImage">TransparentImage</A>
		<LI><A HREF="#WriteImage">WriteImage</A>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
image - ImageMagick Image Methods

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
unsigned int  <STRONG>AnimateImages</STRONG>( const ImageInfo *image_info, Image <CODE>*image</CODE> );

<P>
Image * <STRONG>AppendImages</STRONG>( Image *images, const unsigned int stack );

<P>
Image * <STRONG>AverageImages</STRONG>( const Image <CODE>*images</CODE> );

<P>
Image * <STRONG>CloneImage</STRONG>( Image *image, const unsigned int columns, const unsigned int rows, const
unsigned int orphan );

<P>
ImageInfo * <STRONG>CloneImageInfo</STRONG>( const ImageInfo <CODE>*image_info</CODE> );

<P>
void  <STRONG>CommentImage</STRONG>( Image *image, const char <CODE>*comments</CODE> );

<P>
void  <STRONG>CompositeImage</STRONG>( Image *image, const CompositeOperator compose, Image *composite_image,
const int x_offset, const int y_offset );

<P>
Image * <STRONG>CreateImage</STRONG>( const unsigned int width, const unsigned int height, const char *map,
const StorageType type, const void <CODE>*pixels</CODE> );

<P>
<STRONG>CycleColormapImage</STRONG>( image, amount );

<P>
void  <STRONG>DescribeImage</STRONG>( Image *image, 
<FONT SIZE=-1>FILE</FONT> *file, const unsigned int verbose );

<P>
void  <STRONG>DestroyImage</STRONG>( Image <CODE>*image</CODE> );

<P>
void  <STRONG>DestroyImageInfo</STRONG>( ImageInfo <CODE>*image_info</CODE> );

<P>
void  <STRONG>DestroyImages</STRONG>( Image <CODE>*image</CODE> );

<P>
unsigned int  <STRONG>DisplayImages</STRONG>( const ImageInfo *image_info, Image <CODE>*image</CODE> );

<P>
void  <STRONG>GetImageInfo</STRONG>( ImageInfo <CODE>*image_info</CODE> );

<P>
ImageType  <STRONG>GetImageType</STRONG>( Image <CODE>*image</CODE> );

<P>
Image * <STRONG>GetNextImage</STRONG>( Image <CODE>*image</CODE> );

<P>
unsigned int  <STRONG>GetNumberScenes</STRONG>( const Image <CODE>*image</CODE> );

<P>
void  <STRONG>GetPageInfo</STRONG>( RectangleInfo <CODE>*page_info</CODE> );

<P>
void  <STRONG>GetPixelPacket</STRONG>( PixelPacket <CODE>*pixel</CODE> );

<P>
void  <STRONG>GetPixels</STRONG>( Image *image, const int x, const int y, const unsigned int columns, const
unsigned int rows, const char *map, const StorageType type, void
<CODE>*pixels</CODE> );

<P>
unsigned int  <STRONG>IsGeometry</STRONG>( const char <CODE>*geometry</CODE> );

<P>
unsigned int  <STRONG>IsSubimage</STRONG>( const char *geometry, const unsigned int pedantic );

<P>
unsigned int  <STRONG>IsTainted</STRONG>( const Image <CODE>*image</CODE> );

<P>
void  <STRONG>LabelImage</STRONG>( Image *image, const char <CODE>*label</CODE> );

<P>
void  <STRONG>LayerImage</STRONG>( Image *image, const LayerType layer );

<P>
Image **  <STRONG>ListToGroupImage</STRONG>( const Image *image, unsigned int <CODE>*number_images</CODE> );

<P>
void  <STRONG>MatteImage</STRONG>( Image *image, Quantum opacity );

<P>
void  <STRONG>MogrifyImage</STRONG>( const ImageInfo *image_info, const int argc, char ** argv, Image ** image
);

<P>
void  <STRONG>MogrifyImages</STRONG>( const ImageInfo *image_info, const int argc, char ** argv, Image **
images );

<P>
Image * <STRONG>MosaicImages</STRONG>( const Image <CODE>*images</CODE> );

<P>
int  <STRONG>ParseImageGeometry</STRONG>( const char *geometry, int *x, int *y, unsigned int *width, unsigned int
<CODE>*height</CODE> );

<P>
Image * <STRONG>PingImage</STRONG>( const ImageInfo <CODE>*image_info</CODE> );

<P>
void  <STRONG>RGBTransformImage</STRONG>( Image *image, const ColorspaceType colorspace );

<P>
Image * <STRONG>ReadImage</STRONG>( ImageInfo <CODE>*image_info</CODE> );

<P>
Image * <STRONG>ReadImages</STRONG>( ImageInfo <CODE>*image_info</CODE> );

<P>
void  <STRONG>SetImage</STRONG>( Image <CODE>*image</CODE> );

<P>
void  <STRONG>SetImageInfo</STRONG>( ImageInfo *image_info, const unsigned int rectify );

<P>
void  <STRONG>SyncImage</STRONG>( Image <CODE>*image</CODE> );

<P>
void  <STRONG>TextureImage</STRONG>( Image *image, Image <CODE>*texture</CODE> );

<P>
void  <STRONG>TransformRGBImage</STRONG>( Image *image, const ColorspaceType colorspace );

<P>
void  <STRONG>TransparentImage</STRONG>( Image *image, const char <CODE>*color</CODE> );

<P>
unsigned int  <STRONG>WriteImage</STRONG>( const ImageInfo *image_info, Image <CODE>*image</CODE> );

<P>
<HR>
<H1><A NAME="FUNCTION_DESCRIPTIONS">FUNCTION DESCRIPTIONS</A></H1>
<P>
<HR>
<H2><A NAME="AnimateImages">AnimateImages</A></H2>
<P>
Method AnimateImages displays one or more images to an 
<FONT SIZE=-1>X</FONT> window.

<P>
The format of the AnimateImages method is:

<blockquote>unsigned int AnimateImages ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, <A HREF="types/Image.html">Image</A> *image ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG><A NAME="item_o">status:</A></STRONG><DD>
<P>
Method AnimateImages returns True if the images are displayed in an 
<FONT SIZE=-1>X</FONT> window, otherwise False is returned.

<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="AppendImages">AppendImages</A></H2>
<P>
Method AppendImages appends a set of images. All the input images must have
the same width or height. Images of the same width are stacked
top-to-bottom. Images of the same height are stacked left-to-right. If
stack is false, rectangular images are stacked left-to-right otherwise
top-to-bottom.

<P>
The format of the AppendImage method is:

<blockquote><A HREF="types/Image.html">Image</A> *AppendImages ( <A HREF="types/Image.html">Image</A> *images, const unsigned int stack ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>stack:</STRONG><DD>
<P>
An unsigned value other than stacks rectangular images top-to-bottom
otherwise left-to-right.

</DL></DL>
<P>
<HR>
<H2><A NAME="AverageImages">AverageImages</A></H2>
<P>
Method AverageImages averages a set of images. All the input images must be
the same size in pixels.

<P>
The format of the AverageImage method is:

<blockquote><A HREF="types/Image.html">Image</A> *AverageImages ( const <A HREF="types/Image.html">Image</A> *images ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>averaged_image:</STRONG><DD>
<P>
Method AverageImages returns the mean pixel value for an image sequence.

<p><dt><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="CloneImage">CloneImage</A></H2>
<P>
Method CloneImage returns a copy of all fields of the input image. The
image pixels are copied only if the columns and rows of the cloned image
are the same as the original.

<P>
The format of the CloneImage method is:

<blockquote><A HREF="types/Image.html">Image</A> *CloneImage ( <A HREF="types/Image.html">Image</A> *image, const unsigned int columns, const unsigned int rows, const unsigned int orphan ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>clone_image:</STRONG><DD>
<P>
Method CloneImage returns a pointer to the image after copying. 
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory
shortage.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<p><dt><STRONG>columns:</STRONG><DD>
<P>
An integer that specifies the number of columns in the copied image.

<p><dt><STRONG>rows:</STRONG><DD>
<P>
An integer that specifies the number of rows in the copied image.

<p><dt><STRONG>orphan:</STRONG><DD>
<P>
if true, consider this image an orphan.

</DL></DL>
<P>
<HR>
<H2><A NAME="CloneImageInfo">CloneImageInfo</A></H2>
<P>
Method CloneImageInfo makes a duplicate of the given image info, or if image info is 
<FONT SIZE=-1>NULL,</FONT> a new one.


<P>
The format of the CloneImageInfo method is:

<blockquote><A HREF="types/ImageInfo.html">ImageInfo</A> *CloneImageInfo ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>clone_info:</STRONG><DD>
<P>
Method CloneImageInfo returns a duplicate of the given image info, or if image info is 
<FONT SIZE=-1>NULL</FONT> a new one.


<p><dt><STRONG>image_info:</STRONG><DD>
<P>
a structure of type info.

</DL></DL>
<P>
<HR>
<H2><A NAME="CommentImage">CommentImage</A></H2>
<P>
Method CommentImage initializes an image comment. Optionally the comment
can include the image filename, type, width, height, or scene number by
embedding special format characters.

<P>
The format of the CommentImage method is:

<blockquote>void CommentImage ( <A HREF="types/Image.html">Image</A> *image, const char *comments ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<p><dt><STRONG>comments:</STRONG><DD>
<P>
The address of a character string containing the comment format.

</DL></DL>
<P>
<HR>
<H2><A NAME="CompositeImage">CompositeImage</A></H2>
<P>
Method CompositeImage returns the second image composited onto the first at
the specified offsets.

<P>
The format of the CompositeImage method is:

<blockquote>void CompositeImage ( <A HREF="types/Image.html">Image</A> *image, const <A HREF="types/Enumerations.html#CompositeOperator">CompositeOperator</A> compose, <A HREF="types/Image.html">Image</A> *composite_image, const int x_offset, const int y_offset ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<p><dt><STRONG>compose:</STRONG><DD>
<P>
Specifies an image composite operator.

<p><dt><STRONG>composite_image:</STRONG><DD>
<P>
The address of a structure of type Image.

<p><dt><STRONG>x_offset:</STRONG><DD>
<P>
An integer that specifies the column offset of the composited image.

<p><dt><STRONG>y_offset:</STRONG><DD>
<P>
An integer that specifies the row offset of the composited image.

</DL></DL>
<P>
<HR>
<H2><A NAME="CreateImage">CreateImage</A></H2>
<P>
Method CreateImage is a convenience routine that creates an image from the
pixel data you supply and returns it. It allocates the memory necessary for
the new Image structure and returns a pointer to the new image. The pixel
data must be in scanline order top-to-bottom. The data can be character,
short int, integer, float, or double. Float and double require the pixels
to be normalized [0..1]. The other types are [0..MaxRGB]. For example, to
create a 640x480 image from unsigned red-green-blue character data, use

<blockquote>image=CreateImage ( 640, 480, "RGB", 0, pixels );; </blockquote>

<P>
The format of the CreateImage method is:

<blockquote><A HREF="types/Image.html">Image</A> *CreateImage ( const unsigned int width, const unsigned int height, const char *map, const StorageType type, const void *pixels ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
Method CreateImage returns a pointer to the image. 
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage
or if the image cannot be read.

<p><dt><STRONG>width:</STRONG><DD>
<P>
Specifies the width in pixels of the image.

<p><dt><STRONG>height:</STRONG><DD>
<P>
Specifies the height in pixels of the image.

<p><dt><STRONG>map:</STRONG><DD>
<P>
This character string can be any combination or order of 
<FONT SIZE=-1>R</FONT> = red, 
<FONT SIZE=-1>G</FONT> = green, 
<FONT SIZE=-1>B</FONT> = blue, 
<FONT SIZE=-1>A</FONT> = alpha, 
<FONT SIZE=-1>C</FONT> = cyan, 
<FONT SIZE=-1>Y</FONT> = yellow, 
<FONT SIZE=-1>M</FONT> = magenta, and 
<FONT SIZE=-1>K</FONT> = black. The ordering reflects the order of the pixels in the supplied pixel array.


<p><dt><STRONG>type:</STRONG><DD>
<P>
pixel type where 0 = unsigned char, 1 = short int, 2 = int, 3 = float, and
4 = double. Float and double types are expected to be normalized [0..1]
otherwise [0..MaxRGB].

<p><dt><STRONG>pixels:</STRONG><DD>
<P>
This array of values contain the pixel components as defined by the map and
type parameters. The length of the arrays must equal the area specified by
the width and height values and type parameters.

</DL></DL>
<P>
<HR>
<H2><A NAME="CycleColormapImage">CycleColormapImage</A></H2>
<P>
Method CycleColormapImage cycles the image colormap by a specified amount.

<P>
The format of the CycleColormapImage method is:

<blockquote>CycleColormapImage ( image, amount ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>amount:</STRONG><DD>
<P>
An unsigned value that specifies the offset of the colormap.

</DL></DL>
<P>
<HR>
<H2><A NAME="DescribeImage">DescribeImage</A></H2>
<P>
Method DescribeImage describes an image by printing its attributes to
stdout.

<P>
The format of the DescribeImage method is:

<blockquote>void DescribeImage ( <A HREF="types/Image.html">Image</A> *image, FILE *file, const unsigned int verbose ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<p><dt><STRONG>file:</STRONG><DD>
<P>
send the image attributes to this file.

<p><dt><STRONG>verbose:</STRONG><DD>
<P>
an unsigned value other than zero prints detailed information about the
image.

</DL></DL>
<P>
<HR>
<H2><A NAME="DestroyImage">DestroyImage</A></H2>
<P>
Method DestroyImage deallocates memory associated with an image.

<P>
The format of the DestroyImage method is:

<blockquote>void DestroyImage ( <A HREF="types/Image.html">Image</A> *image ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="DestroyImageInfo">DestroyImageInfo</A></H2>
<P>
Method DestroyImageInfo deallocates memory associated with an ImageInfo
structure.

<P>
The format of the DestroyImageInfo method is:

<blockquote>void DestroyImageInfo ( <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="DestroyImages">DestroyImages</A></H2>
<P>
Method DestroyImages deallocates memory associated with a linked list of
images.

<P>
The format of the DestroyImages method is:

<blockquote>void DestroyImages ( <A HREF="types/Image.html">Image</A> *image ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="DisplayImages">DisplayImages</A></H2>
<P>
Method DisplayImages displays one or more images to an 
<FONT SIZE=-1>X</FONT> window.

<P>
The format of the AllocateNextImage method is:

<blockquote>unsigned int DisplayImages ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, <A HREF="types/Image.html">Image</A> *image ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method DisplayImages returns True if the images are displayed in an 
<FONT SIZE=-1>X</FONT> window, otherwise False is returned.

<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetImageInfo">GetImageInfo</A></H2>
<P>
Method GetImageInfo initializes the ImageInfo structure.

<P>
The format of the GetImageInfo method is:

<blockquote>void GetImageInfo ( <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetImageType">GetImageType</A></H2>
<P>
Method GetImageType returns the type of image (e.g. bilevel, palette, etc).

<P>
The format of the GetImageType method is:

<blockquote><A HREF="types/Enumerations.html#ImageType">ImageType</A> GetImageType ( <A HREF="types/Image.html">Image</A> *image ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>type:</STRONG><DD>
<P>
Method GetImageType returns a ImageType enum that specifies the type of the
specified image (e.g. bilevel, palette, etc).

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetNextImage">GetNextImage</A></H2>
<P>
Method GetNextImage returns the next image in an image sequence.

<P>
The format of the GetNextImage method is:

<blockquote><A HREF="types/Image.html">Image</A> *GetNextImage ( <A HREF="types/Image.html">Image</A> *image ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>next:</STRONG><DD>
<P>
Method GetNextImage returns the next image in an image sequence.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetNumberScenes">GetNumberScenes</A></H2>
<P>
Method GetNumberScenes returns the number of scenes in an image sequence.

<P>
The format of the GetNumberScenes method is:

<blockquote>unsigned int GetNumberScenes ( const <A HREF="types/Image.html">Image</A> *image ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>scenes:</STRONG><DD>
<P>
Method GetNumberScenes returns the number of scenes in an image sequence.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetPageInfo">GetPageInfo</A></H2>
<P>
Method GetPageInfo initializes the image page structure.

<P>
The format of the GetPageInfo method is:

<blockquote>void GetPageInfo ( <A HREF="types/RectangleInfo.html">RectangleInfo</A> *page_info ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>page_info:</STRONG><DD>
<P>
Specifies a pointer to a RectangleInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetPixels">GetPixels</A></H2>
<P>
Method GetPixels is a convenience routine. Use it to extract pixel data
from an image and place it in a buffer you supply. The data is saved either
as char, short int, integer, float or double format in the order specified
by the type parameter. For example, we want to extract scanline 1 of a
640x480 image as character data in red-green-blue order:

<blockquote>GetPixels ( image, 0, 0, 640, 1, "RGB", 0, pixels );; </blockquote>

<P>
The format of the GetPixels method is:

<blockquote>void GetPixels ( <A HREF="types/Image.html">Image</A> *image, const int x, const int y, const unsigned int columns, const unsigned int rows, const char *map, const StorageType type, void *pixels ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
Specifies a pointer to a Image structure; returned from ReadImage.

<p><dt><STRONG>x,y,columns,rows:</STRONG><DD>
<P>
These values define the perimeter of a region of pixels you want to
extract.

<p><dt><STRONG>map:</STRONG><DD>
<P>
This character string can be any combination or order of 
<FONT SIZE=-1>R</FONT> = red, 
<FONT SIZE=-1>G</FONT> = green, 
<FONT SIZE=-1>B</FONT> = blue, 
<FONT SIZE=-1>A</FONT> = alpha, 
<FONT SIZE=-1>C</FONT> = cyan, 
<FONT SIZE=-1>Y</FONT> = yellow, 
<FONT SIZE=-1>M</FONT> = magenta, and 
<FONT SIZE=-1>K</FONT> = black. The ordering reflects the order of the pixels in the supplied pixel array.


<p><dt><STRONG>type:</STRONG><DD>
<P>
pixel type where 0 = unsigned char, 1 = short int, 2 = int, 3 = float, and
4 = double. Float and double types are expected to be normalized [0..1]
otherwise [0..MaxRGB].

<p><dt><STRONG>pixels:</STRONG><DD>
<P>
This array of values contain the pixel components as defined by the map and
type parameters. The length of the arrays must equal the area specified by
the width and height values and type parameters.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetPixelPacket">GetPixelPacket</A></H2>
<P>
Method GetPixelPacket initializes the PixelPacket structure.

<P>
The format of the GetPixelPacket method is:

<blockquote>void GetPixelPacket ( <A HREF="types/PixelPacket.html">PixelPacket</A> *pixel ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>pixel:</STRONG><DD>
<P>
Specifies a pointer to a PixelPacket structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="IsGeometry">IsGeometry</A></H2>
<P>
Method IsGeometry returns True if the geometry specification is valid as
determined by ParseGeometry.

<P>
The format of the IsGeometry method is:

<blockquote>unsigned int IsGeometry ( const char *geometry ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method IsGeometry returns True if the geometry specification is valid
otherwise False is returned.

<p><dt><STRONG>geometry:</STRONG><DD>
<P>
This string is the geometry specification.

</DL></DL>
<P>
<HR>
<H2><A NAME="IsSubimage">IsSubimage</A></H2>
<P>
Method IsSubimage returns True if the geometry is a valid subimage
specification (e.g. [1], [1-9], [1,7,4]).

<P>
The format of the IsSubimage method is:

<blockquote>unsigned int IsSubimage ( const char *geometry, const unsigned int pedantic ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method IsSubimage returns True if the geometry is a valid subimage
specification otherwise False is returned.

<p><dt><STRONG>geometry:</STRONG><DD>
<P>
This string is the geometry specification.

<p><dt><STRONG>pedantic:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> value other than 0 invokes a more restriction set of
conditions for a valid specification (e.g. [1], [1-4], [4-1]).

</DL></DL>
<P>
<HR>
<H2><A NAME="IsTainted">IsTainted</A></H2>
<P>
Method IsTainted returns True if the image has been altered since it was
first read or if any image in the sequence has a difference magic or
filename.

<P>
The format of the IsTainted method is:

<blockquote>unsigned int IsTainted ( const <A HREF="types/Image.html">Image</A> *image ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method IsTainted returns True if the image has been altered since it was
first read.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="LabelImage">LabelImage</A></H2>
<P>
Method LabelImage initializes an image label. Optionally the label can
include the image filename, type, width, height, or scene number by
embedding special format characters.

<P>
The format of the LabelImage method is:

<blockquote>void LabelImage ( <A HREF="types/Image.html">Image</A> *image, const char *label ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<p><dt><STRONG>label:</STRONG><DD>
<P>
The address of a character string containing the label format.

</DL></DL>
<P>
<HR>
<H2><A NAME="LayerImage">LayerImage</A></H2>
<P>
Method LayerImage extracts the specified layer from the references image.

<P>
The format of the LayerImage method is:

<blockquote>void LayerImage ( <A HREF="types/Image.html">Image</A> *image, const <A HREF="types/Enumerations.html#LayerType">LayerType</A> layer ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>layer:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> value of type LayerType that identifies which layer
to extract.

</DL></DL>
<P>
<HR>
<H2><A NAME="ListToGroupImage">ListToGroupImage</A></H2>
<P>
Method ListToGroupImage converts a linked list of images to a sequential
array.

<P>
The format of the ListToGroupImage method is:

<blockquote><A HREF="types/Image.html">Image</A> **ListToGroupImage ( const <A HREF="types/Image.html">Image</A> *image, unsigned int *number_images ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>images:</STRONG><DD>
<P>
Method ListToGroupImage converts a linked list of images to a sequential
array and returns the array..

<p><dt><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>number_images:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to an unsigned integer. The number of images
in the image array is returned here.

</DL></DL>
<P>
<HR>
<H2><A NAME="MatteImage">MatteImage</A></H2>
<P>
Method MatteImage initializes the matte channel of the reference image to
opaque.

<P>
The format of the MatteImage method is:

<blockquote>void MatteImage ( <A HREF="types/Image.html">Image</A> *image, Quantum opacity ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>opacity:</STRONG><DD>
<P>
The level of transparency.

</DL></DL>
<P>
<HR>
<H2><A NAME="MogrifyImage">MogrifyImage</A></H2>
<P>
Method MogrifyImage applies image processing options to an image as
prescribed by command line options.

<P>
The format of the MogrifyImage method is:

<blockquote>void MogrifyImage ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, const int argc, char **argv, <A HREF="types/Image.html">Image</A> **image ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>argc:</STRONG><DD>
<P>
Specifies a pointer to an integer describing the number of elements in the
argument vector.

<p><dt><STRONG>argv:</STRONG><DD>
<P>
Specifies a pointer to a text array containing the command line arguments.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="MogrifyImages">MogrifyImages</A></H2>
<P>
Method MogrifyImages applies image processing options to a sequence of
images as prescribed by command line options.

<P>
The format of the MogrifyImage method is:

<blockquote>void MogrifyImages ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, const int argc, char **argv, <A HREF="types/Image.html">Image</A> **images ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>argc:</STRONG><DD>
<P>
Specifies a pointer to an integer describing the number of elements in the
argument vector.

<p><dt><STRONG>argv:</STRONG><DD>
<P>
Specifies a pointer to a text array containing the command line arguments.

<p><dt><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="MosaicImages">MosaicImages</A></H2>
<P>
Method MosaicImages inlays a number of images to form a single coherent
picture.

<P>
The format of the MosaicImage method is:

<blockquote><A HREF="types/Image.html">Image</A> *MosaicImages ( const <A HREF="types/Image.html">Image</A> *images ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="ParseImageGeometry">ParseImageGeometry</A></H2>
<P>
Method ParseImageGeometry parses a geometry specification and returns the
width, height, x, and y values. It also returns flags that indicates which
of the four values (width, height, xoffset, yoffset) were located in the
string, and whether the x and y values are negative. In addition,

<P>
The format of the ParseImageGeometry method is:

<blockquote>int ParseImageGeometry ( const char *geometry, int *x, int *y, unsigned int *width, unsigned int *height ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>flags:</STRONG><DD>
<P>
Method ParseImageGeometry returns a bitmask that indicates which of the
four values were located in the geometry string.

<p><dt><STRONG>image_geometry:</STRONG><DD>
<P>
Specifies a character string representing the geometry specification.

<p><dt><STRONG>x,y:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to an integer. The x and y offset as
determined by the geometry specification is returned here.

<p><dt><STRONG>width,height:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to an unsigned integer. The width and height
as determined by the geometry specification is returned here.

</DL></DL>
<P>
<HR>
<H2><A NAME="PingImage">PingImage</A></H2>
<P>
Method PingImage returns the image size in bytes if it exists and can be
the image is returned as well. Note, only the first image in a multi-frame
image file is pinged.

<P>
The format of the PingImage method is:

<blockquote><A HREF="types/Image.html">Image</A> *PingImage ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>Image:</STRONG><DD>
<P>
Method PingImage returns the image size in bytes if the image file exists
and it size can be determined otherwise 0.

<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="ReadImage">ReadImage</A></H2>
<P>
Method ReadImage reads an image and returns it. It allocates the memory
necessary for the new Image structure and returns a pointer to the new
image. By default, the image format is determined by its magic number. To
specify a particular image format, precede the filename with an explicit
image format name and a colon (i.e. ps:image) or as the filename suffix
(i.e. image.ps).

<P>
The format of the ReadImage method is:

<blockquote><A HREF="types/Image.html">Image</A> *ReadImage ( <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
Method ReadImage returns a pointer to the image after reading. 
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage
or if the image cannot be read.

<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="ReadImages">ReadImages</A></H2>
<P>
Method ReadImages reads a list of image names from a file and then returns
the images as a linked list.

<P>
The format of the ReadImage method is:

<blockquote><A HREF="types/Image.html">Image</A> *ReadImages ( <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
Method ReadImage returns a pointer to the image after reading. 
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage
or if the image cannot be read.

<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="RGBTransformImage">RGBTransformImage</A></H2>
<P>
Method RGBTransformImage converts the reference image from 
<FONT SIZE=-1>RGB</FONT> to an alternate colorspace. The transformation
matrices are not the standard ones: the weights are rescaled to normalized
the range of the transformed values to be [0..MaxRGB].

<P>
The format of the RGBTransformImage method is:

<blockquote>void RGBTransformImage ( <A HREF="types/Image.html">Image</A> *image, const <A HREF="types/Enumerations.html#ColorspaceType">ColorspaceType</A> colorspace ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>colorspace:</STRONG><DD>
<P>
An unsigned integer value that indicates which colorspace to transform the
image.

</DL></DL>
<P>
<HR>
<H2><A NAME="SetImage">SetImage</A></H2>
<P>
Method SetImage initializes the reference image to the background color.

<P>
The format of the SetImage method is:

<blockquote>void SetImage ( <A HREF="types/Image.html">Image</A> *image ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="SetImageInfo">SetImageInfo</A></H2>
<P>
Method SetImageInfo initializes the `magick' field of the ImageInfo structure. It is set to a type of image format based on the prefix or suffix of the filename. For example, `ps:image' returns 
<FONT SIZE=-1>PS</FONT> indicating a Postscript image. 
<FONT SIZE=-1>JPEG</FONT> is returned for this filename: `image.jpg'. The filename prefix has precendence over the suffix. Use an optional index enclosed in brackets after a file name to specify a desired subimage of a multi-resolution image format like Photo 
<FONT SIZE=-1>CD</FONT> (e.g. img0001.pcd[4]).


<P>
The format of the SetImageInfo method is:

<blockquote>void SetImageInfo ( <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, const unsigned int rectify ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>rectify:</STRONG><DD>
<P>
an unsigned value other than zero rectifies the attribute for multi-frame
support (user may want multi-frame but image format may not support it).

</DL></DL>
<P>
<HR>
<H2><A NAME="SortColormapByIntentsity">SortColormapByIntentsity</A></H2>
<P>
Method SortColormapByIntensity sorts the colormap of a PseudoClass image by
decreasing color intensity.

<P>
The format of the SortColormapByIntensity method is:

<P>
<PRE>    void SortColormapByIntensity(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to a Image structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="SyncImage">SyncImage</A></H2>
<P>
Method SyncImage initializes the red, green, and blue intensities of each
pixel as defined by the colormap index.

<P>
The format of the SyncImage method is:

<blockquote>void SyncImage ( <A HREF="types/Image.html">Image</A> *image ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="TextureImage">TextureImage</A></H2>
<P>
Method TextureImage layers a texture onto the background of an image.

<P>
The format of the TextureImage method is:

<blockquote>void TextureImage ( <A HREF="types/Image.html">Image</A> *image, <A HREF="types/Image.html">Image</A> *texture ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>texture:</STRONG><DD>
<P>
This image contains the texture to layer on the background.

</DL></DL>
<P>
<HR>
<H2><A NAME="TransformRGBImage">TransformRGBImage</A></H2>
<P>
Method TransformRGBImage converts the reference image from an alternate
colorspace. The transformation matrices are not the standard ones: the
weights are rescaled to normalize the range of the transformed values to be
[0..MaxRGB].

<P>
The format of the TransformRGBImage method is:

<blockquote>void TransformRGBImage ( <A HREF="types/Image.html">Image</A> *image, const <A HREF="types/Enumerations.html#ColorspaceType">ColorspaceType</A> colorspace ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>colorspace:</STRONG><DD>
<P>
An unsigned integer value defines which colorspace to transform the image
to.

</DL></DL>
<P>
<HR>
<H2><A NAME="TransparentImage">TransparentImage</A></H2>
<P>
Method TransparentImage creates a matte image associated with the image.
All pixel locations are initially set to opaque. Any pixel that matches the
specified color are set to transparent.

<P>
The format of the TransparentImage method is:

<blockquote>void TransparentImage ( <A HREF="types/Image.html">Image</A> *image, const char *color ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>color:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> character string that contain an 
<FONT SIZE=-1>X11</FONT> color string.


</DL></DL>
<P>
<HR>
<H2><A NAME="WriteImage">WriteImage</A></H2>
<P>
Method WriteImage writes an image to a file as defined by image-&gt;filename. You can specify a particular image format by prefixing the file with the image type and a colon (i.e. ps:image) or specify the image type as the filename suffix (i.e. image.ps). The image may be modified to adapt it to the requirements of the image format. For example, DirectClass images must be color-reduced to PseudoClass if the format is 
<FONT SIZE=-1>GIF.</FONT>


<P>
The format of the WriteImage method is:

<blockquote>unsigned int WriteImage ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, <A HREF="types/Image.html">Image</A> *image ); </blockquote>

<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method WriteImage return True if the image is written. False is returned is
there is a memory shortage or if the image file fails to write.

<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>image:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to a Image structure.

</DL></DL>
</BODY>

</HTML>
