<HTML>
<HEAD>
<TITLE>image - ImageMagick Image Methods</TITLE>
<LINK REV="made" HREF="mailto:cristy@mystic.es.dupont.com">
</HEAD>

<body background="../../images/background.gif">

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#FUNCTION_DESCRIPTIONS">FUNCTION DESCRIPTIONS</A>
	<UL>

		<LI><A HREF="#AllocateImage">AllocateImage</A>
		<LI><A HREF="#AllocateNextImage">AllocateNextImage</A>
		<LI><A HREF="#AnnotateImage">AnnotateImage</A>
		<LI><A HREF="#AppendImages">AppendImages</A>
		<LI><A HREF="#AverageImages">AverageImages</A>
		<LI><A HREF="#BorderImage">BorderImage</A>
		<LI><A HREF="#ChopImage">ChopImage</A>
		<LI><A HREF="#CloseImage">CloseImage</A>
		<LI><A HREF="#CoalesceImage">CoalesceImage</A>
		<LI><A HREF="#ColorFloodfillImage">ColorFloodfillImage</A>
		<LI><A HREF="#ColorizeImage">ColorizeImage</A>
		<LI><A HREF="#CommentImage">CommentImage</A>
		<LI><A HREF="#CompressColormap">CompressColormap</A>
		<LI><A HREF="#CompositeImage">CompositeImage</A>
		<LI><A HREF="#CondenseImage">CondenseImage</A>
		<LI><A HREF="#ContrastImage">ContrastImage</A>
		<LI><A HREF="#CloneImage">CloneImage</A>
		<LI><A HREF="#CropImage">CropImage</A>
		<LI><A HREF="#CycleColormapImage">CycleColormapImage</A>
		<LI><A HREF="#DescribeImage">DescribeImage</A>
		<LI><A HREF="#DestroyImage">DestroyImage</A>
		<LI><A HREF="#DestroyImageInfo">DestroyImageInfo</A>
		<LI><A HREF="#DestroyImages">DestroyImages</A>
		<LI><A HREF="#DrawImage">DrawImage</A>
		<LI><A HREF="#EqualizeImage">EqualizeImage</A>
		<LI><A HREF="#FlipImage">FlipImage</A>
		<LI><A HREF="#FlopImage">FlopImage</A>
		<LI><A HREF="#FrameImage">FrameImage</A>
		<LI><A HREF="#GammaImage">GammaImage</A>
		<LI><A HREF="#GetAnnotateInfo">GetAnnotateInfo</A>
		<LI><A HREF="#GetImageInfo">GetImageInfo</A>
		<LI><A HREF="#GetImageType">GetImageType</A>
		<LI><A HREF="#GetMontageInfo">GetMontageInfo</A>
		<LI><A HREF="#IsGeometry">IsGeometry</A>
		<LI><A HREF="#IsGrayImage">IsGrayImage</A>
		<LI><A HREF="#IsMonochromeImage">IsMonochromeImage</A>
		<LI><A HREF="#IsSubimage">IsSubimage</A>
		<LI><A HREF="#IsTainted">IsTainted</A>
		<LI><A HREF="#LabelImage">LabelImage</A>
		<LI><A HREF="#LayerImage">LayerImage</A>
		<LI><A HREF="#ListToGroupImage">ListToGroupImage</A>
		<LI><A HREF="#MagnifyImage">MagnifyImage</A>
		<LI><A HREF="#MatteFloodfillImage">MatteFloodfillImage</A>
		<LI><A HREF="#MatteImage">MatteImage</A>
		<LI><A HREF="#MinifyImage">MinifyImage</A>
		<LI><A HREF="#ModulateImage">ModulateImage</A>
		<LI><A HREF="#MogrifyImage">MogrifyImage</A>
		<LI><A HREF="#MogrifyImages">MogrifyImages</A>
		<LI><A HREF="#MontageImages">MontageImages</A>
		<LI><A HREF="#MorphImages">MorphImages</A>
		<LI><A HREF="#NegateImage">NegateImage</A>
		<LI><A HREF="#NormalizeImage">NormalizeImage</A>
		<LI><A HREF="#OpagueImage">OpagueImage</A>
		<LI><A HREF="#OpenImage">OpenImage</A>
		<LI><A HREF="#ParseImageGeometry">ParseImageGeometry</A>
		<LI><A HREF="#PingImage">PingImage</A>
		<LI><A HREF="#RGBTransformImage">RGBTransformImage</A>
		<LI><A HREF="#RollImage">RollImage</A>
		<LI><A HREF="#SampleImage">SampleImage</A>
		<LI><A HREF="#ScaleImage">ScaleImage</A>
		<LI><A HREF="#SetImage">SetImage</A>
		<LI><A HREF="#SetImageInfo">SetImageInfo</A>
		<LI><A HREF="#SetNumberScenes">SetNumberScenes</A>
		<LI><A HREF="#SortColormapByIntentsity">SortColormapByIntentsity</A>
		<LI><A HREF="#SteganoImage">SteganoImage</A>
		<LI><A HREF="#StereoImage">StereoImage</A>
		<LI><A HREF="#SyncImage">SyncImage</A>
		<LI><A HREF="#TextureImage">TextureImage</A>
		<LI><A HREF="#ThresholdImage">ThresholdImage</A>
		<LI><A HREF="#TransformImage">TransformImage</A>
		<LI><A HREF="#TransformRGBImage">TransformRGBImage</A>
		<LI><A HREF="#TransparentImage">TransparentImage</A>
		<LI><A HREF="#UncompressImage">UncompressImage</A>
		<LI><A HREF="#ZoomImage">ZoomImage</A>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
image - ImageMagick Image Methods

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
allocated_image=<STRONG>AllocateImage</STRONG>(image_info)

<P>
<STRONG>AnnotateImage</STRONG>(image,annotate_info)

<P>
<STRONG>AppendImages</STRONG>(images,stack)

<P>
averaged_image=<STRONG>AverageImages</STRONG>(images)

<P>
bordered_image=<STRONG>BorderImage</STRONG>(image,border_info)

<P>
chop_image=<STRONG>ChopImage</STRONG>(image,chop_info)

<P>
clone_image=<STRONG>CloneImage</STRONG>(image,columns,rows,clone_pixels)

<P>
<STRONG>CloseImage</STRONG>(image)

<P>
<STRONG>ColorFloodfillImage</STRONG>(image,target,pen,x,y,method)

<P>
<STRONG>ColorizeImage</STRONG>(image,opaque_color,pen_color)

<P>
<STRONG>CommentImage</STRONG>(image,comments)

<P>
<STRONG>CompositeImage</STRONG>(image,compose,composite_image,x_offset,y_offset)

<P>
<STRONG>CompressColormap</STRONG>(image)

<P>
<STRONG>CondenseImage</STRONG>(image)

<P>
<STRONG>ContrastImage</STRONG>(image,sharpen)

<P>
cropped_image=<STRONG>CropImage</STRONG>(image,crop_info)

<P>
<STRONG>CycleColormapImage</STRONG>(image,amount)

<P>
<STRONG>DescribeImage</STRONG>(image,file,verbose)

<P>
<STRONG>DestroyImage</STRONG>(image)

<P>
<STRONG>DestroyImageInfo</STRONG>(image_info)

<P>
<STRONG>DestroyImages</STRONG>(image)

<P>
<STRONG>DrawImage</STRONG>(image,annotate_info)

<P>
<STRONG>EqualizeImage</STRONG>(image)

<P>
flipped_image=<STRONG>FlipImage</STRONG>(image)

<P>
flopped_image=<STRONG>FlopImage</STRONG>(image)

<P>
framed_image=<STRONG>FrameImage</STRONG>(image,frame_info)

<P>
<STRONG>GammaImage</STRONG>(image,gamma)

<P>
<STRONG>GetAnnotateInfo</STRONG>(image_info,annotate_info)

<P>
<STRONG>GetImageInfo</STRONG>(image_info)

<P>
type=<STRONG>GetImageType</STRONG>(image_info,image)

<P>
<STRONG>GetMontageInfo</STRONG>(montage_info)

<P>
status=<STRONG>IsGeometry</STRONG>(geometry)

<P>
status=<STRONG>IsGrayImage</STRONG>(image)

<P>
status=<STRONG>IsMonochromeImage</STRONG>(image)

<P>
status=<STRONG>IsSubimage</STRONG>(geometry,pedantic)

<P>
status=<STRONG>IsTainted</STRONG>(image)

<P>
<STRONG>LabelImage</STRONG>(image,label)

<P>
<STRONG>LayerImage</STRONG>(image,layer)

<P>
images=<STRONG>ListToGroupImage</STRONG>(images,number_images)

<P>
magnified_image=<STRONG>MagnifyImage</STRONG>(image)

<P>
<STRONG>MatteFloodfillImage</STRONG>(image,target,matte,x,y,method)

<P>
<STRONG>MatteImage</STRONG>(image)

<P>
minified_image=<STRONG>MinifyImage</STRONG>(image)

<P>
<STRONG>ModulateImage</STRONG>(image,modulate)

<P>
<STRONG>MogrifyImage</STRONG>(image_info,argc,argv,image)

<P>
<STRONG>MogrifyImages</STRONG>(image_info,argc,argv,images)

<P>
<STRONG>MontageImages</STRONG>(image,montage_info)

<P>
morphed_image=<STRONG>MorphImages</STRONG>(images,number_frames)

<P>
<STRONG>NegateImage</STRONG>(image,grayscale)

<P>
<STRONG>NormalizeImage</STRONG>(image)

<P>
<STRONG>OpenImage</STRONG>(image_info,image,type)

<P>
flags=<STRONG>ParseImageGeometry</STRONG>(image_geometry,x,y,width,height)

<P>
filesize=<STRONG>PingImage</STRONG>(image_info,columns,rows)

<P>
<STRONG>RGBTransformImage</STRONG>(image,colorspace)

<P>
rolled_image=<STRONG>RollImage</STRONG>(image,x_offset,y_offset)

<P>
sampled_image=<STRONG>SampleImage</STRONG>(image,columns,rows)

<P>
scaled_image=<STRONG>ScaleImage</STRONG>(image,columns,rows)

<P>
<STRONG>SetImage</STRONG>(image)

<P>
<STRONG>SetImageInfo</STRONG>(image_info,rectify)

<P>
<STRONG>SetNumberScenes</STRONG>(image)

<P>
stegano_image=<STRONG>SteganoImage</STRONG>(image,watermark)

<P>
stereo_image=<STRONG>StereoImage</STRONG>(left_image,right_image)

<P>
<STRONG>SyncImage</STRONG>(image)

<P>
<STRONG>TextureImage</STRONG>(image,filename)

<P>
<STRONG>ThresholdImage</STRONG>(image,threshold)

<P>
<STRONG>TransformImage</STRONG>(image,crop_geometry,image_geometry)

<P>
<STRONG>TransformRGBImage</STRONG>(image,colorspace)

<P>
<STRONG>TransparentImage</STRONG>(image,color)

<P>
zoomed_image=<STRONG>ZoomImage</STRONG>(image,columns,rows)

<P>
<HR>
<H1><A NAME="FUNCTION_DESCRIPTIONS">FUNCTION DESCRIPTIONS</A></H1>
<P>
<HR>
<H2><A NAME="AllocateImage">AllocateImage</A></H2>
<P>
Method AllocateImage allocates an Image structure and initializes each
field to a default value.

<P>
The format of the AllocateImage routine is:

<P>
<PRE>        allocated_image=AllocateImage(image_info)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG><A NAME="item_o">allocated_image:</A></STRONG><DD>
<P>
Method AllocateImage returns a pointer to an image structure initialized to
default values. A null image is returned if there is a memory shortage.

<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="AllocateNextImage">AllocateNextImage</A></H2>
<P>
Method AllocateNextImage allocates an Image structure and initializes each
field to a default value.

<P>
The format of the AllocateNextImage routine is:

<P>
<PRE>    AllocateImage(image_info,image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="AnnotateImage">AnnotateImage</A></H2>
<P>
Method AnnotateImage annotates an image with text. Optionally the
annotation can include the image filename, type, width, height, or scene
number by embedding special format characters.

<P>
The format of the AnnotateImage routine is:

<P>
<PRE>        AnnotateImage(image,annotate_info)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>annotate_info:</STRONG><DD>
<P>
The address of a AnnotateInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="AppendImages">AppendImages</A></H2>
<P>
Method AppendImages appends a set of images. All the input images must have
the same width or height. Images of the same width are stacked
top-to-bottom. Images of the same height are stacked left-to-right. If the
stack is false, rectangular images are stacked left-to-right otherwise
top-to-bottom.

<P>
The format of the AppendImage routine is:

<P>
<PRE>        AppendImages(images,stack)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>stack:</STRONG><DD>
<P>
An unsigned value other than stacks rectangular images top-to-bottom
otherwise left-to-right.

</DL></DL>
<P>
<HR>
<H2><A NAME="AverageImages">AverageImages</A></H2>
<P>
Method AverageImages averages a set of images. All the input images must be
the same size in pixels.

<P>
The format of the AverageImage routine is:

<P>
<PRE>        averaged_image=AverageImages(images)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>averaged_image:</STRONG><DD>
<P>
Method AverageImages returns the mean pixel value for an image sequence.

<DT><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="BorderImage">BorderImage</A></H2>
<P>
Method BorderImage takes an image and puts a border around it of a
particular color. It allocates the memory necessary for the new Image
structure and returns a pointer to the new image.

<P>
The format of the BorderImage routine is:

<P>
<PRE>        bordered_image=BorderImage(image,border_info)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>bordered_image:</STRONG><DD>
<P>
Method BorderImage returns a pointer to the bordered image. A null image is
returned if there is a memory shortage.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>border_info:</STRONG><DD>
<P>
Specifies a pointer to a structure of type Rectangle which defines the
border region.

</DL></DL>
<P>
<HR>
<H2><A NAME="ChopImage">ChopImage</A></H2>
<P>
Method ChopImage creates a new image that is a subregion of an existing
one. It allocates the memory necessary for the new Image structure and
returns a pointer to the new image.

<P>
The format of the ChopImage routine is:

<P>
<PRE>        chop_image=ChopImage(image,chop_info)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>chop_image:</STRONG><DD>
<P>
Method ChopImage returns a pointer to the chop image. A null image is
returned if there is a memory shortage or if the image width or height is
zero.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>chop_info:</STRONG><DD>
<P>
Specifies a pointer to a RectangleInfo which defines the region of the
image to crop.

</DL></DL>
<P>
<HR>
<H2><A NAME="CloseImage">CloseImage</A></H2>
<P>
Method CloseImage closes a file associated with the image. If the filename
prefix is '|', the file is a pipe and is closed with PipeClose.

<P>
The format of the CloseImage routine is:

<P>
<PRE>        CloseImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="CoalesceImage">CoalesceImage</A></H2>
<P>
Method CoalesceImages merges a sequence of images. This is useful for GIF
animation sequences that have page offsets and disposal methods.

<P>
The format of the CoalesceImages routine is:

<P>
<PRE>    CoalesceImages(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="ColorFloodfillImage">ColorFloodfillImage</A></H2>
<P>
Method ColorFloodfillImage floodfills the designated area with a color. The
floodfill algorithm is strongly based on a similiar algorithm in ``Graphics
Gems'' by Paul Heckbert.

<P>
The format of the ColorFloodfillImage routine is:

<P>
<PRE>        ColorFloodfillImage(image,target,pen,x,y,method)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>target:</STRONG><DD>
<P>
A RunlengthPacket structure. This is the RGB value of the target color.

<DT><STRONG>pen:</STRONG><DD>
<P>
A character string representing the pen color.

<DT><STRONG>x,y:</STRONG><DD>
<P>
Unsigned integers representing the current location of the pen.

<DT><STRONG>method:</STRONG><DD>
<P>
drawing method of type PrimitiveType: floodfill or fill to border.

</DL></DL>
<P>
<HR>
<H2><A NAME="ColorizeImage">ColorizeImage</A></H2>
<P>
Method ColorizeImage colorizes an image with the pen color. The amount of
the coloring is controled with the opacity levels.

<P>
The format of the ColorizeImage routine is:

<P>
<PRE>        ColorizeImage(image,opaque_color,pen_color)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>opaque_color, pen_color:</STRONG><DD>
<P>
A character string that contain an X11 color string.

</DL></DL>
<P>
<HR>
<H2><A NAME="CommentImage">CommentImage</A></H2>
<P>
Method CommentImage initializes an image comment. Optionally the comment
can include the image filename, type, width, height, or scene number by
embedding special format characters.

<P>
The format of the CommentImage routine is:

<P>
<PRE>        CommentImage(image,comments)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>comments:</STRONG><DD>
<P>
The address of a character string containing the comment format.

</DL></DL>
<P>
<HR>
<H2><A NAME="CompressColormap">CompressColormap</A></H2>
<P>
Method CompressColormap compresses an image colormap removing any duplicate
and unused color entries.

<P>
The format of the CompressColormap routine is:

<P>
<PRE>        CompressColormap(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="CompositeImage">CompositeImage</A></H2>
<P>
Method CompositeImage returns the second image composited onto the first at
the specified offsets.

<P>
The format of the CompositeImage routine is:

<P>
<PRE>        CompositeImage(image,compose,composite_image,x_offset,y_offset)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>compose:</STRONG><DD>
<P>
Specifies an image composite operator.

<DT><STRONG>composite_image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>x_offset:</STRONG><DD>
<P>
An integer that specifies the column offset of the composited image.

<DT><STRONG>y_offset:</STRONG><DD>
<P>
An integer that specifies the row offset of the composited image.

</DL></DL>
<P>
<HR>
<H2><A NAME="CondenseImage">CondenseImage</A></H2>
<P>
Method CondenseImage compresses an image to the minimum number of
runlength-encoded packets.

<P>
The format of the CondenseImage routine is:

<P>
<PRE>        CondenseImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="ContrastImage">ContrastImage</A></H2>
<P>
Method ContrastImage enhances the intensity differences between the lighter
and darker elements of the image.

<P>
The format of the ContrastImage routine is:

<P>
<PRE>        ContrastImage(image,sharpen)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>sharpen:</STRONG><DD>
<P>
If True, the intensity is increased otherwise it is decreased.

</DL></DL>
<P>
<HR>
<H2><A NAME="CloneImage">CloneImage</A></H2>
<P>
Method CloneImage returns a copy of all fields of the input image. The the
pixel memory is allocated but the pixel data is not copied.

<P>
The format of the CloneImage routine is:

<P>
<PRE>        clone_image=CloneImage(image,columns,rows,clone_pixels)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>clone_image:</STRONG><DD>
<P>
Method CloneImage returns a pointer to the image after copying. A null
image is returned if there is a memory shortage.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>columns:</STRONG><DD>
<P>
An integer that specifies the number of columns in the copied image.

<DT><STRONG>rows:</STRONG><DD>
<P>
An integer that specifies the number of rows in the copied image.

<DT><STRONG>clone_pixels:</STRONG><DD>
<P>
Specifies whether the pixel data is copied. Must be either True or False;

</DL></DL>
<P>
<HR>
<H2><A NAME="CropImage">CropImage</A></H2>
<P>
Method CropImage creates a new image that is a subregion of an existing
one. It allocates the memory necessary for the new Image structure and
returns a pointer to the new image. This routine is optimized to perserve
the runlength encoding. That is, the cropped image will always use less
memory than the original.

<P>
The format of the CropImage routine is:

<P>
<PRE>        cropped_image=CropImage(image,crop_info)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>cropped_image:</STRONG><DD>
<P>
Method CropImage returns a pointer to the cropped image. A null image is
returned if there is a memory shortage or if the image width or height is
zero.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>crop_info:</STRONG><DD>
<P>
Specifies a pointer to a RectangleInfo which defines the region of the
image to crop.

</DL></DL>
<P>
<HR>
<H2><A NAME="CycleColormapImage">CycleColormapImage</A></H2>
<P>
Method CycleColormapImage cycles the image colormap by a specified amount.

<P>
The format of the CycleColormapImage routine is:

<P>
<PRE>        CycleColormapImage(image,amount)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>amount:</STRONG><DD>
<P>
An unsigned value that specifies the offset of the colormap.

</DL></DL>
<P>
<HR>
<H2><A NAME="DescribeImage">DescribeImage</A></H2>
<P>
Method DescribeImage describes an image by printing its attributes to
stdout.

<P>
The format of the DescribeImage routine is:

<P>
<PRE>        DescribeImage(image,file,verbose)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>file:</STRONG><DD>
<P>
send the image attributes to this file.

<DT><STRONG>verbose:</STRONG><DD>
<P>
an unsigned value other than zero prints detailed information about the
image.

</DL></DL>
<P>
<HR>
<H2><A NAME="DestroyImage">DestroyImage</A></H2>
<P>
Method DestroyImage deallocates memory associated with an image.

<P>
The format of the DestroyImage routine is:

<P>
<PRE>        DestroyImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="DestroyImageInfo">DestroyImageInfo</A></H2>
<P>
Method DestroyImageInfo deallocates memory associated with an ImageInfo
structure.

<P>
The format of the DestroyImageInfo routine is:

<P>
<PRE>        DestroyImageInfo(image_info)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="DestroyImages">DestroyImages</A></H2>
<P>
Method DestroyImages deallocates memory associated with a linked list of
images.

<P>
The format of the DestroyImages routine is:

<P>
<PRE>        DestroyImages(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="DrawImage">DrawImage</A></H2>
<P>
Method DrawImage draws a primitive (line, rectangle, ellipse) on the image.

<P>
The format of the DrawImage routine is:

<P>
<PRE>        DrawImage(image,annotate_info)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>annotate_info:</STRONG><DD>
<P>
The address of a DrawInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="EqualizeImage">EqualizeImage</A></H2>
<P>
Method EqualizeImage performs histogram equalization on the reference
image.

<P>
The format of the EqualizeImage routine is:

<P>
<PRE>        EqualizeImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="FlipImage">FlipImage</A></H2>
<P>
Method FlipImage creates a new image that reflects each scanline in the
vertical direction It allocates the memory necessary for the new Image
structure and returns a pointer to the new image.

<P>
The format of the FlipImage routine is:

<P>
<PRE>        flipped_image=FlipImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>flipped_image:</STRONG><DD>
<P>
Method FlipImage returns a pointer to the image after reflecting. A null
image is returned if there is a memory shortage.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="FlopImage">FlopImage</A></H2>
<P>
Method FlopImage creates a new image that reflects each scanline in the
horizontal direction It allocates the memory necessary for the new Image
structure and returns a pointer to the new image.

<P>
The format of the FlopImage routine is:

<P>
<PRE>        flopped_image=FlopImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>flopped_image:</STRONG><DD>
<P>
Method FlopImage returns a pointer to the image after reflecting. A null
image is returned if there is a memory shortage.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="FrameImage">FrameImage</A></H2>
<P>
Method FrameImage takes an image and puts a frame around it of a particular
color. It allocates the memory necessary for the new Image structure and
returns a pointer to the new image.

<P>
The format of the FrameImage routine is:

<P>
<PRE>        framed_image=FrameImage(image,frame_info)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>framed_image:</STRONG><DD>
<P>
Method FrameImage returns a pointer to the framed image. A null image is
returned if there is a memory shortage.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>frame_info:</STRONG><DD>
<P>
Specifies a pointer to a FrameInfo structure which defines the framed
region.

</DL></DL>
<P>
<HR>
<H2><A NAME="GammaImage">GammaImage</A></H2>
<P>
Method GammaImage converts the reference image to gamma corrected colors.

<P>
The format of the GammaImage routine is:

<P>
<PRE>        GammaImage(image,gamma)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>gamma:</STRONG><DD>
<P>
A character string indicating the level of gamma correction.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetAnnotateInfo">GetAnnotateInfo</A></H2>
<P>
Method GetAnnotateInfo initializes the AnnotateInfo structure.

<P>
The format of the GetAnnotateInfo routine is:

<P>
<PRE>        GetAnnotateInfo(image_info,annotate_info)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<DT><STRONG>annotate_info:</STRONG><DD>
<P>
Specifies a pointer to a AnnotateInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetImageInfo">GetImageInfo</A></H2>
<P>
Method GetImageInfo initializes the ImageInfo structure.

<P>
The format of the GetImageInfo routine is:

<P>
<PRE>        GetImageInfo(image_info)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetImageType">GetImageType</A></H2>
<P>
Method GetImageType returns the type of image (e.g. bilevel, palette, etc).

<P>
The format of the GetImageType routine is:

<P>
<PRE>        type=GetImageType(image_info,image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>type:</STRONG><DD>
<P>
Method GetImageType returns a ImageType enum that specifies the type of the
specified image (e.g. bilevel, palette, etc).

<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetMontageInfo">GetMontageInfo</A></H2>
<P>
Method GetMontageInfo initializes the MontageInfo structure.

<P>
The format of the GetMontageInfo routine is:

<P>
<PRE>        GetMontageInfo(montage_info)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>montage_info:</STRONG><DD>
<P>
Specifies a pointer to a MontageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="IsGeometry">IsGeometry</A></H2>
<P>
Method IsGeometry returns True if the geometry specification is valid as
determined by XParseGeometry.

<P>
The format of the IsGeometry routine is:

<P>
<PRE>        status=IsGeometry(geometry)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method IsGeometry returns True if the geometry specification is valid
otherwise False is returned.

<DT><STRONG>geometry:</STRONG><DD>
<P>
This string is the geometry specification.

</DL></DL>
<P>
<HR>
<H2><A NAME="IsGrayImage">IsGrayImage</A></H2>
<P>
Method IsGrayImage returns True if the image is grayscale otherwise False
is returned. If the image is DirectClass and grayscale, it is demoted to
PseudoClass.

<P>
The format of the IsGrayImage routine is:

<P>
<PRE>        status=IsGrayImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method IsGrayImage returns True if the image is grayscale otherwise False
is returned.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="IsMonochromeImage">IsMonochromeImage</A></H2>
<P>
Method IsMonochromeImage returns True if the image is monochrome otherwise
False is returned. If the image is DirectClass and monochrome, it is
demoted to PseudoClass.

<P>
The format of the IsMonochromeImage routine is:

<P>
<PRE>        status=IsMonochromeImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method IsMonochromeImage returns True if the image is monochrome otherwise
False is returned.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="IsSubimage">IsSubimage</A></H2>
<P>
Method IsSubimage returns True if the geometry is a valid subimage
specification (e.g. [1], [1-9], [1,7,4]).

<P>
The format of the IsSubimage routine is:

<P>
<PRE>        status=IsSubimage(geometry,pedantic)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method IsSubimage returns True if the geometry is a valid subimage
specification otherwise False is returned.

<DT><STRONG>geometry:</STRONG><DD>
<P>
This string is the geometry specification.

<DT><STRONG>pedantic:</STRONG><DD>
<P>
A value other than 0 invokes a more restriction set of conditions for a
valid specification (e.g. [1], [1-4], [4-1]).

</DL></DL>
<P>
<HR>
<H2><A NAME="IsTainted">IsTainted</A></H2>
<P>
Method IsTainted returns True if the image has been altered since it was
first read or if any image in the sequence has a difference magic or
filename.

<P>
The format of the IsTainted routine is:

<P>
<PRE>        status=IsTainted(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method IsTainted returns True if the image has been altered since it was
first read.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="LabelImage">LabelImage</A></H2>
<P>
Method LabelImage initializes an image label. Optionally the label can
include the image filename, type, width, height, or scene number by
embedding special format characters.

<P>
The format of the LabelImage routine is:

<P>
<PRE>        LabelImage(image,label)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>label:</STRONG><DD>
<P>
The address of a character string containing the label format.

</DL></DL>
<P>
<HR>
<H2><A NAME="LayerImage">LayerImage</A></H2>
<P>
Method LayerImage extracts the specified layer from the references image.

<P>
The format of the LayerImage routine is:

<P>
<PRE>        LayerImage(image,layer)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>layer:</STRONG><DD>
<P>
A value of type LayerType that identifies which layer to extract.

</DL></DL>
<P>
<HR>
<H2><A NAME="ListToGroupImage">ListToGroupImage</A></H2>
<P>
Method ListToGroupImage converts a linked list of images to a sequential
array.

<P>
The format of the ListToGroupImage routine is:

<P>
<PRE>        images=ListToGroupImage(images,number_images)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>images:</STRONG><DD>
<P>
Method ListToGroupImage converts a linked list of images to a sequential
array and returns the array..

<DT><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>number_images:</STRONG><DD>
<P>
A pointer to an unsigned integer. The number of images in the image array
is returned here.

</DL></DL>
<P>
<HR>
<H2><A NAME="MagnifyImage">MagnifyImage</A></H2>
<P>
Method MagnifyImage creates a new image that is a integral size greater
than an existing one. It allocates the memory necessary for the new Image
structure and returns a pointer to the new image.

<P>
MagnifyImage scans the reference image to create a magnified image by
bilinear interpolation. The magnified image columns and rows become:

<P>
<PRE>  number_columns &lt;&lt; 1
</PRE>
<P>
<PRE>  number_rows &lt;&lt; 1
</PRE>
<P>
The format of the MagnifyImage routine is:

<P>
<PRE>        magnified_image=MagnifyImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>magnified_image:</STRONG><DD>
<P>
Method MagnifyImage returns a pointer to the image after magnification. A
null image is returned if there is a memory shortage.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="MatteFloodfillImage">MatteFloodfillImage</A></H2>
<P>
Method MatteFloodfillImage floodfills the designated area with a matte
value. The floodfill algorithm is strongly based on a similiar algorithm in
``Graphics Gems'' by Paul Heckbert.

<P>
The format of the MatteFloodfillImage routine is:

<P>
<PRE>        MatteFloodfillImage(image,target,matte,x,y,method)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>target:</STRONG><DD>
<P>
A RunlengthPacket structure. This is the RGB value of the target color.

<DT><STRONG>matte:</STRONG><DD>
<P>
A integer value representing the amount of transparency.

<DT><STRONG>x,y:</STRONG><DD>
<P>
Unsigned integers representing the current location of the pen.

<DT><STRONG>method:</STRONG><DD>
<P>
drawing method of type PrimitiveType: floodfill or fill to border.

</DL></DL>
<P>
<HR>
<H2><A NAME="MatteImage">MatteImage</A></H2>
<P>
Method MatteImage initializes the matte channel of the reference image to
opaque.

<P>
The format of the MatteImage routine is:

<P>
<PRE>        MatteImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="MinifyImage">MinifyImage</A></H2>
<P>
Method MinifyImage creates a new image that is a integral size less than an
existing one. It allocates the memory necessary for the new Image structure
and returns a pointer to the new image.

<P>
MinifyImage scans the reference image to create a minified image by
computing the weighted average of a 4x4 cell centered at each reference
pixel. The target pixel requires two columns and two rows of the reference
pixels. Therefore the minified image columns and rows become:

<P>
<PRE>  number_columns/2
</PRE>
<P>
<PRE>  number_rows/2
</PRE>
<P>
Weights assume that the importance of neighboring pixels is negately
proportional to the square of their distance from the target pixel.

<P>
The scan only processes pixels that have a full set of neighbors. Pixels in
the top, bottom, left, and right pairs of rows and columns are omitted from
the scan.

<P>
The format of the MinifyImage routine is:

<P>
<PRE>        minified_image=MinifyImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>minified_image:</STRONG><DD>
<P>
Method MinifyImage returns a pointer to the image after reducing. A null
image is returned if there is a memory shortage or if the image size is
less than IconSize*2.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="ModulateImage">ModulateImage</A></H2>
<P>
Method ModulateImage modulates the hue, saturation, and brightness of an
image.

<P>
The format of the ModulateImage routine is:

<P>
<PRE>        ModulateImage(image,modulate)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>modulate:</STRONG><DD>
<P>
A character string indicating the percent change in brightness, saturation,
and hue in floating point notation separated by commas (e.g. 10.1,0.0,3.1).

</DL></DL>
<P>
<HR>
<H2><A NAME="MogrifyImage">MogrifyImage</A></H2>
<P>
Method MogrifyImage applies image processing options to an image as
prescribed by command line options.

<P>
The format of the MogrifyImage routine is:

<P>
<PRE>        MogrifyImage(image_info,argc,argv,image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<DT><STRONG>argc:</STRONG><DD>
<P>
Specifies a pointer to an integer describing the number of elements in the
argument vector.

<DT><STRONG>argv:</STRONG><DD>
<P>
Specifies a pointer to a text array containing the command line arguments.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="MogrifyImages">MogrifyImages</A></H2>
<P>
Method MogrifyImages applies image processing options to a sequence of
images as prescribed by command line options.

<P>
The format of the MogrifyImage routine is:

<P>
<PRE>        MogrifyImages(image_info,argc,argv,images)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<DT><STRONG>argc:</STRONG><DD>
<P>
Specifies a pointer to an integer describing the number of elements in the
argument vector.

<DT><STRONG>argv:</STRONG><DD>
<P>
Specifies a pointer to a text array containing the command line arguments.

<DT><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="MontageImages">MontageImages</A></H2>
<P>
Method MontageImages creates a composite image by combining several
separate images.

<P>
The format of the MontageImages routine is:

<P>
<PRE>        MontageImages(image,montage_info)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
Specifies a pointer to an array of Image structures.

<DT><STRONG>montage_info:</STRONG><DD>
<P>
Specifies a pointer to a XMontageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="MorphImages">MorphImages</A></H2>
<P>
Method MorphImages morphs a set of images. both the image pixels and size
are linearly interpolated to give the appearance of a meta-morphosis from
one image to the next.

<P>
The format of the MorphImage routine is:

<P>
<PRE>        morphed_image=MorphImages(images,number_frames)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>morphed_image:</STRONG><DD>
<P>
Method MorphImages returns an image sequence that has linearly interpolated
pixels and size between two input images.

<DT><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>number_frames:</STRONG><DD>
<P>
This unsigned integer reflects the number of in-between images to generate.
The more in-between frames, the smoother the morph.

</DL></DL>
<P>
<HR>
<H2><A NAME="NegateImage">NegateImage</A></H2>
<P>
Method NegateImage negates the colors in the reference image. The Grayscale
option means that only grayscale values within the image are negated.

<P>
The format of the NegateImage routine is:

<P>
<PRE>        NegateImage(image,grayscale)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="NormalizeImage">NormalizeImage</A></H2>
<P>
Method NormalizeImage normalizes the pixel values to span the full range of
color values. This is a contrast enhancement technique.

<P>
The format of the NormalizeImage routine is:

<P>
<PRE>        NormalizeImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="OpagueImage">OpagueImage</A></H2>
<P>
Method OpaqueImage changes the color of an opaque pixel to the pen color.

<P>
The format of the OpaqueImage routine is:

<P>
<PRE>    OpaqueImage(image,opaque_color,pen_color)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>opaque_color, pen_color:</STRONG><DD>
<P>
A character string that contain an X11 color string.

</DL></DL>
<P>
<HR>
<H2><A NAME="OpenImage">OpenImage</A></H2>
<P>
Method OpenImage open a file associated with the image. A file name of '-'
sets the file to stdin for type 'r' and stdout for type 'w'. If the
filename suffix is '.gz' or '.Z', the image is decompressed for type 'r'
and compressed for type 'w'. If the filename prefix is '|', it is piped to
or from a system command.

<P>
The format of the OpenImage routine is:

<P>
<PRE>        OpenImage(image_info,image,type)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>type:</STRONG><DD>
<P>
'r' for reading; 'w' for writing.

</DL></DL>
<P>
<HR>
<H2><A NAME="ParseImageGeometry">ParseImageGeometry</A></H2>
<P>
Method ParseImageGeometry parse a geometry specification and returns the
width and height values.

<P>
The format of the ParseImageGeometry routine is:

<P>
<PRE>        flags=ParseImageGeometry(image_geometry,x,y,width,height)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>flags:</STRONG><DD>
<P>
Method ParseImageGeometry returns a bitmask that indicates which of the
four values (width, height, xoffset, and yoffset) were actually found in
the string, and whether the x and y values are negative.

<DT><STRONG>image_geometry:</STRONG><DD>
<P>
Specifies a character string representing the geometry specification.

<DT><STRONG>x,y:</STRONG><DD>
<P>
A pointer to an integer. The x and y offset as determined by the geometry
specification is returned here.

<DT><STRONG>width,height:</STRONG><DD>
<P>
A pointer to an unsigned integer. The width and height as determined by the
geometry specification is returned here.

</DL></DL>
<P>
<HR>
<H2><A NAME="PingImage">PingImage</A></H2>
<P>
Method PingImage returns the image size in bytes if it exists and can be
the image is returned as well. Note, only the first image in a multi-frame
image file is pinged.

<P>
The format of the PingImage routine is:

<P>
<PRE>        filesize=PingImage(image_info,columns,rows)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>filesize:</STRONG><DD>
<P>
Method PingImage returns the image size in bytes if the image file exists
and it size can be determined otherwise 0.

<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<DT><STRONG>columns:</STRONG><DD>
<P>
An unsigned integer pointer that specifies the number of columns in the
image.

<DT><STRONG>rows:</STRONG><DD>
<P>
An unsigned integer pointer that specifies the number of rows in the image.

</DL></DL>
<P>
<HR>
<H2><A NAME="RGBTransformImage">RGBTransformImage</A></H2>
<P>
Method RGBTransformImage converts the reference image from RGB to an
alternate colorspace. The transformation matrices are not the standard
ones: the weights are rescaled to normalized the range of the transformed
values to be [0..MaxRGB].

<P>
The format of the RGBTransformImage routine is:

<P>
<PRE>        RGBTransformImage(image,colorspace)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>colorspace:</STRONG><DD>
<P>
An unsigned integer value that indicates which colorspace to transform the
image.

</DL></DL>
<P>
<HR>
<H2><A NAME="RollImage">RollImage</A></H2>
<P>
Method RollImage rolls an image vertically and horizontally. It allocates
the memory necessary for the new Image structure and returns a pointer to
the new image.

<P>
The format of the RollImage routine is:

<P>
<PRE>        rolled_image=RollImage(image,x_offset,y_offset)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>rolled_image:</STRONG><DD>
<P>
Method RollImage returns a pointer to the image after rolling. A null image
is returned if there is a memory shortage.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>x_offset:</STRONG><DD>
<P>
An integer that specifies the number of columns to roll in the horizontal
direction.

<DT><STRONG>y_offset:</STRONG><DD>
<P>
An integer that specifies the number of rows to roll in the vertical
direction.

</DL></DL>
<P>
<HR>
<H2><A NAME="SampleImage">SampleImage</A></H2>
<P>
Method SampleImage creates a new image that is a scaled size of an existing
one using pixel sampling. It allocates the memory necessary for the new
Image structure and returns a pointer to the new image.

<P>
The format of the SampleImage routine is:

<P>
<PRE>        sampled_image=SampleImage(image,columns,rows)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>sampled_image:</STRONG><DD>
<P>
Method SampleImage returns a pointer to the image after scaling. A null
image is returned if there is a memory shortage.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>columns:</STRONG><DD>
<P>
An integer that specifies the number of columns in the sampled image.

<DT><STRONG>rows:</STRONG><DD>
<P>
An integer that specifies the number of rows in the sampled image.

</DL></DL>
<P>
<HR>
<H2><A NAME="ScaleImage">ScaleImage</A></H2>
<P>
Method ScaleImage creates a new image that is a scaled size of an existing
one. It allocates the memory necessary for the new Image structure and
returns a pointer to the new image. To scale a scanline from x pixels to y
pixels, each new pixel represents x/y old pixels. To read x/y pixels, read
(x/y rounded up) pixels but only count the required fraction of the last
old pixel read in your new pixel. The remainder of the old pixel will be
counted in the next new pixel.

<P>
The scaling algorithm was suggested by <A
HREF="mailto:rjohnson@shell.com">rjohnson@shell.com</A> and is adapted from
<CODE>pnmscale(1)</CODE> of PBMPLUS by Jef Poskanzer.

<P>
The format of the ScaleImage routine is:

<P>
<PRE>        scaled_image=ScaleImage(image,columns,rows)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>scaled_image:</STRONG><DD>
<P>
Method ScaleImage returns a pointer to the image after scaling. A null
image is returned if there is a memory shortage.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>columns:</STRONG><DD>
<P>
An integer that specifies the number of columns in the scaled image.

<DT><STRONG>rows:</STRONG><DD>
<P>
An integer that specifies the number of rows in the scaled image.

</DL></DL>
<P>
<HR>
<H2><A NAME="SetImage">SetImage</A></H2>
<P>
Method SetImage initializes the reference image to the background color.

<P>
The format of the SetImage routine is:

<P>
<PRE>        SetImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="SetImageInfo">SetImageInfo</A></H2>
<P>
Method SetImageInfo initializes the `magick' field of the ImageInfo
structure. It is set to a type of image format based on the prefix or
suffix of the filename. For example, `ps:image' returns PS indicating a
Postscript image. JPEG is returned for this filename: `image.jpg'. The
filename prefix has precedance over the suffix. Use an optional index
enclosed in brackets after a file name to specify a desired subimage of a
multi-resolution image format like Photo CD (e.g. img0001.pcd[4]).

<P>
The format of the SetImageInfo routine is:

<P>
<PRE>        SetImageInfo(image_info,rectify)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<DT><STRONG>rectify:</STRONG><DD>
<P>
an unsigned value other than zero rectifies the attribute for multi-frame
support (user may want multi-frame but image format may not support it).

</DL></DL>
<P>
<HR>
<H2><A NAME="SetNumberScenes">SetNumberScenes</A></H2>
<P>
Method SetNumberScenes sets the number of scenes in an image sequence.

<P>
The format of the SetNumberScenes routine is:

<P>
<PRE>        SetNumberScenes(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="SortColormapByIntentsity">SortColormapByIntentsity</A></H2>
<P>
Method SortColormapByIntensity sorts the colormap of a PseudoClass image by
decreasing color intensity.

<P>
The format of the SortColormapByIntensity routine is:

<P>
<PRE>    SortColormapByIntensity(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
A pointer to a Image structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="SteganoImage">SteganoImage</A></H2>
<P>
Method SteganoImage hides a digital watermark within the image.

<P>
The format of the SteganoImage routine is:

<P>
<PRE>        stegano_image=SteganoImage(image,watermark)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>stegano_image:</STRONG><DD>
<P>
Method SteganoImage returns a pointer to the steganographic image with the
watermark hidden. A null image is returned if there is a memory shortage.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>watermark:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="StereoImage">StereoImage</A></H2>
<P>
Method StereoImage combines two images and produces a single image that is
the composite of a left and right image of a stereo pair. The left image is
converted to gray scale and written to the red channel of the stereo image.
The right image is converted to gray scale and written to the blue channel
of the stereo image. View the composite image with red-blue glasses to
create a stereo effect.

<P>
The format of the StereoImage routine is:

<P>
<PRE>        stereo_image=StereoImage(left_image,right_image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>stereo_image:</STRONG><DD>
<P>
Method StereoImage returns a pointer to the stereo image. A null image is
returned if there is a memory shortage.

<DT><STRONG>left_image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>right_image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="SyncImage">SyncImage</A></H2>
<P>
Method SyncImage initializes the red, green, and blue intensities of each
pixel as defined by the colormap index.

<P>
The format of the SyncImage routine is:

<P>
<PRE>        SyncImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="TextureImage">TextureImage</A></H2>
<P>
Method TextureImage layers a texture onto the background of an image.

<P>
The format of the TextureImage routine is:

<P>
<PRE>        TextureImage(image,filename)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>filename:</STRONG><DD>
<P>
This file contains the texture to layer on the background.

</DL></DL>
<P>
<HR>
<H2><A NAME="ThresholdImage">ThresholdImage</A></H2>
<P>
Method ThresholdImage thresholds the reference image.

<P>
The format of the ThresholdImage routine is:

<P>
<PRE>        ThresholdImage(image,threshold)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>threshold:</STRONG><DD>
<P>
A double indicating the threshold value.

</DL></DL>
<P>
<HR>
<H2><A NAME="TransformImage">TransformImage</A></H2>
<P>
Method TransformImage creates a new image that is a transformed size of of
existing one as specified by the crop and image geometries. It allocates
the memory necessary for the new Image structure and returns a pointer to
the new image.

<P>
If a crop geometry is specified a subregion of the image is obtained. If
the specified image size, as defined by the image and scale geometries, is
smaller than the actual image size, the image is first minified to an
integral of the specified image size with an antialias digital filter. The
image is then scaled to the exact specified image size with pixel
replication. If the specified image size is greater than the actual image
size, the image is first enlarged to an integral of the specified image
size with bilinear interpolation. The image is then scaled to the exact
specified image size with pixel replication.

<P>
The format of the TransformImage routine is:

<P>
<PRE>        TransformImage(image,crop_geometry,image_geometry)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of an address of a structure of type Image. The transformed
image is returned as this parameter.

<DT><STRONG>crop_geometry:</STRONG><DD>
<P>
Specifies a pointer to a crop geometry string. This geometry defines a
subregion of the image.

<DT><STRONG>image_geometry:</STRONG><DD>
<P>
Specifies a pointer to a image geometry string. The specified width and
height of this geometry string are absolute.

</DL></DL>
<P>
<HR>
<H2><A NAME="TransformRGBImage">TransformRGBImage</A></H2>
<P>
Method TransformRGBImage converts the reference image from an alternate
colorspace. The transformation matrices are not the standard ones: the
weights are rescaled to normalized the range of the transformed values to
be [0..MaxRGB].

<P>
The format of the TransformRGBImage routine is:

<P>
<PRE>        TransformRGBImage(image,colorspace)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>colorspace:</STRONG><DD>
<P>
An unsigned integer value that indicates the colorspace the image is
currently in. On return the image is in the RGB color space.

</DL></DL>
<P>
<HR>
<H2><A NAME="TransparentImage">TransparentImage</A></H2>
<P>
Method TransparentImage creates a matte image associated with the image.
All pixel locations are initially set to opaque. Any pixel that matches the
specified color are set to transparent.

<P>
The format of the TransparentImage routine is:

<P>
<PRE>        TransparentImage(image,color)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<DT><STRONG>color:</STRONG><DD>
<P>
A character string that contain an X11 color string.

</DL></DL>
<P>
<HR>
<H2><A NAME="UncompressImage">UncompressImage</A></H2>
<P>
Method UncondenseImage uncompresses runlength-encoded pixels packets to a
rectangular array of pixels.

<P>
The format of the UncondenseImage routine is:

<P>
<PRE>    status=UncondenseImage(image)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>status:</STRONG><DD>
<P>
Method UncondenseImage returns True if the image is uncompressed otherwise
False.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="ZoomImage">ZoomImage</A></H2>
<P>
Method ZoomImage creates a new image that is a scaled size of an existing
one. It allocates the memory necessary for the new Image structure and
returns a pointer to the new image. The Point filter gives fast pixel
replication, Triangle is equivalent to bi-linear interpolation, and Mitchel
giver slower, very high-quality results. See Graphic Gems III for details
on this algorithm.

<P>
The format of the ZoomImage routine is:

<P>
<PRE>        zoomed_image=ZoomImage(image,columns,rows)
</PRE>
<P>
A description of each parameter follows:

<DL><DL>
<DT><STRONG>zoomed_image:</STRONG><DD>
<P>
Method ZoomImage returns a pointer to the image after scaling. A null image
is returned if there is a memory shortage.

<DT><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<DT><STRONG>columns:</STRONG><DD>
<P>
An integer that specifies the number of columns in the zoomed image.

<DT><STRONG>rows:</STRONG><DD>
<P>
An integer that specifies the number of rows in the scaled image.

</DL></DL>
</BODY>

</HTML>
