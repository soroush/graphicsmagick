<HTML>
<HEAD>
<TITLE>image - ImageMagick Image Methods</TITLE>
<LINK REV="made" HREF="mailto:magick@wizards.dupont.com">
</HEAD>

<body background="../../images/background.gif">

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#FUNCTION_DESCRIPTIONS">FUNCTION DESCRIPTIONS</A>
	<UL>

		<LI><A HREF="#AllocateImage">AllocateImage</A>
		<LI><A HREF="#AllocateNextImage">AllocateNextImage</A>
		<LI><A HREF="#AnimateImages">AnimateImages</A>
		<LI><A HREF="#AppendImages">AppendImages</A>
		<LI><A HREF="#AverageImages">AverageImages</A>
		<LI><A HREF="#CloneImage">CloneImage</A>
		<LI><A HREF="#CloneImageInfo">CloneImageInfo</A>
		<LI><A HREF="#CommentImage">CommentImage</A>
		<LI><A HREF="#CompositeImage">CompositeImage</A>
		<LI><A HREF="#CondenseImage">CondenseImage</A>
		<LI><A HREF="#CreateImage">CreateImage</A>
		<LI><A HREF="#CycleColormapImage">CycleColormapImage</A>
		<LI><A HREF="#DescribeImage">DescribeImage</A>
		<LI><A HREF="#DestroyImage">DestroyImage</A>
		<LI><A HREF="#DestroyImageInfo">DestroyImageInfo</A>
		<LI><A HREF="#DestroyImages">DestroyImages</A>
		<LI><A HREF="#DisplayImages">DisplayImages</A>
		<LI><A HREF="#GetImageInfo">GetImageInfo</A>
		<LI><A HREF="#GetImageType">GetImageType</A>
		<LI><A HREF="#GetNumberScenes">GetNumberScenes</A>
		<LI><A HREF="#GetPixels">GetPixels</A>
		<LI><A HREF="#IsGeometry">IsGeometry</A>
		<LI><A HREF="#IsGrayImage">IsGrayImage</A>
		<LI><A HREF="#IsSubimage">IsSubimage</A>
		<LI><A HREF="#IsTainted">IsTainted</A>
		<LI><A HREF="#LabelImage">LabelImage</A>
		<LI><A HREF="#LayerImage">LayerImage</A>
		<LI><A HREF="#ListToGroupImage">ListToGroupImage</A>
		<LI><A HREF="#MatteImage">MatteImage</A>
		<LI><A HREF="#MogrifyImage">MogrifyImage</A>
		<LI><A HREF="#MogrifyImages">MogrifyImages</A>
		<LI><A HREF="#ParseImageGeometry">ParseImageGeometry</A>
		<LI><A HREF="#PingImage">PingImage</A>
		<LI><A HREF="#ReadImage">ReadImage</A>
		<LI><A HREF="#ReadImages">ReadImages</A>
		<LI><A HREF="#RGBTransformImage">RGBTransformImage</A>
		<LI><A HREF="#SetImage">SetImage</A>
		<LI><A HREF="#SetImageInfo">SetImageInfo</A>
		<LI><A HREF="#SortColormapByIntentsity">SortColormapByIntentsity</A>
		<LI><A HREF="#SyncImage">SyncImage</A>
		<LI><A HREF="#TextureImage">TextureImage</A>
		<LI><A HREF="#TransformImage">TransformImage</A>
		<LI><A HREF="#TransformRGBImage">TransformRGBImage</A>
		<LI><A HREF="#TransparentImage">TransparentImage</A>
		<LI><A HREF="#UncondenseImage">UncondenseImage</A>
		<LI><A HREF="#WriteImage">WriteImage</A>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
image - ImageMagick Image Methods

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
Image* <STRONG>AllocateImage</STRONG>(constImageInfo*image_info)

<P>
void <STRONG>AllocateNextImage</STRONG>(constImageInfo*image_info,Image*image)

<P>
unsigned int <STRONG>AnimateImages</STRONG>(constImageInfo*image_info,Image*image)

<P>
Image* <STRONG>AppendImages</STRONG>(Image*images,constunsigned intstack)

<P>
Image* <STRONG>AverageImages</STRONG>(constImage*images)

<P>
ImageInfo* <STRONG>CloneImageInfo</STRONG>(constImageInfo*image_info)

<P>
void <STRONG>CommentImage</STRONG>(Image*image,constchar*comments)

<P>
void <STRONG>CondenseImage</STRONG>(Image*image)

<P>
<PRE> B&lt;CycleColormapImage&gt;(image,amount)
</PRE>
<P>
void <STRONG>DescribeImage</STRONG>(Image*image,FILE*file,constunsigned intverbose)

<P>
void <STRONG>DestroyImage</STRONG>(Image*image)

<P>
void <STRONG>DestroyImageInfo</STRONG>(ImageInfo*image_info)

<P>
void <STRONG>DestroyImages</STRONG>(Image*image)

<P>
unsigned int <STRONG>DisplayImages</STRONG>(constImageInfo*image_info,Image*image)

<P>
void <STRONG>GetImageInfo</STRONG>(ImageInfo*image_info)

<P>
ImageType <STRONG>GetImageType</STRONG>(Image*image)

<P>
unsigned int <STRONG>GetNumberScenes</STRONG>(constImage*image)

<P>
unsigned int <STRONG>IsGeometry</STRONG>(constchar*geometry)

<P>
unsigned int <STRONG>IsGrayImage</STRONG>(Image*image)

<P>
unsigned int <STRONG>IsSubimage</STRONG>(constchar*geometry,constunsigned intpedantic)

<P>
unsigned int <STRONG>IsTainted</STRONG>(constImage*image)

<P>
void <STRONG>LabelImage</STRONG>(Image*image,constchar*label)

<P>
void <STRONG>LayerImage</STRONG>(Image*image,constLayerTypelayer)

<P>
Image** <STRONG>ListToGroupImage</STRONG>(constImage*image,unsigned int*number_images)

<P>
void <STRONG>MatteImage</STRONG>(Image*image)

<P>
Image* <STRONG>PingImage</STRONG>(constImageInfo*image_info)

<P>
void <STRONG>RGBTransformImage</STRONG>(Image*image,constColorspaceTypecolorspace)

<P>
Image* <STRONG>ReadImage</STRONG>(ImageInfo*image_info)

<P>
Image* <STRONG>ReadImages</STRONG>(ImageInfo*image_info)

<P>
void <STRONG>SetImage</STRONG>(Image*image)

<P>
void <STRONG>SetImageInfo</STRONG>(ImageInfo*image_info,constunsigned intrectify)

<P>
void <STRONG>SyncImage</STRONG>(Image*image)

<P>
void <STRONG>TextureImage</STRONG>(Image*image,Image*texture)

<P>
void <STRONG>TransformRGBImage</STRONG>(Image*image,constColorspaceTypecolorspace)

<P>
void <STRONG>TransparentImage</STRONG>(Image*image,constchar*color)

<P>
unsigned int <STRONG>UncondenseImage</STRONG>(Image*image)

<P>
unsigned int <STRONG>WriteImage</STRONG>(constImageInfo*image_info,Image*image)

<P>
<HR>
<H1><A NAME="FUNCTION_DESCRIPTIONS">FUNCTION DESCRIPTIONS</A></H1>
<P>
<HR>
<H2><A NAME="AllocateImage">AllocateImage</A></H2>
<P>
Method AllocateImage allocates an Image structure and initializes each
field to a default value.

<P>
The format of the AllocateImage method is:

<P>
<PRE>        Image *AllocateImage(const ImageInfo *image_info)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG><A NAME="item_o">allocated_image:</A></STRONG><DD>
<P>
Method AllocateImage returns a pointer to an image structure initialized to default values. 
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.


<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="AllocateNextImage">AllocateNextImage</A></H2>
<P>
Method AllocateNextImage allocates an Image structure and initializes each
field to a default value.

<P>
The format of the AllocateNextImage method is:

<P>
<PRE>        void AllocateNextImage(const ImageInfo *image_info,Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="AnimateImages">AnimateImages</A></H2>
<P>
Method AnimateImages displays one or more images to an 
<FONT SIZE=-1>X</FONT> window.

<P>
The format of the AllocateNextImage method is:

<P>
<PRE>        unsigned int AnimateImages(const ImageInfo *image_info,Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method DisplayImages returns True if the images are displayed in an 
<FONT SIZE=-1>X</FONT> window, otherwise False is returned.

<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="AppendImages">AppendImages</A></H2>
<P>
Method AppendImages appends a set of images. All the input images must have
the same width or height. Images of the same width are stacked
top-to-bottom. Images of the same height are stacked left-to-right. If
stack is false, rectangular images are stacked left-to-right otherwise
top-to-bottom.

<P>
The format of the AppendImage method is:

<P>
<PRE>        Image *AppendImages(Image *images,const unsigned int stack)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>stack:</STRONG><DD>
<P>
An unsigned value other than stacks rectangular images top-to-bottom
otherwise left-to-right.

</DL></DL>
<P>
<HR>
<H2><A NAME="AverageImages">AverageImages</A></H2>
<P>
Method AverageImages averages a set of images. All the input images must be
the same size in pixels.

<P>
The format of the AverageImage method is:

<P>
<PRE>        Image *AverageImages(const Image *images)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>averaged_image:</STRONG><DD>
<P>
Method AverageImages returns the mean pixel value for an image sequence.

<p><dt><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="CloneImage">CloneImage</A></H2>
<P>
Method CloneImage returns a copy of all fields of the input image. The the
pixel memory is allocated but the pixel data is not copied.

<P>
The format of the CloneImage method is:

<P>
<PRE>    Image *CloneImage(const Image *image,const unsigned int columns,
      const unsigned int rows,const unsigned int clone_pixels)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>clone_image:</STRONG><DD>
<P>
Method CloneImage returns a pointer to the image after copying. 
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory
shortage.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<p><dt><STRONG>columns:</STRONG><DD>
<P>
An integer that specifies the number of columns in the copied image.

<p><dt><STRONG>rows:</STRONG><DD>
<P>
An integer that specifies the number of rows in the copied image.

<p><dt><STRONG>clone_pixels:</STRONG><DD>
<P>
Specifies whether the pixel data is copied. Must be either True or False;

</DL></DL>
<P>
<HR>
<H2><A NAME="CloneImageInfo">CloneImageInfo</A></H2>
<P>
Method CloneImageInfo makes a duplicate of the given image info, or if image info is 
<FONT SIZE=-1>NULL,</FONT> a new one.


<P>
The format of the CloneImageInfo method is:

<P>
<PRE>        ImageInfo *CloneImageInfo(const ImageInfo *image_info)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>cloned_info:</STRONG><DD>
<P>
Method CloneImageInfo returns a duplicate of the given image info, or if image info is 
<FONT SIZE=-1>NULL</FONT> a new one.


<p><dt><STRONG>image_info:</STRONG><DD>
<P>
a structure of type info.

</DL></DL>
<P>
<HR>
<H2><A NAME="CommentImage">CommentImage</A></H2>
<P>
Method CommentImage initializes an image comment. Optionally the comment
can include the image filename, type, width, height, or scene number by
embedding special format characters.

<P>
The format of the CommentImage method is:

<P>
<PRE>        void CommentImage(Image *image,const char *comments)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<p><dt><STRONG>comments:</STRONG><DD>
<P>
The address of a character string containing the comment format.

</DL></DL>
<P>
<HR>
<H2><A NAME="CompositeImage">CompositeImage</A></H2>
<P>
Method CompositeImage returns the second image composited onto the first at
the specified offsets.

<P>
The format of the CompositeImage method is:

<P>
<PRE>    void CompositeImage(Image *image,const CompositeOperator compose,
      Image *composite_image,const int x_offset,const int y_offset)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<p><dt><STRONG>compose:</STRONG><DD>
<P>
Specifies an image composite operator.

<p><dt><STRONG>composite_image:</STRONG><DD>
<P>
The address of a structure of type Image.

<p><dt><STRONG>x_offset:</STRONG><DD>
<P>
An integer that specifies the column offset of the composited image.

<p><dt><STRONG>y_offset:</STRONG><DD>
<P>
An integer that specifies the row offset of the composited image.

</DL></DL>
<P>
<HR>
<H2><A NAME="CondenseImage">CondenseImage</A></H2>
<P>
Method CondenseImage compresses an image to the minimum number of
runlength-encoded packets.

<P>
The format of the CondenseImage method is:

<P>
<PRE>        void CondenseImage(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="CreateImage">CreateImage</A></H2>
<P>
Method CreateImage creates an image from the specified normalized pixel
data and returns it. It allocates the memory necessary for the new Image
structure and returns a pointer to the new image.

<P>
The format of the CreateImage method is:

<P>
<PRE>    void CycleColormapImage(Image *image,const int amount)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
Method CreateImage returns a pointer to the image after reading. 
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage
or if the image cannot be read.

<p><dt><STRONG>width:</STRONG><DD>
<P>
Specifies the width in pixels of the image.

<p><dt><STRONG>height:</STRONG><DD>
<P>
Specifies the height in pixels of the image.

<p><dt><STRONG>red,green,blue,opacity:</STRONG><DD>
<P>
This array of normalized float values [0..1] contain the red, green, blue, and opacity components of the pixel data. The length of the arrays must equal the area specified by the width and height values. If you do not want to initialize a particular component, specify it as 
<FONT SIZE=-1>NULL.</FONT>


</DL></DL>
<P>
<HR>
<H2><A NAME="CycleColormapImage">CycleColormapImage</A></H2>
<P>
Method CycleColormapImage cycles the image colormap by a specified amount.

<P>
The format of the CycleColormapImage method is:

<P>
<PRE>        CycleColormapImage(image,amount)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>amount:</STRONG><DD>
<P>
An unsigned value that specifies the offset of the colormap.

</DL></DL>
<P>
<HR>
<H2><A NAME="DescribeImage">DescribeImage</A></H2>
<P>
Method DescribeImage describes an image by printing its attributes to
stdout.

<P>
The format of the DescribeImage method is:

<P>
<PRE>        void DescribeImage(Image *image,FILE *file,const unsigned int verbose)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<p><dt><STRONG>file:</STRONG><DD>
<P>
send the image attributes to this file.

<p><dt><STRONG>verbose:</STRONG><DD>
<P>
an unsigned value other than zero prints detailed information about the
image.

</DL></DL>
<P>
<HR>
<H2><A NAME="DestroyImage">DestroyImage</A></H2>
<P>
Method DestroyImage deallocates memory associated with an image.

<P>
The format of the DestroyImage method is:

<P>
<PRE>        void DestroyImage(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="DestroyImageInfo">DestroyImageInfo</A></H2>
<P>
Method DestroyImageInfo deallocates memory associated with an ImageInfo
structure.

<P>
The format of the DestroyImageInfo method is:

<P>
<PRE>        void DestroyImageInfo(ImageInfo *image_info)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="DestroyImages">DestroyImages</A></H2>
<P>
Method DestroyImages deallocates memory associated with a linked list of
images.

<P>
The format of the DestroyImages method is:

<P>
<PRE>        void DestroyImages(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="DisplayImages">DisplayImages</A></H2>
<P>
Method DisplayImages displays one or more images to an 
<FONT SIZE=-1>X</FONT> window.

<P>
The format of the AllocateNextImage method is:

<P>
<PRE>        unsigned int DisplayImages(const ImageInfo *image_info,Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method DisplayImages returns True if the images are displayed in an 
<FONT SIZE=-1>X</FONT> window, otherwise False is returned.

<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetImageInfo">GetImageInfo</A></H2>
<P>
Method GetImageInfo initializes the ImageInfo structure.

<P>
The format of the GetImageInfo method is:

<P>
<PRE>        void GetImageInfo(ImageInfo *image_info)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetImageType">GetImageType</A></H2>
<P>
Method GetImageType returns the type of image (e.g. bilevel, palette, etc).

<P>
The format of the GetImageType method is:

<P>
<PRE>        ImageType GetImageType(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>type:</STRONG><DD>
<P>
Method GetImageType returns a ImageType enum that specifies the type of the
specified image (e.g. bilevel, palette, etc).

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetNumberScenes">GetNumberScenes</A></H2>
<P>
Method GetNumberScenes returns the number of scenes in an image sequence.

<P>
The format of the GetNumberScenes method is:

<P>
<PRE>        unsigned int GetNumberScenes(const Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>scenes:</STRONG><DD>
<P>
Method GetNumberScenes returns the number of scenes in an image sequence.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="GetPixels">GetPixels</A></H2>
<P>
Method GetPixels returns the pixel data of an image as normalized red,
green, blue, and opacity values.

<P>
The format of the GetPixels method is:

<P>
<PRE>    unsigned int IsGeometry(const char *geometry)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
Specifies a pointer to a Image structure; returned from ReadImage.

<p><dt><STRONG>red_pixels,green_pixels,blue_pixels,opacity_pixels:</STRONG><DD>
<P>
These arrays are returned with the correpondingred, green, blue, and opacity values from the image. The length of the arrays must equal the area specified by the columns and row values values of the Image structure. If you do not want to initialize a particular component, specify it as 
<FONT SIZE=-1>NULL.</FONT>


</DL></DL>
<P>
<HR>
<H2><A NAME="IsGeometry">IsGeometry</A></H2>
<P>
Method IsGeometry returns True if the geometry specification is valid as
determined by ParseGeometry.

<P>
The format of the IsGeometry method is:

<P>
<PRE>        unsigned int IsGeometry(const char *geometry)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method IsGeometry returns True if the geometry specification is valid
otherwise False is returned.

<p><dt><STRONG>geometry:</STRONG><DD>
<P>
This string is the geometry specification.

</DL></DL>
<P>
<HR>
<H2><A NAME="IsGrayImage">IsGrayImage</A></H2>
<P>
Method IsGrayImage returns True if the image is grayscale otherwise False
is returned. If the image is DirectClass and grayscale, it is demoted to
PseudoClass.

<P>
The format of the IsGrayImage method is:

<P>
<PRE>        unsigned int IsGrayImage(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method IsGrayImage returns True if the image is grayscale otherwise False
is returned.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="IsSubimage">IsSubimage</A></H2>
<P>
Method IsSubimage returns True if the geometry is a valid subimage
specification (e.g. [1], [1-9], [1,7,4]).

<P>
The format of the IsSubimage method is:

<P>
<PRE>        unsigned int IsSubimage(const char *geometry,const unsigned int pedantic)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method IsSubimage returns True if the geometry is a valid subimage
specification otherwise False is returned.

<p><dt><STRONG>geometry:</STRONG><DD>
<P>
This string is the geometry specification.

<p><dt><STRONG>pedantic:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> value other than 0 invokes a more restriction set of
conditions for a valid specification (e.g. [1], [1-4], [4-1]).

</DL></DL>
<P>
<HR>
<H2><A NAME="IsTainted">IsTainted</A></H2>
<P>
Method IsTainted returns True if the image has been altered since it was
first read or if any image in the sequence has a difference magic or
filename.

<P>
The format of the IsTainted method is:

<P>
<PRE>        unsigned int IsTainted(const Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method IsTainted returns True if the image has been altered since it was
first read.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="LabelImage">LabelImage</A></H2>
<P>
Method LabelImage initializes an image label. Optionally the label can
include the image filename, type, width, height, or scene number by
embedding special format characters.

<P>
The format of the LabelImage method is:

<P>
<PRE>        void LabelImage(Image *image,const char *label)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

<p><dt><STRONG>label:</STRONG><DD>
<P>
The address of a character string containing the label format.

</DL></DL>
<P>
<HR>
<H2><A NAME="LayerImage">LayerImage</A></H2>
<P>
Method LayerImage extracts the specified layer from the references image.

<P>
The format of the LayerImage method is:

<P>
<PRE>        void LayerImage(Image *image,const LayerType layer)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>layer:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> value of type LayerType that identifies which layer
to extract.

</DL></DL>
<P>
<HR>
<H2><A NAME="ListToGroupImage">ListToGroupImage</A></H2>
<P>
Method ListToGroupImage converts a linked list of images to a sequential
array.

<P>
The format of the ListToGroupImage method is:

<P>
<PRE>        Image **ListToGroupImage(const Image *image,unsigned int *number_images)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>images:</STRONG><DD>
<P>
Method ListToGroupImage converts a linked list of images to a sequential
array and returns the array..

<p><dt><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>number_images:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to an unsigned integer. The number of images
in the image array is returned here.

</DL></DL>
<P>
<HR>
<H2><A NAME="MatteImage">MatteImage</A></H2>
<P>
Method MatteImage initializes the matte channel of the reference image to
opaque.

<P>
The format of the MatteImage method is:

<P>
<PRE>        void MatteImage(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="MogrifyImage">MogrifyImage</A></H2>
<P>
Method MogrifyImage applies image processing options to an image as
prescribed by command line options.

<P>
The format of the MogrifyImage method is:

<P>
<PRE>    void MogrifyImage(const ImageInfo *image_info,const int argc,char **argv,
      Image **image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>argc:</STRONG><DD>
<P>
Specifies a pointer to an integer describing the number of elements in the
argument vector.

<p><dt><STRONG>argv:</STRONG><DD>
<P>
Specifies a pointer to a text array containing the command line arguments.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="MogrifyImages">MogrifyImages</A></H2>
<P>
Method MogrifyImages applies image processing options to a sequence of
images as prescribed by command line options.

<P>
The format of the MogrifyImage method is:

<P>
<PRE>    void MogrifyImages(const ImageInfo *image_info,const int argc,
      char **argv,Image **images)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>argc:</STRONG><DD>
<P>
Specifies a pointer to an integer describing the number of elements in the
argument vector.

<p><dt><STRONG>argv:</STRONG><DD>
<P>
Specifies a pointer to a text array containing the command line arguments.

<p><dt><STRONG>images:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="ParseImageGeometry">ParseImageGeometry</A></H2>
<P>
Method ParseImageGeometry parses a geometry specification and returns the
width, height, x, and y values. It also returns flags that indicates which
of the four values (width, height, xoffset, yoffset) were located in the
string, and whether the x and y values are negative. In addition,

<P>
The format of the ParseImageGeometry method is:

<P>
<PRE>    int ParseImageGeometry(const char *geometry,int *x,int *y,
      unsigned int *width,unsigned int *height)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>flags:</STRONG><DD>
<P>
Method ParseImageGeometry returns a bitmask that indicates which of the
four values were located in the geometry string.

<p><dt><STRONG>image_geometry:</STRONG><DD>
<P>
Specifies a character string representing the geometry specification.

<p><dt><STRONG>x,y:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to an integer. The x and y offset as
determined by the geometry specification is returned here.

<p><dt><STRONG>width,height:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to an unsigned integer. The width and height
as determined by the geometry specification is returned here.

</DL></DL>
<P>
<HR>
<H2><A NAME="PingImage">PingImage</A></H2>
<P>
Method PingImage returns the image size in bytes if it exists and can be
the image is returned as well. Note, only the first image in a multi-frame
image file is pinged.

<P>
The format of the PingImage method is:

<P>
<PRE>        Image *PingImage(const ImageInfo *image_info)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>Image:</STRONG><DD>
<P>
Method PingImage returns the image size in bytes if the image file exists
and it size can be determined otherwise 0.

<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="ReadImage">ReadImage</A></H2>
<P>
Method ReadImage reads an image and returns it. It allocates the memory
necessary for the new Image structure and returns a pointer to the new
image. By default, the image format is determined by its magic number. To
specify a particular image format, precede the filename with an explicit
image format name and a colon (i.e. ps:image) or as the filename suffix
(i.e. image.ps).

<P>
The format of the ReadImage method is:

<P>
<PRE>        Image *ReadImage(ImageInfo *image_info)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
Method ReadImage returns a pointer to the image after reading. 
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage
or if the image cannot be read.

<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="ReadImages">ReadImages</A></H2>
<P>
Method ReadImages reads a list of image names from a file and then returns
the images as a linked list.

<P>
The format of the ReadImage method is:

<P>
<PRE>        Image *ReadImages(ImageInfo *image_info)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
Method ReadImage returns a pointer to the image after reading. 
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage
or if the image cannot be read.

<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="RGBTransformImage">RGBTransformImage</A></H2>
<P>
Method RGBTransformImage converts the reference image from 
<FONT SIZE=-1>RGB</FONT> to an alternate colorspace. The transformation
matrices are not the standard ones: the weights are rescaled to normalized
the range of the transformed values to be [0..MaxRGB].

<P>
The format of the RGBTransformImage method is:

<P>
<PRE>        void RGBTransformImage(Image *image,const ColorspaceType colorspace)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>colorspace:</STRONG><DD>
<P>
An unsigned integer value that indicates which colorspace to transform the
image.

</DL></DL>
<P>
<HR>
<H2><A NAME="SetImage">SetImage</A></H2>
<P>
Method SetImage initializes the reference image to the background color.

<P>
The format of the SetImage method is:

<P>
<PRE>        void SetImage(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

</DL></DL>
<P>
<HR>
<H2><A NAME="SetImageInfo">SetImageInfo</A></H2>
<P>
Method SetImageInfo initializes the `magick' field of the ImageInfo structure. It is set to a type of image format based on the prefix or suffix of the filename. For example, `ps:image' returns 
<FONT SIZE=-1>PS</FONT> indicating a Postscript image. 
<FONT SIZE=-1>JPEG</FONT> is returned for this filename: `image.jpg'. The filename prefix has precendence over the suffix. Use an optional index enclosed in brackets after a file name to specify a desired subimage of a multi-resolution image format like Photo 
<FONT SIZE=-1>CD</FONT> (e.g. img0001.pcd[4]).


<P>
The format of the SetImageInfo method is:

<P>
<PRE>        void SetImageInfo(ImageInfo *image_info,const unsigned int rectify)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>rectify:</STRONG><DD>
<P>
an unsigned value other than zero rectifies the attribute for multi-frame
support (user may want multi-frame but image format may not support it).

</DL></DL>
<P>
<HR>
<H2><A NAME="SortColormapByIntentsity">SortColormapByIntentsity</A></H2>
<P>
Method SortColormapByIntensity sorts the colormap of a PseudoClass image by
decreasing color intensity.

<P>
The format of the SortColormapByIntensity method is:

<P>
<PRE>    void SortColormapByIntensity(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to a Image structure.

</DL></DL>
<P>
<HR>
<H2><A NAME="SyncImage">SyncImage</A></H2>
<P>
Method SyncImage initializes the red, green, and blue intensities of each
pixel as defined by the colormap index.

<P>
The format of the SyncImage method is:

<P>
<PRE>        void SyncImage(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="TextureImage">TextureImage</A></H2>
<P>
Method TextureImage layers a texture onto the background of an image.

<P>
The format of the TextureImage method is:

<P>
<PRE>        void TextureImage(Image *image,Image *texture)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>texture:</STRONG><DD>
<P>
This image contains the texture to layer on the background.

</DL></DL>
<P>
<HR>
<H2><A NAME="TransformImage">TransformImage</A></H2>
<P>
Method TransformImage creates a new image that is a transformed size of of
existing one as specified by the crop and image geometries. It allocates
the memory necessary for the new Image structure and returns a pointer to
the new image.

<P>
If a crop geometry is specified a subregion of the image is obtained. If
the specified image size, as defined by the image and scale geometries, is
smaller than the actual image size, the image is first minified to an
integral of the specified image size with an antialias digital filter. The
image is then scaled to the exact specified image size with pixel
replication. If the specified image size is greater than the actual image
size, the image is first enlarged to an integral of the specified image
size with bilinear interpolation. The image is then scaled to the exact
specified image size with pixel replication.

<P>
The format of the TransformImage method is:

<P>
<PRE>    void TransformImage(Image **image,const char *crop_geometry,
      const char *image_geometry)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of an address of a structure of type Image. The transformed
image is returned as this parameter.

<p><dt><STRONG>crop_geometry:</STRONG><DD>
<P>
Specifies a pointer to a crop geometry string. This geometry defines a
subregion of the image.

<p><dt><STRONG>image_geometry:</STRONG><DD>
<P>
Specifies a pointer to a image geometry string. The specified width and
height of this geometry string are absolute.

</DL></DL>
<P>
<HR>
<H2><A NAME="TransformRGBImage">TransformRGBImage</A></H2>
<P>
Method TransformRGBImage converts the reference image from an alternate
colorspace. The transformation matrices are not the standard ones: the
weights are rescaled to normalized the range of the transformed values to
be [0..MaxRGB].

<P>
The format of the TransformRGBImage method is:

<P>
<PRE>        void TransformRGBImage(Image *image,const ColorspaceType colorspace)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>colorspace:</STRONG><DD>
<P>
An unsigned integer value that indicates the colorspace the image is currently in. On return the image is in the 
<FONT SIZE=-1>RGB</FONT> color space.


</DL></DL>
<P>
<HR>
<H2><A NAME="TransparentImage">TransparentImage</A></H2>
<P>
Method TransparentImage creates a matte image associated with the image.
All pixel locations are initially set to opaque. Any pixel that matches the
specified color are set to transparent.

<P>
The format of the TransparentImage method is:

<P>
<PRE>        void TransparentImage(Image *image,const char *color)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image; returned from ReadImage.

<p><dt><STRONG>color:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> character string that contain an 
<FONT SIZE=-1>X11</FONT> color string.


</DL></DL>
<P>
<HR>
<H2><A NAME="UncondenseImage">UncondenseImage</A></H2>
<P>
Method UncondenseImage uncompresses runlength-encoded pixels packets to a
rectangular array of pixels.

<P>
The format of the UncondenseImage method is:

<P>
<PRE>        unsigned int UncondenseImage(Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method UncondenseImage returns True if the image is uncompressed otherwise
False.

<p><dt><STRONG>image:</STRONG><DD>
<P>
The address of a structure of type Image.

</DL></DL>
<P>
<HR>
<H2><A NAME="WriteImage">WriteImage</A></H2>
<P>
Method WriteImage writes an image to a file as defined by image-&gt;filename. You can specify a particular image format by prefixing the file with the image type and a colon (i.e. ps:image) or specify the image type as the filename suffix (i.e. image.ps). The image may be modified to adapt it to the requirements of the image format. For example, DirectClass images must be color-reduced to PseudoClass if the format is 
<FONT SIZE=-1>GIF.</FONT>


<P>
The format of the WriteImage method is:

<P>
<PRE>        unsigned int WriteImage(const ImageInfo *image_info,Image *image)
</PRE>
<P>

<FONT SIZE=-1>A</FONT> description of each parameter follows:

<DL><DL>
<p><dt><STRONG>status:</STRONG><DD>
<P>
Method WriteImage return True if the image is written. False is returned is
there is a memory shortage or if the image file fails to write.

<p><dt><STRONG>image_info:</STRONG><DD>
<P>
Specifies a pointer to an ImageInfo structure.

<p><dt><STRONG>image:</STRONG><DD>
<P>

<FONT SIZE=-1>A</FONT> pointer to a Image structure.

</DL></DL>
</BODY>

</HTML>
