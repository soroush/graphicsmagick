<HTML>
<HEAD>
<TITLE>image - ImageMagick Image Methods</TITLE>
<LINK REV="made" HREF="mailto:ActivePerl@ActiveState.com">
</HEAD>

<body bgcolor="#FFFFFF" text="#000000" link="#1F00FF" alink="#FF0000"  vlink="#9900DD">

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">
<FONT SIZE=-1>NAME</FONT></A></LI>
	<LI><A HREF="#synopsis">
<FONT SIZE=-1>SYNOPSIS</FONT></A></LI>
	<LI><A HREF="#function descriptions">
<FONT SIZE=-1>FUNCTION</FONT> 
<FONT SIZE=-1>DESCRIPTIONS</FONT></A></LI>
	<UL>

		<LI><A HREF="#allocateimage">AllocateImage</A></LI>
		<LI><A HREF="#allocateimagecolormap">AllocateImageColormap</A></LI>
		<LI><A HREF="#allocatenextimage">AllocateNextImage</A></LI>
		<LI><A HREF="#animateimages">AnimateImages</A></LI>
		<LI><A HREF="#appendimages">AppendImages</A></LI>
		<LI><A HREF="#averageimages">AverageImages</A></LI>
		<LI><A HREF="#channelimage">ChannelImage</A></LI>
		<LI><A HREF="#cloneimage">CloneImage</A></LI>
		<LI><A HREF="#cloneimageinfo">CloneImageInfo</A></LI>
		<LI><A HREF="#compositeimage">CompositeImage</A></LI>
		<LI><A HREF="#cyclecolormapimage">CycleColormapImage</A></LI>
		<LI><A HREF="#describeimage">DescribeImage</A></LI>
		<LI><A HREF="#destroyimage">DestroyImage</A></LI>
		<LI><A HREF="#destroyimageinfo">DestroyImageInfo</A></LI>
		<LI><A HREF="#destroyimages">DestroyImages</A></LI>
		<LI><A HREF="#displayimages">DisplayImages</A></LI>
		<LI><A HREF="#getimagedepth">GetImageDepth</A></LI>
		<LI><A HREF="#getimageinfo">GetImageInfo</A></LI>
		<LI><A HREF="#getimagetype">GetImageType</A></LI>
		<LI><A HREF="#getnextimage">GetNextImage</A></LI>
		<LI><A HREF="#getnumberscenes">GetNumberScenes</A></LI>
		<LI><A HREF="#getpixelpacket">GetPixelPacket</A></LI>
		<LI><A HREF="#isgeometry">IsGeometry</A></LI>
		<LI><A HREF="#isimagesequal">IsImagesEqual</A></LI>
		<LI><A HREF="#isimagetainted">IsImageTainted</A></LI>
		<LI><A HREF="#issubimage">IsSubimage</A></LI>
		<LI><A HREF="#listtogroupimage">ListToGroupImage</A></LI>
		<LI><A HREF="#mogrifyimage">MogrifyImage</A></LI>
		<LI><A HREF="#mogrifyimages">MogrifyImages</A></LI>
		<LI><A HREF="#mosaicimages">MosaicImages</A></LI>
		<LI><A HREF="#parseimagegeometry">ParseImageGeometry</A></LI>
		<LI><A HREF="#rgbtransformimage">RGBTransformImage</A></LI>
		<LI><A HREF="#setimage">SetImage</A></LI>
		<LI><A HREF="#setimagedepth">SetImageDepth</A></LI>
		<LI><A HREF="#setimageopacity">SetImageOpacity</A></LI>
		<LI><A HREF="#setimagetype">SetImageType</A></LI>
		<LI><A HREF="#sortcolormapbyintentsity">SortColormapByIntentsity</A></LI>
		<LI><A HREF="#syncimage">SyncImage</A></LI>
		<LI><A HREF="#textureimage">TextureImage</A></LI>
		<LI><A HREF="#transformrgbimage">TransformRGBImage</A></LI>
		<LI><A HREF="#transmitimage">TransmitImage</A></LI>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">
<FONT SIZE=-1>NAME</FONT></A></H1>
<P>image - ImageMagick Image Methods</P>
<P>
<HR>
<H1><A NAME="synopsis">
<FONT SIZE=-1>SYNOPSIS</FONT></A></H1>
<P>Image * <STRONG>AllocateImage</STRONG>( const ImageInfo *image_info );</P>
<P>unsigned int  <STRONG>AllocateImageColormap</STRONG>( Image *image, const unsigned int colors );</P>
<P>void  <STRONG>AllocateNextImage</STRONG>( const ImageInfo *image_info, Image *image );</P>
<P>unsigned int  <STRONG>AnimateImages</STRONG>( const ImageInfo *image_info, Image *image );</P>
<P>Image * <STRONG>AppendImages</STRONG>( Image *image, const unsigned int stack, ExceptionInfo *exception );</P>
<P>Image * <STRONG>AverageImages</STRONG>( const Image *image, ExceptionInfo *exception );</P>
<P>unsigned int  <STRONG>ChannelImage</STRONG>( Image *image, const ChannelType channel );</P>
<P>Image * <STRONG>CloneImage</STRONG>( Image *image, const unsigned int columns, const unsigned int rows, const unsigned int orphan, ExceptionInfo *exception );</P>
<P>ImageInfo * <STRONG>CloneImageInfo</STRONG>( const ImageInfo *image_info );</P>
<P>unsigned int  <STRONG>CompositeImage</STRONG>( Image *image, const CompositeOperator compose, Image *composite_image, const int x_offset, const int y_offset );</P>
<P><STRONG>CycleColormapImage</STRONG>( Image *image, const int amount );</P>
<P>void  <STRONG>DescribeImage</STRONG>( Image *image, 
<FONT SIZE=-1>FILE</FONT> *file, const unsigned int verbose );</P>
<P>void  <STRONG>DestroyImage</STRONG>( Image *image );</P>
<P>void  <STRONG>DestroyImageInfo</STRONG>( ImageInfo *image_info );</P>
<P>void  <STRONG>DestroyImages</STRONG>( Image *image );</P>
<P>unsigned int  <STRONG>DisplayImages</STRONG>( const ImageInfo *image_info, Image *image );</P>
<P>unsigned int  <STRONG>GetImageDepth</STRONG>( Image *image );</P>
<P>void  <STRONG>GetImageInfo</STRONG>( ImageInfo *image_info );</P>
<P>ImageType  <STRONG>GetImageType</STRONG>( Image *image );</P>
<P>Image * <STRONG>GetNextImage</STRONG>( Image *image );</P>
<P>unsigned int  <STRONG>GetNumberScenes</STRONG>( const Image *image );</P>
<P>void  <STRONG>GetPixelPacket</STRONG>( PixelPacket *pixel );</P>
<P>unsigned int  <STRONG>IsGeometry</STRONG>( const char *geometry );</P>
<P>unsigned int  <STRONG>IsImageTainted</STRONG>( const Image *image );</P>
<P>unsigned int  <STRONG>IsImagesEqual</STRONG>( Image *image, Image *reference );</P>
<P>unsigned int  <STRONG>IsSubimage</STRONG>( const char *geometry, const unsigned int pedantic );</P>
<P>Image **  <STRONG>ListToGroupImage</STRONG>( Image *image, unsigned int *number_images );</P>
<P>unsigned int  <STRONG>MogrifyImage</STRONG>( const ImageInfo *image_info, const int argc, char ** argv, Image ** image );</P>
<P>unsigned int  <STRONG>MogrifyImages</STRONG>( const ImageInfo *image_info, const int argc, char ** argv, Image ** images );</P>
<P>Image * <STRONG>MosaicImages</STRONG>( const Image *image, ExceptionInfo *exception );</P>
<P>int  <STRONG>ParseImageGeometry</STRONG>( const char *geometry, int *x, int *y, unsigned int *width, unsigned int *height );</P>
<P>unsigned int  <STRONG>RGBTransformImage</STRONG>( Image *image, const ColorspaceType colorspace );</P>
<P>void  <STRONG>SetImage</STRONG>( Image *image, opacity );</P>
<P>unsigned int  <STRONG>SetImageDepth</STRONG>( Image *image, const unsigned int );</P>
<P>void  <STRONG>SetImageOpacity</STRONG>( Image *image, const unsigned int opacity );</P>
<P><STRONG>SetImageType</STRONG>( Image *image, const ImageType image_type );</P>
<P>void  <STRONG>SyncImage</STRONG>( Image *image );</P>
<P>void  <STRONG>TextureImage</STRONG>( Image *image, Image *texture );</P>
<P>unsigned int  <STRONG>TransformRGBImage</STRONG>( Image *image, const ColorspaceType colorspace );</P>
<P>unsigned int  <STRONG>TransmitImage</STRONG>( Image *image, ImageInfo *image_info, const TransmitType sendmode, void *param1, void *param2 );</P>
<P>
<HR>
<H1><A NAME="function descriptions">
<FONT SIZE=-1>FUNCTION</FONT> 
<FONT SIZE=-1>DESCRIPTIONS</FONT></A></H1>
<P>
<H2><A NAME="allocateimage">AllocateImage</A></H2>
<blockquote>AllocateImage ( ) returns a pointer to an image structure initialized todefault values.; </blockquote><P>The format of the AllocateImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *AllocateImage ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_image_info%3A">image_info:</A></STRONG><BR>
<DD>
Many of the image default values are set from this structure.  For example, filename, compression, depth, background color, and others.
<P></P></DL></DL>
<P>
<H2><A NAME="allocateimagecolormap">AllocateImageColormap</A></H2>
<blockquote>AllocateImageColormap ( ) allocates an image colormap and initializesit to a linear gray colorspace. If the image already has a colormap, it is replaced. AllocateImageColormap ( ) returns True if successful, otherwise False if there is not enough memory.; </blockquote><P>The format of the AllocateImageColormap method is:</P>
<blockquote>unsigned int AllocateImageColormap ( <A HREF="types/Image.html">Image</A> *image, const unsigned int colors ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_image%3A">image:</A></STRONG><BR>
<DD>
The image.
<P></P>
<p><dt><STRONG><A NAME="item_o_colors%3A">colors:</A></STRONG><BR>
<DD>
The number of colors in the image colormap.
<P></P></DL></DL>
<P>
<H2><A NAME="allocatenextimage">AllocateNextImage</A></H2>
<blockquote>Use AllocateNextImage ( ) to initialize the next image in a sequence. Thenext member of image points to the newly allocated image. If there is amemory shortage, next is assigned NULL.; </blockquote><P>The format of the AllocateNextImage method is:</P>
<blockquote>void AllocateNextImage ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, <A HREF="types/Image.html">Image</A> *image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image_info:</STRONG><BR>
<DD>
Many of the image default values are set from this structure.  For example, filename, compression, depth, background color, and others.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P></DL></DL>
<P>
<H2><A NAME="animateimages">AnimateImages</A></H2>
<blockquote>AnimateImages ( ) repeatedly displays an image sequence to any X window screen. It returns a value other than 0 if successful. Check theexception member of image to determine the reason for any failure.; </blockquote><P>The format of the AnimateImages method is:</P>
<blockquote>unsigned int AnimateImages ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, <A HREF="types/Image.html">Image</A> *image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image_info:</STRONG><BR>
<DD>
The image info.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P></DL></DL>
<P>
<H2><A NAME="appendimages">AppendImages</A></H2>
<P>The <CODE>Append()</CODE> method takes a set of images and appends them to each other.  Each image in the set must have the equal width or equal height (or both). <CODE>Append()</CODE> returns a single image where each image in the original set is side-by-side if all the heights are equal or stacked on top of each other if all widths are equal.  On failure, a 
<FONT SIZE=-1>NULL</FONT> image is returned and exception describes the reason for the failure.</P>
<P>The format of the AppendImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *AppendImages ( <A HREF="types/Image.html">Image</A> *image, const unsigned int stack, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image sequence.
<P></P>
<p><dt><STRONG><A NAME="item_o_stack%3A">stack:</A></STRONG><BR>
<DD>
An unsigned value other than stacks rectangular image top-to-bottom otherwise left-to-right.
<P></P>
<p><dt><STRONG><A NAME="item_o_exception%3A">exception:</A></STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="averageimages">AverageImages</A></H2>
<P>The <CODE>Average()</CODE> method takes a set of images and averages them together.  Each image in the set must have the same width and the same height.  <CODE>Average()</CODE> returns a single image with each corresponding pixel component of each image averaged.  On failure, a 
<FONT SIZE=-1>NULL</FONT> image is returned and exception describes the reason for the failure.</P>
<P>The format of the AverageImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *AverageImages ( const <A HREF="types/Image.html">Image</A> *image, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image sequence.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="channelimage">ChannelImage</A></H2>
<P>Extract a channel from the image.  
<FONT SIZE=-1>A</FONT> channel is a particular color component of each pixel in the image.</P>
<P>The format of the ChannelImage method is:</P>
<blockquote>unsigned int ChannelImage ( <A HREF="types/Image.html">Image</A> *image, const ChannelType channel ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P>
<p><dt><STRONG><A NAME="item_o_channel%3A">channel:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> value of type ChannelType that identifies which channel to extract: Red, Green, Blue, or Opacity.
<P></P></DL></DL>
<P>
<H2><A NAME="cloneimage">CloneImage</A></H2>
<blockquote>CloneImage ( ) copies an image and returns the copy as a new image object. If the specified columns and rows is 0, an exact copy of the image isreturned, otherwise the pixel data is undefined and must be initializedwith the SetImagePixels ( ) and SyncImagePixels ( ) methods. A NULL imageis returned if the image cannot be cloned; check exception for the reasonwhy.; </blockquote><P>The format of the CloneImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *CloneImage ( <A HREF="types/Image.html">Image</A> *image, const unsigned int columns, const unsigned int rows, const unsigned int orphan, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P>
<p><dt><STRONG><A NAME="item_o_columns%3A">columns:</A></STRONG><BR>
<DD>
The number of columns in the copied
<P></P>
<p><dt><STRONG><A NAME="item_o_rows%3A">rows:</A></STRONG><BR>
<DD>
The number of rows in the copied image.
<P></P>
<p><dt><STRONG><A NAME="item_o_orphan%3A">orphan:</A></STRONG><BR>
<DD>
With a value other than 0, the cloned image is an orphan.  An orphan is a stand-alone image that is not assocated with an image list.  In effect, the next and previous members of the cloned image is set to 
<FONT SIZE=-1>NULL.</FONT>
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="cloneimageinfo">CloneImageInfo</A></H2>
<blockquote>CloneImageInfo ( ) makes a copy of the given image info, or if is NULL, a new one.; </blockquote><P>The format of the CloneImageInfo method is:</P>
<blockquote><A HREF="types/ImageInfo.html">ImageInfo</A> *CloneImageInfo ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image_info:</STRONG><BR>
<DD>
The image info.
<P></P></DL></DL>
<P>
<H2><A NAME="compositeimage">CompositeImage</A></H2>
<blockquote>CompositeImage ( ) returns the second image composited onto the first at thespecified offsets.; </blockquote><P>The format of the CompositeImage method is:</P>
<blockquote>unsigned int CompositeImage ( <A HREF="types/Image.html">Image</A> *image, const <A HREF="types/Enumerations.html#CompositeOperator">CompositeOperator</A> compose, <A HREF="types/Image.html">Image</A> *composite_image, const int x_offset, const int y_offset ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P>
<p><dt><STRONG><A NAME="item_o_compose%3A">compose:</A></STRONG><BR>
<DD>
This operator affects how the composite is applied to the image.  The default is Over.  Choose from these operators:
<P></P></DL></DL>
<PRE>
      OverCompositeOp       InCompositeOp         OutCompositeOP
      AtopCompositeOP       XorCompositeOP        PlusCompositeOP
      MinusCompositeOP      AddCompositeOP        SubtractCompositeOP
      DifferenceCompositeOP BumpmapCompositeOP    CopyCompositeOP
      DisplaceCompositeOP
=over 4</PRE>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_composite_image%3A">composite_image:</A></STRONG><BR>
<DD>
The composite image.
<P></P>
<p><dt><STRONG><A NAME="item_o_x_offset%3A">x_offset:</A></STRONG><BR>
<DD>
The column offset of the composited image.
<P></P>
<p><dt><STRONG><A NAME="item_o_y_offset%3A">y_offset:</A></STRONG><BR>
<DD>
The row offset of the composited image.
<P></P></DL></DL>
<P>
<H2><A NAME="cyclecolormapimage">CycleColormapImage</A></H2>
<P><CODE>CycleColormap()</CODE> displaces an image's colormap by a given number of positions.  If you cycle the colormap a number of times you can produce a psychodelic effect.</P>
<P>The format of the CycleColormapImage method is:</P>
<blockquote>CycleColormapImage ( <A HREF="types/Image.html">Image</A> *image, const int amount ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P>
<p><dt><STRONG><A NAME="item_o_amount%3A">amount:</A></STRONG><BR>
<DD>
Offset of the colormap this much.
<P></P></DL></DL>
<P>
<H2><A NAME="describeimage">DescribeImage</A></H2>
<blockquote>DescribeImage ( ) describes an image by printing its attributes to thefile. Attributes include the image width, height, size, and others.; </blockquote><P>The format of the DescribeImage method is:</P>
<blockquote>void DescribeImage ( <A HREF="types/Image.html">Image</A> *image, FILE *file, const unsigned int verbose ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P>
<p><dt><STRONG><A NAME="item_o_file%3A">file:</A></STRONG><BR>
<DD>
The file, typically stdout.
<P></P>
<p><dt><STRONG><A NAME="item_o_verbose%3A">verbose:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> value other than zero prints more detailed information about the image.
<P></P></DL></DL>
<P>
<H2><A NAME="destroyimage">DestroyImage</A></H2>
<blockquote>DestroyImage ( ) deallocates memory associated with an image.; </blockquote><P>The format of the DestroyImage method is:</P>
<blockquote>void DestroyImage ( <A HREF="types/Image.html">Image</A> *image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P></DL></DL>
<P>
<H2><A NAME="destroyimageinfo">DestroyImageInfo</A></H2>
<blockquote>DestroyImageInfo ( ) deallocates memory associated with an <A HREF="types/ImageInfo.html">ImageInfo</A> structure.; </blockquote><P>The format of the DestroyImageInfo method is:</P>
<blockquote>void DestroyImageInfo ( <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image_info:</STRONG><BR>
<DD>
The image info.
<P></P></DL></DL>
<P>
<H2><A NAME="destroyimages">DestroyImages</A></H2>
<blockquote>DestroyImages ( ) deallocates memory associated with all the images in asequence.; </blockquote><P>The format of the DestroyImages method is:</P>
<blockquote>void DestroyImages ( <A HREF="types/Image.html">Image</A> *image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image sequence.
<P></P></DL></DL>
<P>
<H2><A NAME="displayimages">DisplayImages</A></H2>
<blockquote>DisplayImages ( ) displays an image sequence to any X windowscreen. It returns a value other than 0 if successful. Check theexception member of image to determine the reason for any failure.; </blockquote><P>The format of the AllocateNextImage method is:</P>
<blockquote>unsigned int DisplayImages ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, <A HREF="types/Image.html">Image</A> *image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image_info:</STRONG><BR>
<DD>
The image info.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P></DL></DL>
<P>
<H2><A NAME="getimagedepth">GetImageDepth</A></H2>
<blockquote>GetImageDepth ( ) returns the depth of the image, either 8 or 16 bits. Bydefault, pixels components are stored as 16-bit two byte unsigned shortintegers that range in value from 0 to 65535. However, if all the pixelshave lower-order bytes of zero, the image is considered to have a depth of8-bit.; </blockquote><P>The format of the GetImageDepth method is:</P>
<blockquote>unsigned int GetImageDepth ( <A HREF="types/Image.html">Image</A> *image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P></DL></DL>
<P>
<H2><A NAME="getimageinfo">GetImageInfo</A></H2>
<blockquote>GetImageInfo ( ) initializes the <A HREF="types/ImageInfo.html">ImageInfo</A> structure to default values.; </blockquote><P>The format of the GetImageInfo method is:</P>
<blockquote>void GetImageInfo ( <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image_info:</STRONG><BR>
<DD>
The image info.
<P></P></DL></DL>
<P>
<H2><A NAME="getimagetype">GetImageType</A></H2>
<blockquote>GetImageType ( ) returns the type of image:; </blockquote><PRE>
      Bilevel        Grayscale       GrayscaleMatte
      Palette        PaletteMatte    TrueColor
      TrueColorMatte ColorSeparation ColorSeparationMatte</PRE>
<P>The format of the GetImageType method is:</P>
<blockquote><A HREF="types/Enumerations.html#ImageType">ImageType</A> GetImageType ( <A HREF="types/Image.html">Image</A> *image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P></DL></DL>
<P>
<H2><A NAME="getnextimage">GetNextImage</A></H2>
<blockquote>GetNextImage ( ) returns the next image in an image sequence.; </blockquote><P>The format of the GetNextImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *GetNextImage ( <A HREF="types/Image.html">Image</A> *image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P></DL></DL>
<P>
<H2><A NAME="getnumberscenes">GetNumberScenes</A></H2>
<P>Method GetNumberScenes returns the number of images in an image sequence.</P>
<P>The format of the GetNumberScenes method is:</P>
<blockquote>unsigned int GetNumberScenes ( const <A HREF="types/Image.html">Image</A> *image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P></DL></DL>
<P>
<H2><A NAME="getpixelpacket">GetPixelPacket</A></H2>
<P>Method GetPixelPacket initializes the PixelPacket structure.</P>
<P>The format of the GetPixelPacket method is:</P>
<blockquote>void GetPixelPacket ( <A HREF="types/PixelPacket.html">PixelPacket</A> *pixel ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_pixel%3A">pixel:</A></STRONG><BR>
<DD>
Specifies a pointer to a PixelPacket structure.
<P></P></DL></DL>
<P>
<H2><A NAME="isgeometry">IsGeometry</A></H2>
<P>Method IsGeometry returns True if the geometry specification is valid as determined by ParseGeometry.</P>
<P>The format of the IsGeometry method is:</P>
<blockquote>unsigned int IsGeometry ( const char *geometry ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_status%3A">status:</A></STRONG><BR>
<DD>
Method IsGeometry returns True if the geometry specification is valid otherwise False is returned.
<P></P>
<p><dt><STRONG><A NAME="item_o_geometry%3A">geometry:</A></STRONG><BR>
<DD>
This string is the geometry specification.
<P></P></DL></DL>
<P>
<H2><A NAME="isimagesequal">IsImagesEqual</A></H2>
<P>Method IsImagesEqual measures the difference between two images.  The error is computed by summing over all pixels in an image the distance squared in 
<FONT SIZE=-1>RGB</FONT> space between each image pixel and its corresponding pixel in the reference image.  These values are computed:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_mean_error_per_pixel%3A">mean_error_per_pixel:</A></STRONG><BR>
<DD>
This value is the mean error for any single pixel in the image.
<P></P>
<p><dt><STRONG><A NAME="item_o_normalized_mean_square_error%3A">normalized_mean_square_error:</A></STRONG><BR>
<DD>
This value is the normalized mean quantization error for any single pixel in the image.  This distance measure is normalized to a range between 0 and 1.  It is independent of the range of red, green, and blue values in the image.
<P></P>
<p><dt><STRONG><A NAME="item_o_normalized_maximum_square_error%3A">normalized_maximum_square_error:</A></STRONG><BR>
<DD>
Thsi value is the normalized maximum quantization error for any single pixel in the image.  This distance measure is normalized to a range between 0 and 1.  It is independent of the range of red, green, and blue values in your image.
<P></P></DL></DL>
<P>The format of the IsImagesEqual method is:</P>
<blockquote>unsigned int IsImagesEqual ( <A HREF="types/Image.html">Image</A> *image, <A HREF="types/Image.html">Image</A> *reference ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows.</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
Specifies a pointer to an Image structure.
<P></P>
<p><dt><STRONG><A NAME="item_o_reference%3A">reference:</A></STRONG><BR>
<DD>
Specifies a pointer to an Image structure.
<P></P></DL></DL>
<P>
<H2><A NAME="isimagetainted">IsImageTainted</A></H2>
<P>Method IsImageTainted returns True if the image has been altered since it was first read or if any image in the sequence has a difference magic or filename.</P>
<P>The format of the IsImageTainted method is:</P>
<blockquote>unsigned int IsImageTainted ( const <A HREF="types/Image.html">Image</A> *image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>status:</STRONG><BR>
<DD>
Method IsImageTainted returns True if the image has been altered since it was first read.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The address of a structure of type Image.
<P></P></DL></DL>
<P>
<H2><A NAME="issubimage">IsSubimage</A></H2>
<P>Method IsSubimage returns True if the geometry is a valid subimage specification (e.g.  [1], [1-9], [1,7,4]).</P>
<P>The format of the IsSubimage method is:</P>
<blockquote>unsigned int IsSubimage ( const char *geometry, const unsigned int pedantic ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>status:</STRONG><BR>
<DD>
Method IsSubimage returns True if the geometry is a valid subimage specification otherwise False is returned.
<P></P>
<p><dt><STRONG>geometry:</STRONG><BR>
<DD>
This string is the geometry specification.
<P></P>
<p><dt><STRONG><A NAME="item_o_pedantic%3A">pedantic:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> value other than 0 invokes a more restriction set of conditions for a valid specification (e.g.  [1], [1-4], [4-1]).
<P></P></DL></DL>
<P>
<H2><A NAME="listtogroupimage">ListToGroupImage</A></H2>
<P>Method ListToGroupImage converts a linked list of images to a sequential array.</P>
<P>The format of the ListToGroupImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> **ListToGroupImage ( <A HREF="types/Image.html">Image</A> *image, unsigned int *number_images ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_images%3A">images:</A></STRONG><BR>
<DD>
Method ListToGroupImage converts a linked list of images to a sequential array and returns the array..
<P></P>
<p><dt><STRONG>images:</STRONG><BR>
<DD>
The address of a structure of type Image; returned from ReadImage.
<P></P>
<p><dt><STRONG><A NAME="item_o_number_images%3A">number_images:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> pointer to an unsigned integer.  The number of images in the image array is returned here.
<P></P></DL></DL>
<P>
<H2><A NAME="mogrifyimage">MogrifyImage</A></H2>
<P>Method MogrifyImage applies image processing options to an image as prescribed by command line options.</P>
<P>The format of the MogrifyImage method is:</P>
<blockquote>unsigned int MogrifyImage ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, const int argc, char **argv, <A HREF="types/Image.html">Image</A> **image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image_info:</STRONG><BR>
<DD>
Specifies a pointer to an ImageInfo structure.
<P></P>
<p><dt><STRONG><A NAME="item_o_argc%3A">argc:</A></STRONG><BR>
<DD>
Specifies a pointer to an integer describing the number of elements in the argument vector.
<P></P>
<p><dt><STRONG><A NAME="item_o_argv%3A">argv:</A></STRONG><BR>
<DD>
Specifies a pointer to a text array containing the command line arguments.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The address of a structure of type Image; returned from ReadImage.
<P></P></DL></DL>
<P>
<H2><A NAME="mogrifyimages">MogrifyImages</A></H2>
<P>Method MogrifyImages applies next processing options to a sequence of images as prescribed by command line options.</P>
<P>The format of the MogrifyImage method is:</P>
<blockquote>unsigned int MogrifyImages ( const <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, const int argc, char **argv, <A HREF="types/Image.html">Image</A> **images ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image_info:</STRONG><BR>
<DD>
Specifies a pointer to an ImageInfo structure.
<P></P>
<p><dt><STRONG>argc:</STRONG><BR>
<DD>
Specifies a pointer to an integer describing the number of elements in the argument vector.
<P></P>
<p><dt><STRONG>argv:</STRONG><BR>
<DD>
Specifies a pointer to a text array containing the command line arguments.
<P></P>
<p><dt><STRONG>images:</STRONG><BR>
<DD>
The address of a structure of type Image; returned from ReadImage.
<P></P></DL></DL>
<P>
<H2><A NAME="mosaicimages">MosaicImages</A></H2>
<P>Method MosaicImages inlays a number of image to form a single coherent picture.</P>
<P>The format of the MosaicImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *MosaicImages ( const <A HREF="types/Image.html">Image</A> *image, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The address of a structure of type Image; returned from ReadImage.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="parseimagegeometry">ParseImageGeometry</A></H2>
<P>Method ParseImageGeometry parses a geometry specification and returns the width, height, x, and y values.  It also returns flags that indicates which of the four values (width, height, xoffset, yoffset) were located in the string, and whether the x and y values are negative.  In addition,</P>
<P>The format of the ParseImageGeometry method is:</P>
<blockquote>int ParseImageGeometry ( const char *geometry, int *x, int *y, unsigned int *width, unsigned int *height ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_flags%3A">flags:</A></STRONG><BR>
<DD>
Method ParseImageGeometry returns a bitmask that indicates which of the four values were located in the geometry string.
<P></P>
<p><dt><STRONG><A NAME="item_o_image_geometry%3A">image_geometry:</A></STRONG><BR>
<DD>
Specifies a character string representing the geometry specification.
<P></P>
<p><dt><STRONG><A NAME="item_o_x%2Cy%3A">x,y:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> pointer to an integer.  The x and y offset as determined by the geometry specification is returned here.
<P></P>
<p><dt><STRONG><A NAME="item_o_width%2Cheight%3A">width,height:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> pointer to an unsigned integer.  The width and height as determined by the geometry specification is returned here.
<P></P></DL></DL>
<P>
<H2><A NAME="rgbtransformimage">RGBTransformImage</A></H2>
<P>Method RGBTransformImage converts the reference image from 
<FONT SIZE=-1>RGB</FONT> to an alternate colorspace.  The transformation matrices are not the standard ones: the weights are rescaled to normalized the range of the transformed values to be [0..MaxRGB].</P>
<P>The format of the RGBTransformImage method is:</P>
<blockquote>unsigned int RGBTransformImage ( <A HREF="types/Image.html">Image</A> *image, const <A HREF="types/Enumerations.html#ColorspaceType">ColorspaceType</A> colorspace ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The address of a structure of type Image; returned from ReadImage.
<P></P>
<p><dt><STRONG><A NAME="item_o_colorspace%3A">colorspace:</A></STRONG><BR>
<DD>
An unsigned integer value that indicates which colorspace to transform the image.
<P></P></DL></DL>
<P>
<H2><A NAME="setimage">SetImage</A></H2>
<P>Method SetImage initializes the reference image to the background color.</P>
<P>The format of the SetImage method is:</P>
<blockquote>void SetImage ( <A HREF="types/Image.html">Image</A> *image, opacity ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The address of a structure of type Image; returned from ReadImage.
<P></P>
<p><dt><STRONG><A NAME="item_o_opacity%3A">opacity:</A></STRONG><BR>
<DD>
The transparency of the background color.
<P></P></DL></DL>
<P>
<H2><A NAME="setimagedepth">SetImageDepth</A></H2>
<P>Method SetImageDepth sets the depth of the image.</P>
<P>The format of the SetImageDepth method is:</P>
<blockquote>unsigned int SetImageDepth ( <A HREF="types/Image.html">Image</A> *image, const unsigned int ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>status:</STRONG><BR>
<DD>
Method SetImageDepth returns True if the image depth is set.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The address of a structure of type Image.
<P></P>
<p><dt><STRONG><A NAME="item_o_depth%3A">depth:</A></STRONG><BR>
<DD>
specified the image depth.
<P></P></DL></DL>
<P>
<H2><A NAME="setimageopacity">SetImageOpacity</A></H2>
<P>Method SetImageOpacity initializes the opacity channel of the reference image to the specified value.  If the image already has a matte channel it is attenuated with the opacity value.</P>
<P>The format of the SetImageOpacity method is:</P>
<blockquote>void SetImageOpacity ( <A HREF="types/Image.html">Image</A> *image, const unsigned int opacity ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The address of a structure of type Image; returned from ReadImage.
<P></P>
<p><dt><STRONG>opacity:</STRONG><BR>
<DD>
The level of transparency.
<P></P></DL></DL>
<P>
<H2><A NAME="setimagetype">SetImageType</A></H2>
<P>Method SetImageType sets the type of the image.</P>
<P>The format of the SetImageType method is:</P>
<blockquote>SetImageType ( <A HREF="types/Image.html">Image</A> *image, const <A HREF="types/Enumerations.html#ImageType">ImageType</A> image_type ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>status:</STRONG><BR>
<DD>
Method SetImageDepth returns True if the image depth is set.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The address of a structure of type Image.
<P></P>
<p><dt><STRONG><A NAME="item_o_image_type%3A">image_type:</A></STRONG><BR>
<DD>
specified the image type.
<P></P></DL></DL>
<P>
<H2><A NAME="sortcolormapbyintentsity">SortColormapByIntentsity</A></H2>
<P>Method SortColormapByIntensity sorts the colormap of a PseudoClass image by decreasing color intensity.</P>
<P>The format of the SortColormapByIntensity method is:</P>
<PRE>
    unsigned int SortColormapByIntensity(Image *image)</PRE>
<P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> pointer to a Image structure.
<P></P></DL></DL>
<P>
<H2><A NAME="syncimage">SyncImage</A></H2>
<P>Method SyncImage initializes the red, green, and blue intensities of each pixel as defined by the colormap index.</P>
<P>The format of the SyncImage method is:</P>
<blockquote>void SyncImage ( <A HREF="types/Image.html">Image</A> *image ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The address of a structure of type Image.
<P></P></DL></DL>
<P>
<H2><A NAME="textureimage">TextureImage</A></H2>
<P>Method TextureImage layers a texture onto the background of an image.</P>
<P>The format of the TextureImage method is:</P>
<blockquote>void TextureImage ( <A HREF="types/Image.html">Image</A> *image, <A HREF="types/Image.html">Image</A> *texture ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The address of a structure of type Image; returned from ReadImage.
<P></P>
<p><dt><STRONG><A NAME="item_o_texture%3A">texture:</A></STRONG><BR>
<DD>
This image contains the texture to layer on the background.
<P></P></DL></DL>
<P>
<H2><A NAME="transformrgbimage">TransformRGBImage</A></H2>
<P>Method TransformRGBImage converts the reference image from an alternate colorspace.  The transformation matrices are not the standard ones: the weights are rescaled to normalize the range of the transformed values to be [0..MaxRGB].</P>
<P>The format of the TransformRGBImage method is:</P>
<blockquote>unsigned int TransformRGBImage ( <A HREF="types/Image.html">Image</A> *image, const <A HREF="types/Enumerations.html#ColorspaceType">ColorspaceType</A> colorspace ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The address of a structure of type Image; returned from ReadImage.
<P></P>
<p><dt><STRONG>colorspace:</STRONG><BR>
<DD>
An unsigned integer value defines which colorspace to transform the image to.
<P></P></DL></DL>
<P>
<H2><A NAME="transmitimage">TransmitImage</A></H2>
<P>Method TransmitImage transmit an image to a variety of destinations.  It is used primarily in 
<FONT SIZE=-1>CGI</FONT> and 
<FONT SIZE=-1>ISAPI</FONT> programs to send an image to a client using either disk, blobs, streaming, or via the normal in memory image structure.</P>
<P>The format of the TransmitImage method is:</P>
<blockquote>unsigned int TransmitImage ( <A HREF="types/Image.html">Image</A> *image, <A HREF="types/ImageInfo.html">ImageInfo</A> *image_info, const TransmitType sendmode, void *param1, void *param2 ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The address of a structure of type Image; returned from ReadImage.
<P></P>
<p><dt><STRONG>image_info:</STRONG><BR>
<DD>
Specifies a pointer to an ImageInfo structure.
<P></P>
<p><dt><STRONG><A NAME="item_o_sendmode%3A">sendmode:</A></STRONG><BR>
<DD>
An unsigned integer value defines which transmit mode to send the image with.
<P></P>
<p><dt><STRONG><A NAME="item_o_param1%3A">param1:</A></STRONG><BR>
<DD>
An void pointer whose meaning depends on the transmit mode.
<P></P>
<p><dt><STRONG><A NAME="item_o_param2%3A">param2:</A></STRONG><BR>
<DD>
An void pointer whose meaning depends on the transmit mode.
</DL></DL>

</BODY>

</HTML>
